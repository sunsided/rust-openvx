/* automatically generated by rust-bindgen 0.55.1 */

#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

pub const VX_MAX_IMPLEMENTATION_NAME: u32 = 64;
pub const VX_MAX_KERNEL_NAME: u32 = 256;
pub const VX_MAX_LOG_MESSAGE_LEN: u32 = 1024;
pub const VX_MAX_REFERENCE_NAME: u32 = 64;
pub const VX_VENDOR_MASK: u32 = 4293918720;
pub const VX_TYPE_MASK: u32 = 1048320;
pub const VX_LIBRARY_MASK: u32 = 1044480;
pub const VX_KERNEL_MASK: u32 = 4095;
pub const VX_ATTRIBUTE_ID_MASK: u32 = 255;
pub const VX_ENUM_TYPE_MASK: u32 = 1044480;
pub const VX_ENUM_MASK: u32 = 4095;
pub const VX_FMT_REF: &'static [u8; 3usize] = b"%p\0";
pub const VX_FMT_SIZE: &'static [u8; 4usize] = b"%zu\0";
pub const VX_SCALE_UNITY: u32 = 1024;
pub const VX_SCALE_PYRAMID_HALF: f64 = 0.5;
#[doc = "< \\brief The Khronos Group"]
pub const vx_vendor_id_e_VX_ID_KHRONOS: vx_vendor_id_e = 0;
#[doc = "< \\brief Texas Instruments, Inc."]
pub const vx_vendor_id_e_VX_ID_TI: vx_vendor_id_e = 1;
#[doc = "< \\brief Qualcomm, Inc."]
pub const vx_vendor_id_e_VX_ID_QUALCOMM: vx_vendor_id_e = 2;
#[doc = "< \\brief NVIDIA Corporation"]
pub const vx_vendor_id_e_VX_ID_NVIDIA: vx_vendor_id_e = 3;
#[doc = "< \\brief ARM Ltd."]
pub const vx_vendor_id_e_VX_ID_ARM: vx_vendor_id_e = 4;
#[doc = "< \\brief Berkley Design Technology, Inc."]
pub const vx_vendor_id_e_VX_ID_BDTI: vx_vendor_id_e = 5;
#[doc = "< \\brief Renasas Electronics"]
pub const vx_vendor_id_e_VX_ID_RENESAS: vx_vendor_id_e = 6;
#[doc = "< \\brief Vivante Corporation"]
pub const vx_vendor_id_e_VX_ID_VIVANTE: vx_vendor_id_e = 7;
#[doc = "< \\brief Xilinx Inc."]
pub const vx_vendor_id_e_VX_ID_XILINX: vx_vendor_id_e = 8;
#[doc = "< \\brief Axis Communications"]
pub const vx_vendor_id_e_VX_ID_AXIS: vx_vendor_id_e = 9;
#[doc = "< \\brief Movidius Ltd."]
pub const vx_vendor_id_e_VX_ID_MOVIDIUS: vx_vendor_id_e = 10;
#[doc = "< \\brief Samsung Electronics"]
pub const vx_vendor_id_e_VX_ID_SAMSUNG: vx_vendor_id_e = 11;
#[doc = "< \\brief Freescale Semiconductor"]
pub const vx_vendor_id_e_VX_ID_FREESCALE: vx_vendor_id_e = 12;
#[doc = "< \\brief Advanced Micro Devices"]
pub const vx_vendor_id_e_VX_ID_AMD: vx_vendor_id_e = 13;
#[doc = "< \\brief Broadcom Corporation"]
pub const vx_vendor_id_e_VX_ID_BROADCOM: vx_vendor_id_e = 14;
#[doc = "< \\brief Intel Corporation"]
pub const vx_vendor_id_e_VX_ID_INTEL: vx_vendor_id_e = 15;
#[doc = "< \\brief Marvell Technology Group Ltd."]
pub const vx_vendor_id_e_VX_ID_MARVELL: vx_vendor_id_e = 16;
#[doc = "< \\brief MediaTek, Inc."]
pub const vx_vendor_id_e_VX_ID_MEDIATEK: vx_vendor_id_e = 17;
#[doc = "< \\brief STMicroelectronics"]
pub const vx_vendor_id_e_VX_ID_ST: vx_vendor_id_e = 18;
#[doc = "< \\brief CEVA DSP"]
pub const vx_vendor_id_e_VX_ID_CEVA: vx_vendor_id_e = 19;
#[doc = "< \\brief Itseez, Inc."]
pub const vx_vendor_id_e_VX_ID_ITSEEZ: vx_vendor_id_e = 20;
#[doc = "< \\brief Imagination Technologies"]
pub const vx_vendor_id_e_VX_ID_IMAGINATION: vx_vendor_id_e = 21;
#[doc = "< \\brief NXP Semiconductors"]
pub const vx_vendor_id_e_VX_ID_NXP: vx_vendor_id_e = 22;
#[doc = "< \\brief Videantis"]
pub const vx_vendor_id_e_VX_ID_VIDEANTIS: vx_vendor_id_e = 23;
#[doc = "< \\brief Synopsys"]
pub const vx_vendor_id_e_VX_ID_SYNOPSYS: vx_vendor_id_e = 24;
#[doc = "< \\brief Cadence"]
pub const vx_vendor_id_e_VX_ID_CADENCE: vx_vendor_id_e = 25;
#[doc = "< \\brief Huawei"]
pub const vx_vendor_id_e_VX_ID_HUAWEI: vx_vendor_id_e = 26;
#[doc = "< \\brief Socionext"]
pub const vx_vendor_id_e_VX_ID_SOCIONEXT: vx_vendor_id_e = 27;
#[doc = "< \\brief For use by vxAllocateUserKernelId and vxAllocateUserKernelLibraryId"]
pub const vx_vendor_id_e_VX_ID_USER: vx_vendor_id_e = 4094;
pub const vx_vendor_id_e_VX_ID_MAX: vx_vendor_id_e = 4095;
#[doc = " \\brief For use by all Kernel authors until they can obtain an assigned ID."]
pub const vx_vendor_id_e_VX_ID_DEFAULT: vx_vendor_id_e = 4095;
#[doc = " \\brief The Vendor ID of the Implementation. As new vendors submit their"]
#[doc = " implementations, this enumeration will grow."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_vendor_id_e = ::std::os::raw::c_uint;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
#[doc = " \\brief An 8 bit ASCII character."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_char = ::std::os::raw::c_char;
#[doc = " \\brief An 8-bit unsigned value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_uint8 = u8;
#[doc = " \\brief A 16-bit unsigned value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_uint16 = u16;
#[doc = " \\brief A 32-bit unsigned value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_uint32 = u32;
#[doc = " \\brief A 64-bit unsigned value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_uint64 = u64;
#[doc = " \\brief An 8-bit signed value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_int8 = i8;
#[doc = " \\brief A 16-bit signed value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_int16 = i16;
#[doc = " \\brief A 32-bit signed value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_int32 = i32;
#[doc = " \\brief A 64-bit signed value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_int64 = i64;
pub type vx_bitfield = u32;
#[doc = " \\brief A 32-bit float value."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_float32 = f32;
#[doc = " \\brief A 64-bit float value (aka double)."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_float64 = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_reference {
    _unused: [u8; 0],
}
#[doc = " \\brief A generic opaque reference to any object within OpenVX."]
#[doc = " \\details A user of OpenVX should not assume that this can be cast directly to anything;"]
#[doc = " however, any object in OpenVX can be cast back to this for the purposes of"]
#[doc = " querying attributes of the object or for passing the object as a parameter to"]
#[doc = " functions that take a <tt>\\ref vx_reference</tt> type."]
#[doc = " If the API does not take that specific type but may take others, an"]
#[doc = " error may be returned from the API."]
#[doc = " \\ingroup group_reference"]
pub type vx_reference = *mut _vx_reference;
#[doc = " \\brief Sets the standard enumeration type size to be a fixed quantity."]
#[doc = " \\details All enumerable fields must use this type as the container to"]
#[doc = " enforce enumeration ranges and sizeof() operations."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_enum = i32;
#[doc = " \\brief A wrapper of <tt>size_t</tt> to keep the naming convention uniform."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_size = size_t;
#[doc = " \\brief Used to hold a VX_DF_IMAGE code to describe the pixel format and color space."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_df_image = u32;
#[doc = " \\brief Holds the address of a variable where the map/unmap functions return a map identifier."]
#[doc = " \\ingroup group_image"]
pub type vx_map_id = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_scalar {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a scalar."]
#[doc = " \\details A scalar can be up to 64 bits wide."]
#[doc = " \\see vxCreateScalar"]
#[doc = " \\ingroup group_scalar"]
#[doc = " \\extends vx_reference"]
pub type vx_scalar = *mut _vx_scalar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_image {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to an image."]
#[doc = " \\see vxCreateImage"]
#[doc = " \\ingroup group_image"]
#[doc = " \\extends vx_reference"]
pub type vx_image = *mut _vx_image;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_kernel {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to the descriptor of a kernel."]
#[doc = " \\see vxGetKernelByName"]
#[doc = " \\see vxGetKernelByEnum"]
#[doc = " \\ingroup group_kernel"]
#[doc = " \\extends vx_reference"]
pub type vx_kernel = *mut _vx_kernel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_parameter {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a single parameter."]
#[doc = " \\see vxGetParameterByIndex"]
#[doc = " \\ingroup group_parameter"]
#[doc = " \\extends vx_reference"]
pub type vx_parameter = *mut _vx_parameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_node {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a kernel node."]
#[doc = " \\see vxCreateGenericNode"]
#[doc = " \\ingroup group_node"]
#[doc = " \\extends vx_reference"]
pub type vx_node = *mut _vx_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_graph {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a graph"]
#[doc = " \\see vxCreateGraph"]
#[doc = " \\ingroup group_graph"]
#[doc = " \\extends vx_reference"]
pub type vx_graph = *mut _vx_graph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_context {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to the implementation context."]
#[doc = " \\see vxCreateContext"]
#[doc = " \\ingroup group_context"]
#[doc = " \\extends vx_reference"]
pub type vx_context = *mut _vx_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_delay {
    _unused: [u8; 0],
}
#[doc = " \\brief The delay object. This is like a ring buffer of objects that is"]
#[doc = " maintained by the OpenVX implementation."]
#[doc = " \\see vxCreateDelay"]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_delay"]
pub type vx_delay = *mut _vx_delay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_lut {
    _unused: [u8; 0],
}
#[doc = " \\brief The Look-Up Table (LUT) Object."]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_lut"]
pub type vx_lut = *mut _vx_lut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_distribution {
    _unused: [u8; 0],
}
#[doc = " \\brief The Distribution object. This has a user-defined number of bins over"]
#[doc = " a user-defined range (within a uint32_t range)."]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_distribution"]
pub type vx_distribution = *mut _vx_distribution;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_matrix {
    _unused: [u8; 0],
}
#[doc = " \\brief The Matrix Object. An MxN matrix of some unit type."]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_matrix"]
pub type vx_matrix = *mut _vx_matrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_pyramid {
    _unused: [u8; 0],
}
#[doc = " \\brief The Image Pyramid object. A set of scaled images."]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_pyramid"]
pub type vx_pyramid = *mut _vx_pyramid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_threshold {
    _unused: [u8; 0],
}
#[doc = " \\brief The Threshold Object. A thresholding object contains the types and"]
#[doc = " limit values of the thresholding required."]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_threshold"]
pub type vx_threshold = *mut _vx_threshold;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_convolution {
    _unused: [u8; 0],
}
#[doc = " \\brief The Convolution Object. A user-defined convolution kernel of MxM elements."]
#[doc = " \\extends vx_reference"]
#[doc = " \\ingroup group_convolution"]
pub type vx_convolution = *mut _vx_convolution;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_remap {
    _unused: [u8; 0],
}
#[doc = " \\brief The remap table Object. A remap table contains per-pixel mapping of"]
#[doc = " output pixels to input pixels."]
#[doc = " \\ingroup group_remap"]
pub type vx_remap = *mut _vx_remap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_array {
    _unused: [u8; 0],
}
#[doc = " \\brief The Array Object. Array is a strongly-typed container for other data structures."]
#[doc = " \\ingroup group_array"]
pub type vx_array = *mut _vx_array;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_object_array {
    _unused: [u8; 0],
}
#[doc = " \\brief The ObjectArray Object. ObjectArray is a strongly-typed container of OpenVX data-objects."]
#[doc = " \\ingroup group_object_array"]
pub type vx_object_array = *mut _vx_object_array;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_tensor_t {
    _unused: [u8; 0],
}
#[doc = " \\brief The multidimensional data object (Tensor)."]
#[doc = " \\see vxCreateTensor"]
#[doc = " \\ingroup group_object_tensor"]
#[doc = " \\extends vx_reference"]
pub type vx_tensor = *mut _vx_tensor_t;
#[doc = " \\brief The \"false\" value."]
pub const vx_bool_e_vx_false_e: vx_bool_e = 0;
#[doc = " \\brief The \"true\" value."]
pub const vx_bool_e_vx_true_e: vx_bool_e = 1;
#[doc = " \\brief A Boolean value."]
#[doc = " This allows 0 to be FALSE, as it is in C, and any non-zero to be TRUE."]
#[doc = " \\code"]
#[doc = " vx_bool ret = vx_true_e;"]
#[doc = " if (ret) printf(\"true!\\n\");"]
#[doc = " ret = vx_false_e;"]
#[doc = " if (!ret) printf(\"false!\\n\");"]
#[doc = " \\endcode"]
#[doc = " This would print both strings."]
#[doc = " \\see vx_bool"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_bool_e = ::std::os::raw::c_uint;
#[doc = " \\brief A formal boolean type with known fixed size."]
#[doc = " \\see vx_bool_e"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_bool = vx_enum;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_meta_format {
    _unused: [u8; 0],
}
#[doc = " \\brief This object is used by output validation functions to specify the meta data"]
#[doc = " of the expected output data object."]
#[doc = " \\note When the actual output object of the user node is virtual, the information"]
#[doc = " given through the vx_meta_format object allows the OpenVX framework to automatically"]
#[doc = " create the data object when meta data were not specified by the application at object"]
#[doc = " creation time."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_meta_format = *mut _vx_meta_format;
#[doc = "< \\brief An invalid type value. When passed an error must be returned."]
pub const vx_type_e_VX_TYPE_INVALID: vx_type_e = 0;
#[doc = "< \\brief A <tt>\\ref vx_char</tt>."]
pub const vx_type_e_VX_TYPE_CHAR: vx_type_e = 1;
#[doc = "< \\brief A <tt>\\ref vx_int8</tt>."]
pub const vx_type_e_VX_TYPE_INT8: vx_type_e = 2;
#[doc = "< \\brief A <tt>\\ref vx_uint8</tt>."]
pub const vx_type_e_VX_TYPE_UINT8: vx_type_e = 3;
#[doc = "< \\brief A <tt>\\ref vx_int16</tt>."]
pub const vx_type_e_VX_TYPE_INT16: vx_type_e = 4;
#[doc = "< \\brief A <tt>\\ref vx_uint16</tt>."]
pub const vx_type_e_VX_TYPE_UINT16: vx_type_e = 5;
#[doc = "< \\brief A <tt>\\ref vx_int32</tt>."]
pub const vx_type_e_VX_TYPE_INT32: vx_type_e = 6;
#[doc = "< \\brief A <tt>\\ref vx_uint32</tt>."]
pub const vx_type_e_VX_TYPE_UINT32: vx_type_e = 7;
#[doc = "< \\brief A <tt>\\ref vx_int64</tt>."]
pub const vx_type_e_VX_TYPE_INT64: vx_type_e = 8;
#[doc = "< \\brief A <tt>\\ref vx_uint64</tt>."]
pub const vx_type_e_VX_TYPE_UINT64: vx_type_e = 9;
#[doc = "< \\brief A <tt>\\ref vx_float32</tt>."]
pub const vx_type_e_VX_TYPE_FLOAT32: vx_type_e = 10;
#[doc = "< \\brief A <tt>\\ref vx_float64</tt>."]
pub const vx_type_e_VX_TYPE_FLOAT64: vx_type_e = 11;
#[doc = "< \\brief A <tt>\\ref vx_enum</tt>. Equivalent in size to a <tt>\\ref vx_int32</tt>."]
pub const vx_type_e_VX_TYPE_ENUM: vx_type_e = 12;
#[doc = "< \\brief A <tt>\\ref vx_size</tt>."]
pub const vx_type_e_VX_TYPE_SIZE: vx_type_e = 13;
#[doc = "< \\brief A <tt>\\ref vx_df_image</tt>."]
pub const vx_type_e_VX_TYPE_DF_IMAGE: vx_type_e = 14;
#[doc = "< \\brief A <tt>\\ref vx_bool</tt>."]
pub const vx_type_e_VX_TYPE_BOOL: vx_type_e = 16;
#[doc = "< \\brief A <tt>\\ref vx_rectangle_t</tt>."]
pub const vx_type_e_VX_TYPE_RECTANGLE: vx_type_e = 32;
#[doc = "< \\brief A <tt>\\ref vx_keypoint_t</tt>."]
pub const vx_type_e_VX_TYPE_KEYPOINT: vx_type_e = 33;
#[doc = "< \\brief A <tt>\\ref vx_coordinates2d_t</tt>."]
pub const vx_type_e_VX_TYPE_COORDINATES2D: vx_type_e = 34;
#[doc = "< \\brief A <tt>\\ref vx_coordinates3d_t</tt>."]
pub const vx_type_e_VX_TYPE_COORDINATES3D: vx_type_e = 35;
#[doc = "< \\brief A <tt>\\ref vx_coordinates2df_t</tt>."]
pub const vx_type_e_VX_TYPE_COORDINATES2DF: vx_type_e = 36;
#[doc = "< \\brief A <tt>\\ref vx_hog_t</tt>."]
pub const vx_type_e_VX_TYPE_HOG_PARAMS: vx_type_e = 40;
#[doc = "< \\brief A <tt>\\ref vx_hough_lines_p_t</tt>."]
pub const vx_type_e_VX_TYPE_HOUGH_LINES_PARAMS: vx_type_e = 41;
#[doc = "< \\brief A <tt>\\ref vx_line2d_t</tt>."]
pub const vx_type_e_VX_TYPE_LINE_2D: vx_type_e = 42;
#[doc = "< \\brief A <tt>\\ref vx_tensor_matrix_multiply_params_t</tt>."]
pub const vx_type_e_VX_TYPE_TENSOR_MATRIX_MULTIPLY_PARAMS: vx_type_e = 43;
#[doc = "< \\brief A user-defined struct base index."]
pub const vx_type_e_VX_TYPE_USER_STRUCT_START: vx_type_e = 256;
#[doc = "< \\brief A vendor-defined struct base index."]
pub const vx_type_e_VX_TYPE_VENDOR_STRUCT_START: vx_type_e = 1024;
#[doc = "< \\brief A Khronos defined object base index."]
pub const vx_type_e_VX_TYPE_KHRONOS_OBJECT_START: vx_type_e = 2048;
#[doc = "< \\brief A vendor defined object base index."]
pub const vx_type_e_VX_TYPE_VENDOR_OBJECT_START: vx_type_e = 3072;
#[doc = "< \\brief A value for comparison between Khronos defined structs and user structs."]
pub const vx_type_e_VX_TYPE_KHRONOS_STRUCT_MAX: vx_type_e = 255;
#[doc = "< \\brief A value for comparison between user structs and vendor structs."]
pub const vx_type_e_VX_TYPE_USER_STRUCT_END: vx_type_e = 1023;
#[doc = "< \\brief A value for comparison between vendor structs and Khronos defined objects."]
pub const vx_type_e_VX_TYPE_VENDOR_STRUCT_END: vx_type_e = 2047;
#[doc = "< \\brief A value for comparison between Khronos defined objects and vendor structs."]
pub const vx_type_e_VX_TYPE_KHRONOS_OBJECT_END: vx_type_e = 3071;
#[doc = "< \\brief A value used for bound checking of vendor objects"]
pub const vx_type_e_VX_TYPE_VENDOR_OBJECT_END: vx_type_e = 4095;
#[doc = "< \\brief A <tt>\\ref vx_reference</tt>."]
pub const vx_type_e_VX_TYPE_REFERENCE: vx_type_e = 2048;
#[doc = "< \\brief A <tt>\\ref vx_context</tt>."]
pub const vx_type_e_VX_TYPE_CONTEXT: vx_type_e = 2049;
#[doc = "< \\brief A <tt>\\ref vx_graph</tt>."]
pub const vx_type_e_VX_TYPE_GRAPH: vx_type_e = 2050;
#[doc = "< \\brief A <tt>\\ref vx_node</tt>."]
pub const vx_type_e_VX_TYPE_NODE: vx_type_e = 2051;
#[doc = "< \\brief A <tt>\\ref vx_kernel</tt>."]
pub const vx_type_e_VX_TYPE_KERNEL: vx_type_e = 2052;
#[doc = "< \\brief A <tt>\\ref vx_parameter</tt>."]
pub const vx_type_e_VX_TYPE_PARAMETER: vx_type_e = 2053;
#[doc = "< \\brief A <tt>\\ref vx_delay</tt>."]
pub const vx_type_e_VX_TYPE_DELAY: vx_type_e = 2054;
#[doc = "< \\brief A <tt>\\ref vx_lut</tt>."]
pub const vx_type_e_VX_TYPE_LUT: vx_type_e = 2055;
#[doc = "< \\brief A <tt>\\ref vx_distribution</tt>."]
pub const vx_type_e_VX_TYPE_DISTRIBUTION: vx_type_e = 2056;
#[doc = "< \\brief A <tt>\\ref vx_pyramid</tt>."]
pub const vx_type_e_VX_TYPE_PYRAMID: vx_type_e = 2057;
#[doc = "< \\brief A <tt>\\ref vx_threshold</tt>."]
pub const vx_type_e_VX_TYPE_THRESHOLD: vx_type_e = 2058;
#[doc = "< \\brief A <tt>\\ref vx_matrix</tt>."]
pub const vx_type_e_VX_TYPE_MATRIX: vx_type_e = 2059;
#[doc = "< \\brief A <tt>\\ref vx_convolution</tt>."]
pub const vx_type_e_VX_TYPE_CONVOLUTION: vx_type_e = 2060;
#[doc = "< \\brief A <tt>\\ref vx_scalar</tt>. when needed to be completely generic for kernel validation."]
pub const vx_type_e_VX_TYPE_SCALAR: vx_type_e = 2061;
#[doc = "< \\brief A <tt>\\ref vx_array</tt>."]
pub const vx_type_e_VX_TYPE_ARRAY: vx_type_e = 2062;
#[doc = "< \\brief A <tt>\\ref vx_image</tt>."]
pub const vx_type_e_VX_TYPE_IMAGE: vx_type_e = 2063;
#[doc = "< \\brief A <tt>\\ref vx_remap</tt>."]
pub const vx_type_e_VX_TYPE_REMAP: vx_type_e = 2064;
#[doc = "< \\brief An error object which has no type."]
pub const vx_type_e_VX_TYPE_ERROR: vx_type_e = 2065;
#[doc = "< \\brief A <tt>\\ref vx_meta_format</tt>."]
pub const vx_type_e_VX_TYPE_META_FORMAT: vx_type_e = 2066;
#[doc = "< \\brief A <tt>\\ref vx_object_array</tt>."]
pub const vx_type_e_VX_TYPE_OBJECT_ARRAY: vx_type_e = 2067;
#[doc = "< \\brief A <tt>\\ref vx_tensor</tt>."]
pub const vx_type_e_VX_TYPE_TENSOR: vx_type_e = 2069;
#[doc = " \\brief The type enumeration lists all the known types in OpenVX."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_type_e = ::std::os::raw::c_uint;
#[doc = "< \\brief Indicates the lower bound of status codes in VX. Used for bounds checks only."]
pub const vx_status_e_VX_STATUS_MIN: vx_status_e = -25;
#[doc = "< \\brief Indicates that an operation did not complete due to a reference count being non-zero."]
pub const vx_status_e_VX_ERROR_REFERENCE_NONZERO: vx_status_e = -24;
#[doc = "< \\brief Indicates that the graph has more than one node outputting to the same data object. This is an invalid graph structure."]
pub const vx_status_e_VX_ERROR_MULTIPLE_WRITERS: vx_status_e = -23;
#[doc = "< \\brief Indicates that the graph is stopped due to an error or a callback that abandoned execution."]
pub const vx_status_e_VX_ERROR_GRAPH_ABANDONED: vx_status_e = -22;
#[doc = "< \\brief Indicates that the supplied graph already has been scheduled and may be currently executing."]
pub const vx_status_e_VX_ERROR_GRAPH_SCHEDULED: vx_status_e = -21;
#[doc = "< \\brief Indicates that the supplied parameter is from another scope and cannot be used in the current scope."]
pub const vx_status_e_VX_ERROR_INVALID_SCOPE: vx_status_e = -20;
#[doc = "< \\brief Indicates that the supplied node could not be created."]
pub const vx_status_e_VX_ERROR_INVALID_NODE: vx_status_e = -19;
#[doc = "< \\brief Indicates that the supplied graph has invalid connections (cycles)."]
pub const vx_status_e_VX_ERROR_INVALID_GRAPH: vx_status_e = -18;
#[doc = "< \\brief Indicates that the supplied type parameter is incorrect."]
pub const vx_status_e_VX_ERROR_INVALID_TYPE: vx_status_e = -17;
#[doc = "< \\brief Indicates that the supplied parameter has an incorrect value."]
pub const vx_status_e_VX_ERROR_INVALID_VALUE: vx_status_e = -16;
#[doc = "< \\brief Indicates that the supplied parameter is too big or too small in dimension."]
pub const vx_status_e_VX_ERROR_INVALID_DIMENSION: vx_status_e = -15;
#[doc = "< \\brief Indicates that the supplied parameter is in an invalid format."]
pub const vx_status_e_VX_ERROR_INVALID_FORMAT: vx_status_e = -14;
#[doc = "< \\brief Indicates that the link is not possible as specified. The parameters are incompatible."]
pub const vx_status_e_VX_ERROR_INVALID_LINK: vx_status_e = -13;
#[doc = "< \\brief Indicates that the reference provided is not valid."]
pub const vx_status_e_VX_ERROR_INVALID_REFERENCE: vx_status_e = -12;
#[doc = "< \\brief This is returned from <tt>\\ref vxLoadKernels</tt> when the module does not contain the entry point."]
pub const vx_status_e_VX_ERROR_INVALID_MODULE: vx_status_e = -11;
#[doc = "< \\brief Indicates that the supplied parameter information does not match the kernel contract."]
pub const vx_status_e_VX_ERROR_INVALID_PARAMETERS: vx_status_e = -10;
#[doc = "< \\brief Indicates that the object refered to has been optimized out of existence."]
pub const vx_status_e_VX_ERROR_OPTIMIZED_AWAY: vx_status_e = -9;
#[doc = "< \\brief Indicates that an internal or implicit allocation failed. Typically catastrophic. After detection, deconstruct the context. \\see vxVerifyGraph."]
pub const vx_status_e_VX_ERROR_NO_MEMORY: vx_status_e = -8;
#[doc = "< \\brief Indicates that an internal or implicit resource can not be acquired (not memory). This is typically catastrophic. After detection, deconstruct the context. \\see vxVerifyGraph."]
pub const vx_status_e_VX_ERROR_NO_RESOURCES: vx_status_e = -7;
#[doc = "< \\brief Indicates that the attempt to link two parameters together failed due to type incompatibilty."]
pub const vx_status_e_VX_ERROR_NOT_COMPATIBLE: vx_status_e = -6;
#[doc = "< \\brief Indicates to the system that the parameter must be allocated by the system."]
pub const vx_status_e_VX_ERROR_NOT_ALLOCATED: vx_status_e = -5;
#[doc = "< \\brief Indicates that the given graph has failed verification due to an insufficient number of required parameters, which cannot be automatically created. Typically this indicates required atomic parameters. \\see vxVerifyGraph."]
pub const vx_status_e_VX_ERROR_NOT_SUFFICIENT: vx_status_e = -4;
#[doc = "< \\brief Indicates that the requested set of parameters produce a configuration that cannot be supported. Refer to the supplied documentation on the configured kernels. \\see vx_kernel_e. This is also returned if a function to set an attribute is called on a Read-only attribute."]
pub const vx_status_e_VX_ERROR_NOT_SUPPORTED: vx_status_e = -3;
#[doc = "< \\brief Indicates that the requested kernel is missing. \\see vx_kernel_e vxGetKernelByName."]
pub const vx_status_e_VX_ERROR_NOT_IMPLEMENTED: vx_status_e = -2;
#[doc = "< \\brief Indicates a generic error code, used when no other describes the error."]
pub const vx_status_e_VX_FAILURE: vx_status_e = -1;
#[doc = "< \\brief No error."]
pub const vx_status_e_VX_SUCCESS: vx_status_e = 0;
#[doc = " \\brief The enumeration of all status codes."]
#[doc = " \\see vx_status."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_status_e = ::std::os::raw::c_int;
#[doc = " \\brief A formal status type with known fixed size."]
#[doc = " \\see vx_status_e"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_status = vx_enum;
#[doc = " \\brief The formal typedef of the response from the callback."]
#[doc = " \\see vx_action_e"]
#[doc = " \\ingroup group_node_callback"]
pub type vx_action = vx_enum;
#[doc = " \\brief A callback to the client after a particular node has completed."]
#[doc = " \\see vx_action"]
#[doc = " \\see vxAssignNodeCallback"]
#[doc = " \\param [in] node The node to which the callback was attached."]
#[doc = " \\return An action code from <tt>\\ref vx_action_e</tt>."]
#[doc = " \\ingroup group_node_callback"]
pub type vx_nodecomplete_f =
    ::std::option::Option<unsafe extern "C" fn(node: vx_node) -> vx_action>;
#[doc = "< \\brief Parameter Direction."]
pub const vx_enum_e_VX_ENUM_DIRECTION: vx_enum_e = 0;
#[doc = "< \\brief Action Codes."]
pub const vx_enum_e_VX_ENUM_ACTION: vx_enum_e = 1;
#[doc = "< \\brief Hint Values."]
pub const vx_enum_e_VX_ENUM_HINT: vx_enum_e = 2;
#[doc = "< \\brief Directive Values."]
pub const vx_enum_e_VX_ENUM_DIRECTIVE: vx_enum_e = 3;
#[doc = "< \\brief Interpolation Types."]
pub const vx_enum_e_VX_ENUM_INTERPOLATION: vx_enum_e = 4;
#[doc = "< \\brief Overflow Policies."]
pub const vx_enum_e_VX_ENUM_OVERFLOW: vx_enum_e = 5;
#[doc = "< \\brief Color Space."]
pub const vx_enum_e_VX_ENUM_COLOR_SPACE: vx_enum_e = 6;
#[doc = "< \\brief Color Space Range."]
pub const vx_enum_e_VX_ENUM_COLOR_RANGE: vx_enum_e = 7;
#[doc = "< \\brief Parameter State."]
pub const vx_enum_e_VX_ENUM_PARAMETER_STATE: vx_enum_e = 8;
#[doc = "< \\brief Channel Name."]
pub const vx_enum_e_VX_ENUM_CHANNEL: vx_enum_e = 9;
#[doc = "< \\brief Convert Policy."]
pub const vx_enum_e_VX_ENUM_CONVERT_POLICY: vx_enum_e = 10;
#[doc = "< \\brief Threshold Type List."]
pub const vx_enum_e_VX_ENUM_THRESHOLD_TYPE: vx_enum_e = 11;
#[doc = "< \\brief Border Mode List."]
pub const vx_enum_e_VX_ENUM_BORDER: vx_enum_e = 12;
#[doc = "< \\brief Comparison Values."]
pub const vx_enum_e_VX_ENUM_COMPARISON: vx_enum_e = 13;
#[doc = "< \\brief The memory type enumeration."]
pub const vx_enum_e_VX_ENUM_MEMORY_TYPE: vx_enum_e = 14;
#[doc = "< \\brief A termination criteria."]
pub const vx_enum_e_VX_ENUM_TERM_CRITERIA: vx_enum_e = 15;
#[doc = "< \\brief A norm type."]
pub const vx_enum_e_VX_ENUM_NORM_TYPE: vx_enum_e = 16;
#[doc = "< \\brief An accessor flag type."]
pub const vx_enum_e_VX_ENUM_ACCESSOR: vx_enum_e = 17;
#[doc = "< \\brief Rounding Policy."]
pub const vx_enum_e_VX_ENUM_ROUND_POLICY: vx_enum_e = 18;
#[doc = "< \\brief Target."]
pub const vx_enum_e_VX_ENUM_TARGET: vx_enum_e = 19;
#[doc = "< \\brief Unsupported Border Mode Policy List."]
pub const vx_enum_e_VX_ENUM_BORDER_POLICY: vx_enum_e = 20;
#[doc = "< \\brief Graph attribute states."]
pub const vx_enum_e_VX_ENUM_GRAPH_STATE: vx_enum_e = 21;
#[doc = "< \\brief Non-linear function list."]
pub const vx_enum_e_VX_ENUM_NONLINEAR: vx_enum_e = 22;
#[doc = "< \\brief Matrix pattern enumeration."]
pub const vx_enum_e_VX_ENUM_PATTERN: vx_enum_e = 23;
#[doc = "< \\brief Lbp format."]
pub const vx_enum_e_VX_ENUM_LBP_FORMAT: vx_enum_e = 24;
#[doc = "< \\brief Compare metric."]
pub const vx_enum_e_VX_ENUM_COMP_METRIC: vx_enum_e = 25;
#[doc = "< \\brief Scalar operation list."]
pub const vx_enum_e_VX_ENUM_SCALAR_OPERATION: vx_enum_e = 32;
#[doc = " \\brief The set of supported enumerations in OpenVX."]
#[doc = " \\details These can be extracted from enumerated values using <tt>\\ref VX_ENUM_TYPE</tt>."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_enum_e = ::std::os::raw::c_uint;
#[doc = " \\brief Continue executing the graph with no changes."]
pub const vx_action_e_VX_ACTION_CONTINUE: vx_action_e = 4096;
#[doc = " \\brief Stop executing the graph."]
pub const vx_action_e_VX_ACTION_ABANDON: vx_action_e = 4097;
#[doc = " \\brief A return code enumeration from a <tt>\\ref vx_nodecomplete_f</tt> during execution."]
#[doc = " \\see <tt>vxAssignNodeCallback</tt>"]
#[doc = " \\ingroup group_node_callback"]
pub type vx_action_e = ::std::os::raw::c_uint;
#[doc = " \\brief The parameter is an input only."]
pub const vx_direction_e_VX_INPUT: vx_direction_e = 0;
#[doc = " \\brief The parameter is an output only."]
pub const vx_direction_e_VX_OUTPUT: vx_direction_e = 1;
#[doc = " \\brief An indication of how a kernel will treat the given parameter."]
#[doc = " \\ingroup group_parameter"]
pub type vx_direction_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates to the implementation that user do not apply any specific"]
#[doc = "  requirements for performance."]
pub const vx_hint_e_VX_HINT_PERFORMANCE_DEFAULT: vx_hint_e = 8193;
#[doc = " \\brief Indicates the user preference is low power consumption versus"]
#[doc = " highest performance."]
pub const vx_hint_e_VX_HINT_PERFORMANCE_LOW_POWER: vx_hint_e = 8194;
#[doc = " \\brief Indicates the user preference for highest performance over"]
#[doc = " low power consumption."]
pub const vx_hint_e_VX_HINT_PERFORMANCE_HIGH_SPEED: vx_hint_e = 8195;
#[doc = " \\brief These enumerations are given to the <tt>\\ref vxHint</tt> API to enable/disable platform"]
#[doc = " optimizations and/or features. Hints are optional and usually are vendor-specific."]
#[doc = " \\see <tt>\\ref vxHint</tt>"]
#[doc = " \\ingroup group_hint"]
pub type vx_hint_e = ::std::os::raw::c_uint;
#[doc = " \\brief Disables recording information for graph debugging."]
pub const vx_directive_e_VX_DIRECTIVE_DISABLE_LOGGING: vx_directive_e = 12288;
#[doc = " \\brief Enables recording information for graph debugging."]
pub const vx_directive_e_VX_DIRECTIVE_ENABLE_LOGGING: vx_directive_e = 12289;
#[doc = " \\brief Disables performance counters for the context. By default performance counters are disabled"]
pub const vx_directive_e_VX_DIRECTIVE_DISABLE_PERFORMANCE: vx_directive_e = 12290;
#[doc = " \\brief Enables performance counters for the context."]
pub const vx_directive_e_VX_DIRECTIVE_ENABLE_PERFORMANCE: vx_directive_e = 12291;
#[doc = " \\brief These enumerations are given to the \\c vxDirective API to enable/disable"]
#[doc = " platform optimizations and/or features. Directives are not optional and"]
#[doc = " usually are vendor-specific, by defining a vendor range of directives and"]
#[doc = " starting their enumeration from there."]
#[doc = " \\see <tt>vxDirective</tt>"]
#[doc = " \\ingroup group_directive"]
pub type vx_directive_e = ::std::os::raw::c_uint;
#[doc = " \\brief The graph should be verified before execution"]
pub const vx_graph_state_e_VX_GRAPH_STATE_UNVERIFIED: vx_graph_state_e = 86016;
#[doc = " \\brief The graph has been verified and has not been executed or scheduled for execution yet"]
pub const vx_graph_state_e_VX_GRAPH_STATE_VERIFIED: vx_graph_state_e = 86017;
#[doc = " \\brief The graph either has been scheduled and not completed, or is being executed"]
pub const vx_graph_state_e_VX_GRAPH_STATE_RUNNING: vx_graph_state_e = 86018;
#[doc = " \\brief The graph execution was abandoned"]
pub const vx_graph_state_e_VX_GRAPH_STATE_ABANDONED: vx_graph_state_e = 86019;
#[doc = " \\brief The graph execution is completed and the graph is not scheduled for execution"]
pub const vx_graph_state_e_VX_GRAPH_STATE_COMPLETED: vx_graph_state_e = 86020;
#[doc = " \\brief The Graph State Enumeration."]
#[doc = " \\ingroup group_graph"]
pub type vx_graph_state_e = ::std::os::raw::c_uint;
#[doc = " \\brief Returns the number of nodes in a graph. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_graph_attribute_e_VX_GRAPH_NUMNODES: vx_graph_attribute_e = 524800;
#[doc = " \\brief Returns the overall performance of the graph. Read-only. Use a <tt>\\ref vx_perf_t</tt> parameter."]
#[doc = " The accuracy of timing information is platform dependent."]
#[doc = " \\note Performance tracking must have been enabled. See <tt>\\ref vx_directive_e</tt>"]
pub const vx_graph_attribute_e_VX_GRAPH_PERFORMANCE: vx_graph_attribute_e = 524802;
#[doc = " \\brief Returns the number of explicitly declared parameters on the graph. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_graph_attribute_e_VX_GRAPH_NUMPARAMETERS: vx_graph_attribute_e = 524803;
#[doc = " \\brief Returns the state of the graph. See <tt>\\ref vx_graph_state_e</tt> enum."]
pub const vx_graph_attribute_e_VX_GRAPH_STATE: vx_graph_attribute_e = 524804;
#[doc = " \\brief The graph attributes list."]
#[doc = " \\ingroup group_graph"]
pub type vx_graph_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Results are the least significant bits of the output operand, as if"]
#[doc = " stored in two's complement binary format in the size of its bit-depth."]
pub const vx_convert_policy_e_VX_CONVERT_POLICY_WRAP: vx_convert_policy_e = 40960;
#[doc = " \\brief Results are saturated to the bit depth of the output operand."]
pub const vx_convert_policy_e_VX_CONVERT_POLICY_SATURATE: vx_convert_policy_e = 40961;
#[doc = " \\brief The Conversion Policy Enumeration."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_convert_policy_e = ::std::os::raw::c_uint;
#[doc = " \\brief A virtual image of no defined type."]
pub const vx_df_image_e_VX_DF_IMAGE_VIRT: vx_df_image_e = 1414678870;
#[doc = " \\brief A single plane of 24-bit pixel as 3 interleaved 8-bit units of"]
#[doc = " R then G then B data. This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_RGB: vx_df_image_e = 843204434;
#[doc = " \\brief A single plane of 32-bit pixel as 4 interleaved 8-bit units of"]
#[doc = " R then G then B data, then a <i>don't care</i> byte."]
#[doc = " This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_RGBX: vx_df_image_e = 1094862674;
#[doc = " \\brief A 2-plane YUV format of Luma (Y) and interleaved UV data at"]
#[doc = " 4:2:0 sampling. This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_NV12: vx_df_image_e = 842094158;
#[doc = " \\brief A 2-plane YUV format of Luma (Y) and interleaved VU data at"]
#[doc = " 4:2:0 sampling. This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_NV21: vx_df_image_e = 825382478;
#[doc = " \\brief A single plane of 32-bit macro pixel of U0, Y0, V0, Y1 bytes."]
#[doc = " This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_UYVY: vx_df_image_e = 1498831189;
#[doc = " \\brief A single plane of 32-bit macro pixel of Y0, U0, Y1, V0 bytes."]
#[doc = " This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_YUYV: vx_df_image_e = 1448695129;
#[doc = " \\brief A 3 plane of 8-bit 4:2:0 sampled Y, U, V planes."]
#[doc = " This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_IYUV: vx_df_image_e = 1448433993;
#[doc = " \\brief A 3 plane of 8 bit 4:4:4 sampled Y, U, V planes."]
#[doc = " This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_YUV4: vx_df_image_e = 878073177;
#[doc = " \\brief A single plane of unsigned 1-bit data packed eight pixels per byte."]
#[doc = " The least significant bit is the first pixel in each byte."]
#[doc = " See <tt>\\ref vx_imagepatch_addressing_t</tt> for more details."]
pub const vx_df_image_e_VX_DF_IMAGE_U1: vx_df_image_e = 825241685;
#[doc = " \\brief A single plane of unsigned 8-bit data."]
#[doc = " The range of data is not specified, as it may be extracted from a YUV or"]
#[doc = " generated."]
pub const vx_df_image_e_VX_DF_IMAGE_U8: vx_df_image_e = 942682197;
#[doc = " \\brief A single plane of unsigned 16-bit data."]
#[doc = " The range of data is not specified, as it may be extracted from a YUV or"]
#[doc = " generated."]
pub const vx_df_image_e_VX_DF_IMAGE_U16: vx_df_image_e = 909193301;
#[doc = " \\brief A single plane of signed 16-bit data."]
#[doc = " The range of data is not specified, as it may be extracted from a YUV or"]
#[doc = " generated."]
pub const vx_df_image_e_VX_DF_IMAGE_S16: vx_df_image_e = 909193299;
#[doc = " \\brief A single plane of unsigned 32-bit data."]
#[doc = " The range of data is not specified, as it may be extracted from a YUV or"]
#[doc = " generated."]
pub const vx_df_image_e_VX_DF_IMAGE_U32: vx_df_image_e = 842215509;
#[doc = " \\brief A single plane of unsigned 32-bit data."]
#[doc = " The range of data is not specified, as it may be extracted from a YUV or"]
#[doc = " generated."]
pub const vx_df_image_e_VX_DF_IMAGE_S32: vx_df_image_e = 842215507;
#[doc = " \\brief Based on the VX_DF_IMAGE definition."]
#[doc = " \\note Use <tt>\\ref vx_df_image</tt> to contain these values."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_df_image_e = ::std::os::raw::c_uint;
#[doc = " \\brief Any available target. An OpenVX implementation must support at least one target associated with this value"]
pub const vx_target_e_VX_TARGET_ANY: vx_target_e = 77824;
#[doc = " \\brief Target, explicitly specified by its (case-insensitive) name string."]
pub const vx_target_e_VX_TARGET_STRING: vx_target_e = 77825;
#[doc = " \\brief Start of Vendor specific target enumerates."]
pub const vx_target_e_VX_TARGET_VENDOR_BEGIN: vx_target_e = 81920;
#[doc = " \\brief The Target Enumeration."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_target_e = ::std::os::raw::c_uint;
#[doc = " \\brief Returns the reference count of the object. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_reference_attribute_e_VX_REFERENCE_COUNT: vx_reference_attribute_e = 524288;
#[doc = " \\brief Returns the <tt>\\ref vx_type_e</tt> of the reference. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_reference_attribute_e_VX_REFERENCE_TYPE: vx_reference_attribute_e = 524289;
#[doc = " \\brief Used to query the reference for its name. Read-write. Use a *<tt>\\ref vx_char</tt> parameter."]
pub const vx_reference_attribute_e_VX_REFERENCE_NAME: vx_reference_attribute_e = 524290;
#[doc = " \\brief The reference attributes list."]
#[doc = " \\ingroup group_reference"]
pub type vx_reference_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the unique vendor ID. Read-only. Use a <tt>\\ref vx_uint16</tt>."]
pub const vx_context_attribute_e_VX_CONTEXT_VENDOR_ID: vx_context_attribute_e = 524544;
#[doc = " \\brief Queries the OpenVX Version Number. Read-only. Use a <tt>\\ref vx_uint16</tt>"]
pub const vx_context_attribute_e_VX_CONTEXT_VERSION: vx_context_attribute_e = 524545;
#[doc = " \\brief Queries the context for the number of \\e unique kernels. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_UNIQUE_KERNELS: vx_context_attribute_e = 524546;
#[doc = " \\brief Queries the context for the number of active modules. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_MODULES: vx_context_attribute_e = 524547;
#[doc = " \\brief Queries the context for the number of active references. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_REFERENCES: vx_context_attribute_e = 524548;
#[doc = " \\brief Queries the context for it's implementation name. Read-only. Use a <tt>\\ref vx_char</tt>[<tt>\\ref VX_MAX_IMPLEMENTATION_NAME</tt>] array"]
pub const vx_context_attribute_e_VX_CONTEXT_IMPLEMENTATION: vx_context_attribute_e = 524549;
#[doc = " \\brief Queries the number of bytes in the extensions string. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_EXTENSIONS_SIZE: vx_context_attribute_e = 524550;
#[doc = " \\brief Retrieves the extensions string. Read-only."]
#[doc = " This is a space-separated string of extension names. Each OpenVX official extension has a unique identifier,"]
#[doc = " comprised of capital letters, numbers and the underscore character, prefixed with \"KHR_\", for example \"KHR_NEW_FEATURE\"."]
#[doc = " Use a <tt>\\ref vx_char</tt> pointer allocated to the size returned from <tt>\\ref VX_CONTEXT_EXTENSIONS_SIZE</tt>."]
pub const vx_context_attribute_e_VX_CONTEXT_EXTENSIONS: vx_context_attribute_e = 524551;
#[doc = " \\brief The maximum width or height of a convolution matrix."]
#[doc = " Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
#[doc = " Each vendor must support centered kernels of size w X h, where both w"]
#[doc = " and h are odd numbers, 3 <= w <= n and 3 <= h <= n, where n is the value of the"]
#[doc = " <tt>\\ref VX_CONTEXT_CONVOLUTION_MAX_DIMENSION</tt> attribute. n is an odd"]
#[doc = " number that should not be smaller than 9. w and h may or may not be equal to"]
#[doc = " each other. All combinations of w and h meeting the conditions above must be"]
#[doc = " supported. The behavior of <tt>\\ref vxCreateConvolution</tt> is undefined for values"]
#[doc = " larger than the value returned by this attribute."]
pub const vx_context_attribute_e_VX_CONTEXT_CONVOLUTION_MAX_DIMENSION: vx_context_attribute_e =
    524552;
#[doc = " \\brief The maximum window dimension of the OpticalFlowPyrLK kernel. The value of this attribute shall be equal to or greater than '9'."]
#[doc = " \\see <tt>\\ref VX_KERNEL_OPTICAL_FLOW_PYR_LK</tt>. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION:
    vx_context_attribute_e = 524553;
#[doc = " \\brief The border mode for immediate mode functions."]
#[doc = " \\details Graph mode functions are unaffected by this attribute. Read-write. Use a pointer to a <tt>\\ref vx_border_t</tt> structure as parameter."]
#[doc = " \\note The assumed default value for immediate mode functions is <tt>\\ref VX_BORDER_UNDEFINED</tt>."]
pub const vx_context_attribute_e_VX_CONTEXT_IMMEDIATE_BORDER: vx_context_attribute_e = 524554;
#[doc = " \\brief Returns the table of all unique the kernels that exist in the context."]
#[doc = "  Read-only. Use a <tt>\\ref vx_kernel_info_t</tt> array."]
#[doc = " \\pre You must call <tt>\\ref vxQueryContext</tt> with <tt>\\ref VX_CONTEXT_UNIQUE_KERNELS</tt>"]
#[doc = " to compute the necessary size of the array."]
pub const vx_context_attribute_e_VX_CONTEXT_UNIQUE_KERNEL_TABLE: vx_context_attribute_e = 524555;
#[doc = " \\brief The unsupported border mode policy for immediate mode functions. Read-Write."]
#[doc = " \\details Graph mode functions are unaffected by this attribute. Use a <tt>\\ref vx_enum</tt> as parameter. Will contain a <tt>\\ref vx_border_policy_e</tt>."]
#[doc = " \\note The assumed default value for immediate mode functions is <tt>\\ref VX_BORDER_POLICY_DEFAULT_TO_UNDEFINED</tt>. Users should refer to the documentation of their implementation to determine what border modes are supported by each kernel."]
pub const vx_context_attribute_e_VX_CONTEXT_IMMEDIATE_BORDER_POLICY: vx_context_attribute_e =
    524556;
#[doc = " \\brief The dimension of the largest nonlinear filter supported. See <tt>\\ref vxNonLinearFilterNode</tt>."]
#[doc = " \\details The implementation must support all dimensions (height or width, not necessarily the same)"]
#[doc = " up to the value of this attribute.  The lowest value that must be supported for this attribute is 9."]
#[doc = " Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_NONLINEAR_MAX_DIMENSION: vx_context_attribute_e =
    524557;
#[doc = " \\brief tensor Data maximal number of dimensions supported by the implementation."]
pub const vx_context_attribute_e_VX_CONTEXT_MAX_TENSOR_DIMS: vx_context_attribute_e = 524558;
#[doc = " \\brief A list of context attributes."]
#[doc = " \\ingroup group_context"]
pub type vx_context_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries a kernel for the number of parameters the kernel"]
#[doc = " supports. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_kernel_attribute_e_VX_KERNEL_PARAMETERS: vx_kernel_attribute_e = 525312;
#[doc = " \\brief Queries the name of the kernel. Not settable."]
#[doc = "  Read-only. Use a <tt>\\ref vx_char</tt>[<tt>\\ref VX_MAX_KERNEL_NAME</tt>] array (not a <tt>\\ref vx_array</tt>)."]
pub const vx_kernel_attribute_e_VX_KERNEL_NAME: vx_kernel_attribute_e = 525313;
#[doc = " \\brief Queries the enum of the kernel. Not settable."]
#[doc = "  Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_kernel_attribute_e_VX_KERNEL_ENUM: vx_kernel_attribute_e = 525314;
#[doc = " \\brief The local data area allocated with each kernel when it becomes a"]
#[doc = " node.  Read-write. Can be written only before user-kernel finalization."]
#[doc = " Use a <tt>\\ref vx_size</tt> parameter."]
#[doc = " \\note If not set it will default to zero."]
pub const vx_kernel_attribute_e_VX_KERNEL_LOCAL_DATA_SIZE: vx_kernel_attribute_e = 525315;
#[doc = " \\brief The kernel attributes list"]
#[doc = " \\ingroup group_kernel"]
pub type vx_kernel_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the status of node execution. Read-only. Use a <tt>\\ref vx_status</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_STATUS: vx_node_attribute_e = 525056;
#[doc = " \\brief Queries the performance of the node execution."]
#[doc = " The accuracy of timing information is platform dependent and also depends on the graph"]
#[doc = " optimizations. Read-only."]
#[doc = " \\note Performance tracking must have been enabled. See <tt>\\ref vx_directive_e</tt>."]
pub const vx_node_attribute_e_VX_NODE_PERFORMANCE: vx_node_attribute_e = 525057;
#[doc = " \\brief Gets or sets the border mode of the node."]
#[doc = " Read-write. Use a <tt>\\ref vx_border_t</tt> structure with a default value of VX_BORDER_UNDEFINED."]
pub const vx_node_attribute_e_VX_NODE_BORDER: vx_node_attribute_e = 525058;
#[doc = " \\brief Indicates the size of the kernel local memory area."]
#[doc = " Read-only. Can be written only at user-node (de)initialization if VX_KERNEL_LOCAL_DATA_SIZE==0."]
#[doc = " Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_LOCAL_DATA_SIZE: vx_node_attribute_e = 525059;
#[doc = " \\brief Indicates the pointer kernel local memory area."]
#[doc = " Read-Write. Can be written only at user-node (de)initialization if VX_KERNEL_LOCAL_DATA_SIZE==0."]
#[doc = " Use a void * parameter."]
pub const vx_node_attribute_e_VX_NODE_LOCAL_DATA_PTR: vx_node_attribute_e = 525060;
#[doc = " \\brief Indicates the number of node parameters, including optional parameters that are not passed."]
#[doc = " Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_PARAMETERS: vx_node_attribute_e = 525061;
#[doc = " \\brief Indicates whether the node is replicated. Read-only."]
#[doc = " Use a <tt>\\ref vx_bool</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_IS_REPLICATED: vx_node_attribute_e = 525062;
#[doc = " \\brief Indicates the replicated parameters. Read-only."]
#[doc = " Use a <tt>\\ref vx_bool</tt>* parameter."]
pub const vx_node_attribute_e_VX_NODE_REPLICATE_FLAGS: vx_node_attribute_e = 525063;
#[doc = " \\brief Indicates the behavior with respect to the valid rectangle. Read-only."]
#[doc = " Use a <tt>\\ref vx_bool</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_VALID_RECT_RESET: vx_node_attribute_e = 525064;
#[doc = " \\brief The node attributes list."]
#[doc = " \\ingroup group_node"]
pub type vx_node_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries a parameter for its index value on the kernel with which it is associated. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_INDEX: vx_parameter_attribute_e = 525568;
#[doc = " \\brief Queries a parameter for its direction value on the kernel with which it is associated. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_DIRECTION: vx_parameter_attribute_e = 525569;
#[doc = " \\brief Queries a parameter for its type, \\ref vx_type_e is returned. Read-only. The size of the parameter is implied for plain data objects. For opaque data objects like images and arrays a query to their attributes has to be called to determine the size."]
pub const vx_parameter_attribute_e_VX_PARAMETER_TYPE: vx_parameter_attribute_e = 525570;
#[doc = " \\brief Queries a parameter for its state. A value in <tt>\\ref vx_parameter_state_e</tt> is returned. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_STATE: vx_parameter_attribute_e = 525571;
#[doc = " \\brief Use to extract the reference contained in the parameter. Read-only. Use a <tt>\\ref vx_reference</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_REF: vx_parameter_attribute_e = 525572;
#[doc = " \\brief Use to extract the meta format contained in the parameter. Read-only. Use a <tt>\\ref vx_meta_format</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_META_FORMAT: vx_parameter_attribute_e = 525573;
#[doc = " \\brief The parameter attributes list"]
#[doc = " \\ingroup group_parameter"]
pub type vx_parameter_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries an image for its width. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_WIDTH: vx_image_attribute_e = 528128;
#[doc = " \\brief Queries an image for its height. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_HEIGHT: vx_image_attribute_e = 528129;
#[doc = " \\brief Queries an image for its format. Read-only. Use a <tt>\\ref vx_df_image</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_FORMAT: vx_image_attribute_e = 528130;
#[doc = " \\brief Queries an image for its number of planes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_PLANES: vx_image_attribute_e = 528131;
#[doc = " \\brief Queries an image for its color space (see <tt>\\ref vx_color_space_e</tt>). Read-write. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_SPACE: vx_image_attribute_e = 528132;
#[doc = " \\brief Queries an image for its channel range (see <tt>\\ref vx_channel_range_e</tt>). Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_RANGE: vx_image_attribute_e = 528133;
#[doc = " \\brief Queries memory type if created using vxCreateImageFromHandle. If vx_image was not created using"]
#[doc = "vxCreateImageFromHandle, VX_MEMORY_TYPE_NONE is returned. Use a <tt>\\ref vx_memory_type_e</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_MEMORY_TYPE: vx_image_attribute_e = 528135;
#[doc = " \\brief Queries if an image is uniform. Read-only. Use a <tt>\\ref vx_bool</tt> parameter"]
pub const vx_image_attribute_e_VX_IMAGE_IS_UNIFORM: vx_image_attribute_e = 528136;
#[doc = " \\brief Queries the image uniform value if any. Read-only. Use a <tt>\\ref vx_pixel_value_t</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_UNIFORM_VALUE: vx_image_attribute_e = 528137;
#[doc = " \\brief The image attributes list."]
#[doc = " \\ingroup group_image"]
pub type vx_image_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the type of atomic that is contained in the scalar. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_scalar_attribute_e_VX_SCALAR_TYPE: vx_scalar_attribute_e = 527616;
#[doc = " \\brief The scalar attributes list."]
#[doc = " \\ingroup group_scalar"]
pub type vx_scalar_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief logical and."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_AND: vx_scalar_operation_e = 131072;
#[doc = " \\brief logical or."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_OR: vx_scalar_operation_e = 131073;
#[doc = " \\brief logical exclusive or."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_XOR: vx_scalar_operation_e = 131074;
#[doc = " \\brief logical nand."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_NAND: vx_scalar_operation_e = 131075;
#[doc = " \\brief comparison (equal)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_EQUAL: vx_scalar_operation_e = 131076;
#[doc = " \\brief comparison (not equal)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_NOTEQUAL: vx_scalar_operation_e = 131077;
#[doc = " \\brief comparison (less than)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_LESS: vx_scalar_operation_e = 131078;
#[doc = " \\brief comparison (less than or equal to)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_LESSEQ: vx_scalar_operation_e = 131079;
#[doc = " \\brief comparison (greater than)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_GREATER: vx_scalar_operation_e = 131080;
#[doc = " \\brief comparison (greater than or equal to)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_GREATEREQ: vx_scalar_operation_e = 131081;
#[doc = " \\brief arithmetic addition."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_ADD: vx_scalar_operation_e = 131082;
#[doc = " \\brief arithmetic subtraction."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_SUBTRACT: vx_scalar_operation_e = 131083;
#[doc = " \\brief arithmetic multiplication."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MULTIPLY: vx_scalar_operation_e = 131084;
#[doc = " \\brief arithmetic division."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_DIVIDE: vx_scalar_operation_e = 131085;
#[doc = " \\brief arithmetic (modulo operator)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MODULUS: vx_scalar_operation_e = 131086;
#[doc = " \\brief minimum of two scalars."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MIN: vx_scalar_operation_e = 131087;
#[doc = " \\brief maximum of two scalars."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MAX: vx_scalar_operation_e = 131088;
#[doc = " \\brief A type of operation in which both operands are scalars."]
#[doc = " \\see group_scalar"]
#[doc = " \\ingroup group_scalar"]
pub type vx_scalar_operation_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the value type of the LUT. Read-only. Use a <tt>\\ref vx_enum</tt>."]
pub const vx_lut_attribute_e_VX_LUT_TYPE: vx_lut_attribute_e = 526080;
#[doc = " \\brief Indicates the number of elements in the LUT. Read-only. Use a <tt>\\ref vx_size</tt>."]
pub const vx_lut_attribute_e_VX_LUT_COUNT: vx_lut_attribute_e = 526081;
#[doc = " \\brief Indicates the total size of the LUT in bytes. Read-only. Uses a <tt>\\ref vx_size</tt>."]
pub const vx_lut_attribute_e_VX_LUT_SIZE: vx_lut_attribute_e = 526082;
#[doc = " \\brief Indicates the index of the input value = 0. Read-only. Uses a <tt>\\ref vx_uint32</tt>."]
pub const vx_lut_attribute_e_VX_LUT_OFFSET: vx_lut_attribute_e = 526083;
#[doc = " \\brief The Look-Up Table (LUT) attribute list."]
#[doc = " \\ingroup group_lut"]
pub type vx_lut_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the number of dimensions in the distribution. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_DIMENSIONS: vx_distribution_attribute_e =
    526336;
#[doc = " \\brief Indicates the start of the values to use (inclusive). Read-only. Use a <tt>\\ref vx_int32</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_OFFSET: vx_distribution_attribute_e = 526337;
#[doc = " \\brief Indicates the total number of the consecutive values of the distribution interval."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_RANGE: vx_distribution_attribute_e = 526338;
#[doc = " \\brief Indicates the number of bins. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_BINS: vx_distribution_attribute_e = 526339;
#[doc = " \\brief Indicates the width of a bin. Equal to the range divided by the number of bins. If the range is not a"]
#[doc = " multiple of the number of bins, it is not valid. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_WINDOW: vx_distribution_attribute_e = 526340;
#[doc = " \\brief Indicates the total size of the distribution in bytes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_SIZE: vx_distribution_attribute_e = 526341;
#[doc = " \\brief The distribution attribute list."]
#[doc = " \\ingroup group_distribution"]
pub type vx_distribution_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief A threshold with only 1 value."]
pub const vx_threshold_type_e_VX_THRESHOLD_TYPE_BINARY: vx_threshold_type_e = 45056;
#[doc = " \\brief A threshold with 2 values (upper/lower). Use with Canny Edge Detection."]
pub const vx_threshold_type_e_VX_THRESHOLD_TYPE_RANGE: vx_threshold_type_e = 45057;
#[doc = " \\brief The Threshold types."]
#[doc = " \\ingroup group_threshold"]
pub type vx_threshold_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief The value type of the threshold. Read-only. Use a <tt>\\ref vx_enum</tt> parameter. Will contain a <tt>\\ref vx_threshold_type_e</tt>."]
pub const vx_threshold_attribute_e_VX_THRESHOLD_TYPE: vx_threshold_attribute_e = 526848;
#[doc = " \\brief The input image format the threshold was created for. Read-only. Use a <tt>\\ref vx_enum</tt> parameter. Will contain a <tt>\\ref vx_df_image_e</tt>."]
pub const vx_threshold_attribute_e_VX_THRESHOLD_INPUT_FORMAT: vx_threshold_attribute_e = 526855;
#[doc = " \\brief The output image format the threshold was created for. Read-only. Use a <tt>\\ref vx_enum</tt> parameter. Will contain a <tt>\\ref vx_df_image_e</tt>."]
pub const vx_threshold_attribute_e_VX_THRESHOLD_OUTPUT_FORMAT: vx_threshold_attribute_e = 526856;
#[doc = " \\brief The threshold attributes."]
#[doc = " \\ingroup group_threshold"]
pub type vx_threshold_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The value type of the matrix. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_TYPE: vx_matrix_attribute_e = 527104;
#[doc = " \\brief The M dimension of the matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_ROWS: vx_matrix_attribute_e = 527105;
#[doc = " \\brief The N dimension of the matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_COLUMNS: vx_matrix_attribute_e = 527106;
#[doc = " \\brief The total size of the matrix in bytes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_SIZE: vx_matrix_attribute_e = 527107;
#[doc = " \\brief The origin of the matrix with a default value of [floor(VX_MATRIX_COLUMNS/2),"]
#[doc = "floor(VX_MATRIX_ROWS/2)]. Read-only. Use a <tt>\\ref vx_coordinates2d_t</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_ORIGIN: vx_matrix_attribute_e = 527108;
#[doc = " \\brief The pattern of the matrix. See <tt>\\ref vx_pattern_e </tt>. Read-only. Use a"]
#[doc = " <tt>\\ref vx_enum</tt> parameter. If the matrix was created via <tt>\\ref vxCreateMatrixFromPattern</tt>"]
#[doc = " or <tt>\\ref vxCreateMatrixFromPatternAndOrigin</tt>, the attribute corresponds to the given pattern."]
#[doc = " Otherwise the attribute is <tt>\\ref VX_PATTERN_OTHER</tt>."]
pub const vx_matrix_attribute_e_VX_MATRIX_PATTERN: vx_matrix_attribute_e = 527109;
#[doc = " \\brief The matrix attributes."]
#[doc = " \\ingroup group_matrix"]
pub type vx_matrix_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The number of rows of the convolution matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_ROWS: vx_convolution_attribute_e = 527360;
#[doc = " \\brief The number of columns of the convolution matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_COLUMNS: vx_convolution_attribute_e = 527361;
#[doc = " \\brief The scale of the convolution matrix. Read-write. Use a <tt>\\ref vx_uint32</tt> parameter."]
#[doc = " \\if OPENVX_STRICT_1_0"]
#[doc = " \\note For 1.0, only powers of 2 are supported up to 2^31."]
#[doc = " \\endif"]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_SCALE: vx_convolution_attribute_e = 527362;
#[doc = " \\brief The total size of the convolution matrix in bytes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_SIZE: vx_convolution_attribute_e = 527363;
#[doc = " \\brief The convolution attributes."]
#[doc = " \\ingroup group_convolution"]
pub type vx_convolution_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The number of levels of the pyramid. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_LEVELS: vx_pyramid_attribute_e = 526592;
#[doc = " \\brief The scale factor between each level of the pyramid. Read-only. Use a <tt>\\ref vx_float32</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_SCALE: vx_pyramid_attribute_e = 526593;
#[doc = " \\brief The width of the 0th image in pixels. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_WIDTH: vx_pyramid_attribute_e = 526594;
#[doc = " \\brief The height of the 0th image in pixels. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_HEIGHT: vx_pyramid_attribute_e = 526595;
#[doc = " \\brief The <tt>\\ref vx_df_image_e</tt> format of the image. Read-only. Use a <tt>\\ref vx_df_image</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_FORMAT: vx_pyramid_attribute_e = 526596;
#[doc = " \\brief The pyramid object attributes."]
#[doc = " \\ingroup group_pyramid"]
pub type vx_pyramid_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The source width. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_SOURCE_WIDTH: vx_remap_attribute_e = 528384;
#[doc = " \\brief The source height. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_SOURCE_HEIGHT: vx_remap_attribute_e = 528385;
#[doc = " \\brief The destination width. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_DESTINATION_WIDTH: vx_remap_attribute_e = 528386;
#[doc = " \\brief The destination height. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_DESTINATION_HEIGHT: vx_remap_attribute_e = 528387;
#[doc = " \\brief The remap object attributes."]
#[doc = " \\ingroup group_remap"]
pub type vx_remap_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The type of the Array items. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_ITEMTYPE: vx_array_attribute_e = 527872;
#[doc = " \\brief The number of items in the Array. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_NUMITEMS: vx_array_attribute_e = 527873;
#[doc = " \\brief The maximal number of items that the Array can hold. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_CAPACITY: vx_array_attribute_e = 527874;
#[doc = " \\brief Queries an array item size. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_ITEMSIZE: vx_array_attribute_e = 527875;
#[doc = " \\brief The array object attributes."]
#[doc = " \\ingroup group_array"]
pub type vx_array_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The type of the ObjectArray items. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_object_array_attribute_e_VX_OBJECT_ARRAY_ITEMTYPE: vx_object_array_attribute_e =
    529152;
#[doc = " \\brief The number of items in the ObjectArray. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_object_array_attribute_e_VX_OBJECT_ARRAY_NUMITEMS: vx_object_array_attribute_e =
    529153;
#[doc = " \\brief The ObjectArray object attributes."]
#[doc = " \\ingroup group_object_array"]
pub type vx_object_array_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Number of dimensions."]
pub const vx_tensor_attribute_e_VX_TENSOR_NUMBER_OF_DIMS: vx_tensor_attribute_e = 529664;
#[doc = " \\brief Dimension sizes."]
pub const vx_tensor_attribute_e_VX_TENSOR_DIMS: vx_tensor_attribute_e = 529665;
#[doc = " \\brief tensor Data element data type. <tt>vx_type_e</tt>"]
pub const vx_tensor_attribute_e_VX_TENSOR_DATA_TYPE: vx_tensor_attribute_e = 529666;
#[doc = " \\brief fixed point position when the input element type is integer."]
pub const vx_tensor_attribute_e_VX_TENSOR_FIXED_POINT_POSITION: vx_tensor_attribute_e = 529667;
#[doc = " \\brief tensor Data attributes."]
#[doc = " \\ingroup group_object_tensor"]
pub type vx_tensor_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Valid rectangle callback during output parameter validation. Write-only."]
pub const vx_meta_valid_rect_attribute_e_VX_VALID_RECT_CALLBACK: vx_meta_valid_rect_attribute_e =
    528897;
#[doc = " \\brief The meta valid rectangle attributes."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_meta_valid_rect_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_0: vx_channel_e = 36864;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_1: vx_channel_e = 36865;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_2: vx_channel_e = 36866;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_3: vx_channel_e = 36867;
#[doc = " \\brief Use to extract the RED channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_R: vx_channel_e = 36880;
#[doc = " \\brief Use to extract the GREEN channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_G: vx_channel_e = 36881;
#[doc = " \\brief Use to extract the BLUE channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_B: vx_channel_e = 36882;
#[doc = " \\brief Use to extract the ALPHA channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_A: vx_channel_e = 36883;
#[doc = " \\brief Use to extract the LUMA channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_Y: vx_channel_e = 36884;
#[doc = " \\brief Use to extract the Cb/U channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_U: vx_channel_e = 36885;
#[doc = " \\brief Use to extract the Cr/V/Value channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_V: vx_channel_e = 36886;
#[doc = " \\brief The channel enumerations for channel extractions."]
#[doc = " \\see vxChannelExtractNode"]
#[doc = " \\see vxuChannelExtract"]
#[doc = " \\see VX_KERNEL_CHANNEL_EXTRACT"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_channel_e = ::std::os::raw::c_uint;
#[doc = " \\brief For memory allocated through OpenVX, this is the import type."]
pub const vx_memory_type_e_VX_MEMORY_TYPE_NONE: vx_memory_type_e = 57344;
#[doc = " \\brief The default memory type to import from the Host."]
pub const vx_memory_type_e_VX_MEMORY_TYPE_HOST: vx_memory_type_e = 57345;
#[doc = " \\brief An enumeration of memory import types."]
#[doc = " \\ingroup group_context"]
pub type vx_memory_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Output values are defined to match the source pixel whose center is nearest to the sample position."]
pub const vx_interpolation_type_e_VX_INTERPOLATION_NEAREST_NEIGHBOR: vx_interpolation_type_e =
    16384;
#[doc = " \\brief Output values are defined by bilinear interpolation between the pixels whose centers are closest"]
#[doc = " to the sample position, weighted linearly by the distance of the sample from the pixel centers."]
pub const vx_interpolation_type_e_VX_INTERPOLATION_BILINEAR: vx_interpolation_type_e = 16385;
#[doc = " \\brief Output values are determined by averaging the source pixels whose areas fall under the"]
#[doc = " area of the destination pixel, projected onto the source image."]
pub const vx_interpolation_type_e_VX_INTERPOLATION_AREA: vx_interpolation_type_e = 16386;
#[doc = " \\brief The image reconstruction filters supported by image resampling operations."]
#[doc = ""]
#[doc = " The edge of a pixel is interpreted as being aligned to the edge of the image."]
#[doc = " The value for an output pixel is evaluated at the center of that pixel."]
#[doc = ""]
#[doc = " This means, for example, that an even enlargement of a factor of two in nearest-neighbor"]
#[doc = " interpolation will replicate every source pixel into a 2x2 quad in the destination, and that"]
#[doc = " an even shrink by a factor of two in bilinear interpolation will create each destination pixel"]
#[doc = " by average a 2x2 quad of source pixels."]
#[doc = ""]
#[doc = " Samples that cross the boundary of the source image have values determined by the border"]
#[doc = " mode - see <tt>\\ref vx_border_e</tt> and <tt>\\ref VX_NODE_BORDER</tt>."]
#[doc = " \\see vxuScaleImage"]
#[doc = " \\see vxScaleImageNode"]
#[doc = " \\see VX_KERNEL_SCALE_IMAGE"]
#[doc = " \\see vxuWarpAffine"]
#[doc = " \\see vxWarpAffineNode"]
#[doc = " \\see VX_KERNEL_WARP_AFFINE"]
#[doc = " \\see vxuWarpPerspective"]
#[doc = " \\see vxWarpPerspectiveNode"]
#[doc = " \\see VX_KERNEL_WARP_PERSPECTIVE"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_interpolation_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Nonlinear median filter."]
pub const vx_non_linear_filter_e_VX_NONLINEAR_FILTER_MEDIAN: vx_non_linear_filter_e = 90112;
#[doc = " \\brief Nonlinear Erode."]
pub const vx_non_linear_filter_e_VX_NONLINEAR_FILTER_MIN: vx_non_linear_filter_e = 90113;
#[doc = " \\brief Nonlinear Dilate."]
pub const vx_non_linear_filter_e_VX_NONLINEAR_FILTER_MAX: vx_non_linear_filter_e = 90114;
#[doc = " \\brief An enumeration of non-linear filter functions."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_non_linear_filter_e = ::std::os::raw::c_uint;
#[doc = " \\brief Box pattern matrix"]
pub const vx_pattern_e_VX_PATTERN_BOX: vx_pattern_e = 94208;
#[doc = " \\brief Cross pattern matrix"]
pub const vx_pattern_e_VX_PATTERN_CROSS: vx_pattern_e = 94209;
#[doc = " \\brief A square matrix (rows = columns = size)"]
pub const vx_pattern_e_VX_PATTERN_DISK: vx_pattern_e = 94210;
#[doc = " \\brief Matrix with any pattern other than above."]
pub const vx_pattern_e_VX_PATTERN_OTHER: vx_pattern_e = 94211;
#[doc = " \\brief An enumeration of matrix patterns. See <tt>\\ref vxCreateMatrixFromPattern </tt>"]
#[doc = "  and <tt>\\ref vxCreateMatrixFromPatternAndOrigin </tt>"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_pattern_e = ::std::os::raw::c_uint;
#[doc = " \\brief Use to indicate that no color space is used."]
pub const vx_color_space_e_VX_COLOR_SPACE_NONE: vx_color_space_e = 24576;
#[doc = " \\brief Use to indicate that the BT.601 coefficients and SMPTE C primaries are used for conversions."]
pub const vx_color_space_e_VX_COLOR_SPACE_BT601_525: vx_color_space_e = 24577;
#[doc = " \\brief Use to indicate that the BT.601 coefficients and BTU primaries are used for conversions."]
pub const vx_color_space_e_VX_COLOR_SPACE_BT601_625: vx_color_space_e = 24578;
#[doc = " \\brief Use to indicate that the BT.709 coefficients are used for conversions."]
pub const vx_color_space_e_VX_COLOR_SPACE_BT709: vx_color_space_e = 24579;
#[doc = " \\brief All images in VX are by default BT.709"]
pub const vx_color_space_e_VX_COLOR_SPACE_DEFAULT: vx_color_space_e = 24579;
#[doc = " \\brief The image color space list used by the <tt>\\ref VX_IMAGE_SPACE</tt> attribute of a <tt>\\ref vx_image</tt>."]
#[doc = " \\ingroup group_image"]
pub type vx_color_space_e = ::std::os::raw::c_uint;
#[doc = " \\brief Full range of the unit of the channel"]
pub const vx_channel_range_e_VX_CHANNEL_RANGE_FULL: vx_channel_range_e = 28672;
#[doc = " \\brief Restricted range of the unit of the channel based on the space given"]
pub const vx_channel_range_e_VX_CHANNEL_RANGE_RESTRICTED: vx_channel_range_e = 28673;
#[doc = " \\brief The image channel range list used by the <tt>\\ref VX_IMAGE_RANGE</tt> attribute of a <tt>\\ref vx_image</tt>."]
#[doc = "  \\ingroup group_image"]
pub type vx_channel_range_e = ::std::os::raw::c_uint;
#[doc = " \\brief Default. The parameter must be supplied. If not set, during"]
#[doc = " Verify, an error is returned."]
pub const vx_parameter_state_e_VX_PARAMETER_STATE_REQUIRED: vx_parameter_state_e = 32768;
#[doc = " \\brief The parameter may be unspecified. The kernel takes care not"]
#[doc = " to deference optional parameters until it is certain they are valid."]
pub const vx_parameter_state_e_VX_PARAMETER_STATE_OPTIONAL: vx_parameter_state_e = 32769;
#[doc = " \\brief The parameter state type."]
#[doc = " \\ingroup group_parameter"]
pub type vx_parameter_state_e = ::std::os::raw::c_uint;
#[doc = " \\brief No defined border mode behavior is given."]
pub const vx_border_e_VX_BORDER_UNDEFINED: vx_border_e = 49152;
#[doc = " \\brief For nodes that support this behavior, a constant value is"]
#[doc = " \\e filled-in when accessing out-of-bounds pixels."]
pub const vx_border_e_VX_BORDER_CONSTANT: vx_border_e = 49153;
#[doc = " \\brief For nodes that support this behavior, a replication of the nearest"]
#[doc = " edge pixels value is given for out-of-bounds pixels."]
pub const vx_border_e_VX_BORDER_REPLICATE: vx_border_e = 49154;
#[doc = " \\brief The border mode list."]
#[doc = " \\ingroup group_borders"]
pub type vx_border_e = ::std::os::raw::c_uint;
#[doc = " \\brief Use VX_BORDER_UNDEFINED instead of unsupported border modes."]
pub const vx_border_policy_e_VX_BORDER_POLICY_DEFAULT_TO_UNDEFINED: vx_border_policy_e = 81920;
#[doc = " \\brief Return VX_ERROR_NOT_SUPPORTED for unsupported border modes."]
pub const vx_border_policy_e_VX_BORDER_POLICY_RETURN_ERROR: vx_border_policy_e = 81921;
#[doc = " \\brief The unsupported border mode policy list."]
#[doc = " \\ingroup group_borders"]
pub type vx_border_policy_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates a termination after a set number of iterations."]
pub const vx_termination_criteria_e_VX_TERM_CRITERIA_ITERATIONS: vx_termination_criteria_e = 61440;
#[doc = " \\brief Indicates a termination after matching against the value of eplison provided to the function."]
pub const vx_termination_criteria_e_VX_TERM_CRITERIA_EPSILON: vx_termination_criteria_e = 61441;
#[doc = " \\brief Indicates that both an iterations and eplison method are employed. Whichever one matches first"]
#[doc = " causes the termination."]
pub const vx_termination_criteria_e_VX_TERM_CRITERIA_BOTH: vx_termination_criteria_e = 61442;
#[doc = " \\brief The termination criteria list."]
#[doc = " \\see group_vision_function_opticalflowpyrlk"]
#[doc = " \\ingroup group_context"]
pub type vx_termination_criteria_e = ::std::os::raw::c_uint;
#[doc = " \\brief The L1 normalization."]
pub const vx_norm_type_e_VX_NORM_L1: vx_norm_type_e = 65536;
#[doc = " \\brief The L2 normalization."]
pub const vx_norm_type_e_VX_NORM_L2: vx_norm_type_e = 65537;
#[doc = " \\brief A normalization type."]
#[doc = " \\see group_vision_function_canny"]
#[doc = " \\ingroup group_vision_function_canny"]
pub type vx_norm_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief The type of objects in the delay. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_delay_attribute_e_VX_DELAY_TYPE: vx_delay_attribute_e = 525824;
#[doc = " \\brief The number of items in the delay. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_delay_attribute_e_VX_DELAY_SLOTS: vx_delay_attribute_e = 525825;
#[doc = " \\brief The delay attribute list."]
#[doc = " \\ingroup group_delay"]
pub type vx_delay_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The memory shall be treated by the system as if it were read-only."]
#[doc = " If the User writes to this memory, the results are implementation defined."]
pub const vx_accessor_e_VX_READ_ONLY: vx_accessor_e = 69633;
#[doc = " \\brief The memory shall be treated by the system as if it were write-only."]
#[doc = " If the User reads from this memory, the results are implementation defined."]
pub const vx_accessor_e_VX_WRITE_ONLY: vx_accessor_e = 69634;
#[doc = " \\brief The memory shall be treated by the system as if it were readable and writeable."]
pub const vx_accessor_e_VX_READ_AND_WRITE: vx_accessor_e = 69635;
#[doc = " \\brief The memory accessor hint flags."]
#[doc = " These enumeration values are used to indicate desired \\e system behavior,"]
#[doc = " not the \\b User intent. For example: these can be interpretted as hints to the"]
#[doc = " system about cache operations or marshalling operations."]
#[doc = " \\ingroup group_context"]
pub type vx_accessor_e = ::std::os::raw::c_uint;
#[doc = " \\brief When scaling, this truncates the least significant values that are lost in operations."]
pub const vx_round_policy_e_VX_ROUND_POLICY_TO_ZERO: vx_round_policy_e = 73729;
#[doc = " \\brief When scaling, this rounds to nearest even output value."]
pub const vx_round_policy_e_VX_ROUND_POLICY_TO_NEAREST_EVEN: vx_round_policy_e = 73730;
#[doc = " \\brief The Round Policy Enumeration."]
#[doc = " \\ingroup group_context"]
pub type vx_round_policy_e = ::std::os::raw::c_uint;
#[doc = " \\brief local binary pattern"]
pub const vx_lbp_format_e_VX_LBP: vx_lbp_format_e = 98304;
#[doc = " \\brief Modified Local Binary Patterns"]
pub const vx_lbp_format_e_VX_MLBP: vx_lbp_format_e = 98305;
#[doc = " \\brief Uniform local binary pattern"]
pub const vx_lbp_format_e_VX_ULBP: vx_lbp_format_e = 98306;
#[doc = " \\brief Local binary pattern supported."]
#[doc = " \\ingroup group_vision_function_lbp"]
pub type vx_lbp_format_e = ::std::os::raw::c_uint;
#[doc = " \\brief hamming distance \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} XOR(T(\\grave{x},\\grave{y}),I(x+\\grave{x},y+\\grave{y}))\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_HAMMING: vx_comp_metric_e = 102400;
#[doc = " \\brief L1 distance \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} ABS(T(\\grave{x},\\grave{y}) - I(x+\\grave{x},y+\\grave{y}))\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_L1: vx_comp_metric_e = 102401;
#[doc = " \\brief L2 distance normalized by image size \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} (T(\\grave{x},\\grave{y}) - I(x+\\grave{x},y+\\grave{y}))^2\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_L2: vx_comp_metric_e = 102402;
#[doc = " \\brief cross correlation distance \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} (T(\\grave{x},\\grave{y})*I(x+\\grave{x},y+\\grave{y}))\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_CCORR: vx_comp_metric_e = 102403;
#[doc = " \\brief L2 normalized distance \\f$ R(x,y) = \\frac{\\sum_{\\grave{x},\\grave{y}}^{w,h} (T(\\grave{x},\\grave{y}) - I(x+\\grave{x},y+\\grave{y}))^2}"]
#[doc = " {\\sqrt{\\sum_{\\grave{x},\\grave{y}}^{w,h} T(\\grave{x},\\grave{y})^2 * I(x+\\grave{x},y+\\grave{y})^2}} \\f$"]
pub const vx_comp_metric_e_VX_COMPARE_L2_NORM: vx_comp_metric_e = 102404;
#[doc = " \\brief cross correlation normalized distance \\f$ R(x,y) = \\frac{\\sum_{\\grave{x},\\grave{y}}^{w,h} T(\\grave{x},\\grave{y}) * I(x+\\grave{x},y+\\grave{y})*2^{15}}"]
#[doc = " {\\sqrt{\\sum_{\\grave{x},\\grave{y}}^{w,h} T(\\grave{x},\\grave{y})^2 * I(x+\\grave{x},y+\\grave{y})^2}} \\f$"]
pub const vx_comp_metric_e_VX_COMPARE_CCORR_NORM: vx_comp_metric_e = 102405;
#[doc = " \\brief comparing metrics."]
#[doc = " \\details In all the equations below w and h are width and height of the template image respectively."]
#[doc = " \\f$ R \\f$ is the compare map. \\f$ T \\f$ is the template image.\\f$ I \\f$ is the image on which the template is searched."]
#[doc = " \\ingroup group_vision_function_match_template"]
pub type vx_comp_metric_e = ::std::os::raw::c_uint;
#[doc = " \\brief The addressing image patch structure is used by the Host only"]
#[doc = " to address pixels in an image patch. The fields of the structure are defined as:"]
#[doc = " \\arg dim - The dimensions of the image in logical pixel units in the x & y direction."]
#[doc = " \\arg stride - The physical byte distance from a logical pixel to the next"]
#[doc = " logically adjacent pixel in the positive x or y direction."]
#[doc = " \\arg scale - The relationship of scaling from the primary plane (typically"]
#[doc = " the zero indexed plane) to this plane. An integer down-scaling factor of \\f$ f \\f$ shall be"]
#[doc = " set to a value equal to \\f$ scale = \\frac{unity}{f} \\f$ and an integer up-scaling factor of \\f$ f \\f$"]
#[doc = " shall be set to a value of \\f$ scale = unity * f \\f$. \\f$ unity \\f$ is defined as <tt>\\ref VX_SCALE_UNITY</tt>."]
#[doc = " \\arg step - The step is the number of logical pixel units to skip to"]
#[doc = " arrive at the next physically unique pixel. For example, on a plane that is"]
#[doc = " half-scaled in a dimension, the step in that dimension is 2 to indicate that"]
#[doc = " every other pixel in that dimension is an alias. This is useful in situations"]
#[doc = " where iteration over unique pixels is required, such as in serializing"]
#[doc = " or de-serializing the image patch information."]
#[doc = " \\see <tt>\\ref vxMapImagePatch</tt>"]
#[doc = " \\note For <tt>\\ref VX_DF_IMAGE_U1</tt> images it is defined that \\a stride_x == 0 since it is less than one byte."]
#[doc = " The least significant bit (bit number 0, value 1) in the first byte in the image,"]
#[doc = " is the left-most pixel in the upper left corner, i.e. origo. A <tt>\\ref VX_DF_IMAGE_U1</tt> image always"]
#[doc = " start on a byte boundary and each row has a \\a stride_y that is a multiple of whole bytes, which means padding"]
#[doc = " bits of undefined value may be present at the end of each row."]
#[doc = " Imagepatches can only be accessed at a multiple of eight pixels: the x-coordinate must be a multiple of eight."]
#[doc = " Individual pixel access is also different: the byte at the imagepatch-calculated pointer value is a collection of eight pixels."]
#[doc = " Each byte can then be masked with the bit-mask <tt> 1 << (x % 8)</tt> to get individual pixel values (shifted <tt>x</tt> times)."]
#[doc = " See \\ref sub_image_access for an example."]
#[doc = " \\ingroup group_image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_imagepatch_addressing_t {
    #[doc = "< \\brief Width of patch in X dimension in pixels."]
    pub dim_x: vx_uint32,
    #[doc = "< \\brief Height of patch in Y dimension in pixels."]
    pub dim_y: vx_uint32,
    #[doc = "< \\brief Stride in X dimension in bytes."]
    pub stride_x: vx_int32,
    #[doc = "< \\brief Stride in Y dimension in bytes."]
    pub stride_y: vx_int32,
    #[doc = "< \\brief Scale of X dimension. For sub-sampled planes this is the scaling factor of the dimension of the plane in relation to the zero plane. Use <tt>\\ref VX_SCALE_UNITY</tt> in the numerator."]
    pub scale_x: vx_uint32,
    #[doc = "< \\brief Scale of Y dimension. For sub-sampled planes this is the scaling factor of the dimension of the plane in relation to the zero plane. Use <tt>\\ref VX_SCALE_UNITY</tt> in the numerator."]
    pub scale_y: vx_uint32,
    #[doc = "< \\brief Step of X dimension in pixels."]
    pub step_x: vx_uint32,
    #[doc = "< \\brief Step of Y dimension in pixels."]
    pub step_y: vx_uint16,
    #[doc = "< \\brief Stride in X dimension in bits. Used when stride_x is not an integer number of bytes."]
    pub stride_x_bits: vx_uint16,
}
#[test]
fn bindgen_test_layout__vx_imagepatch_addressing_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_imagepatch_addressing_t>(),
        32usize,
        concat!("Size of: ", stringify!(_vx_imagepatch_addressing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_imagepatch_addressing_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_imagepatch_addressing_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).dim_x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(dim_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).dim_y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(dim_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).stride_x as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(stride_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).stride_y as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(stride_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).scale_x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(scale_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).scale_y as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(scale_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).step_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(step_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).step_y as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(step_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_imagepatch_addressing_t>())).stride_x_bits as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(stride_x_bits)
        )
    );
}
#[doc = " \\brief The addressing image patch structure is used by the Host only"]
#[doc = " to address pixels in an image patch. The fields of the structure are defined as:"]
#[doc = " \\arg dim - The dimensions of the image in logical pixel units in the x & y direction."]
#[doc = " \\arg stride - The physical byte distance from a logical pixel to the next"]
#[doc = " logically adjacent pixel in the positive x or y direction."]
#[doc = " \\arg scale - The relationship of scaling from the primary plane (typically"]
#[doc = " the zero indexed plane) to this plane. An integer down-scaling factor of \\f$ f \\f$ shall be"]
#[doc = " set to a value equal to \\f$ scale = \\frac{unity}{f} \\f$ and an integer up-scaling factor of \\f$ f \\f$"]
#[doc = " shall be set to a value of \\f$ scale = unity * f \\f$. \\f$ unity \\f$ is defined as <tt>\\ref VX_SCALE_UNITY</tt>."]
#[doc = " \\arg step - The step is the number of logical pixel units to skip to"]
#[doc = " arrive at the next physically unique pixel. For example, on a plane that is"]
#[doc = " half-scaled in a dimension, the step in that dimension is 2 to indicate that"]
#[doc = " every other pixel in that dimension is an alias. This is useful in situations"]
#[doc = " where iteration over unique pixels is required, such as in serializing"]
#[doc = " or de-serializing the image patch information."]
#[doc = " \\see <tt>\\ref vxMapImagePatch</tt>"]
#[doc = " \\note For <tt>\\ref VX_DF_IMAGE_U1</tt> images it is defined that \\a stride_x == 0 since it is less than one byte."]
#[doc = " The least significant bit (bit number 0, value 1) in the first byte in the image,"]
#[doc = " is the left-most pixel in the upper left corner, i.e. origo. A <tt>\\ref VX_DF_IMAGE_U1</tt> image always"]
#[doc = " start on a byte boundary and each row has a \\a stride_y that is a multiple of whole bytes, which means padding"]
#[doc = " bits of undefined value may be present at the end of each row."]
#[doc = " Imagepatches can only be accessed at a multiple of eight pixels: the x-coordinate must be a multiple of eight."]
#[doc = " Individual pixel access is also different: the byte at the imagepatch-calculated pointer value is a collection of eight pixels."]
#[doc = " Each byte can then be masked with the bit-mask <tt> 1 << (x % 8)</tt> to get individual pixel values (shifted <tt>x</tt> times)."]
#[doc = " See \\ref sub_image_access for an example."]
#[doc = " \\ingroup group_image"]
pub type vx_imagepatch_addressing_t = _vx_imagepatch_addressing_t;
#[doc = " \\brief The performance measurement structure. The time or durations are in units of nano seconds."]
#[doc = " \\ingroup group_performance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_perf_t {
    #[doc = "< \\brief Holds the last measurement."]
    pub tmp: vx_uint64,
    #[doc = "< \\brief Holds the first measurement in a set."]
    pub beg: vx_uint64,
    #[doc = "< \\brief Holds the last measurement in a set."]
    pub end: vx_uint64,
    #[doc = "< \\brief Holds the summation of durations."]
    pub sum: vx_uint64,
    #[doc = "< \\brief Holds the average of the durations."]
    pub avg: vx_uint64,
    #[doc = "< \\brief Holds the minimum of the durations."]
    pub min: vx_uint64,
    #[doc = "< \\brief Holds the number of measurements."]
    pub num: vx_uint64,
    #[doc = "< \\brief Holds the maximum of the durations."]
    pub max: vx_uint64,
}
#[test]
fn bindgen_test_layout__vx_perf_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_perf_t>(),
        64usize,
        concat!("Size of: ", stringify!(_vx_perf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_perf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_perf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).tmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(tmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).beg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(beg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).avg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).min as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).num as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_perf_t>())).max as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " \\brief The performance measurement structure. The time or durations are in units of nano seconds."]
#[doc = " \\ingroup group_performance"]
pub type vx_perf_t = _vx_perf_t;
#[doc = " \\brief Hough lines probability parameters."]
#[doc = " \\ingroup group_vision_function_hough_lines_p"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_hough_lines_p_t {
    #[doc = " \\brief  Distance resolution of the parameter in pixels."]
    pub rho: vx_float32,
    #[doc = " \\brief Angle resolution of the parameter in radians."]
    pub theta: vx_float32,
    #[doc = " \\brief The minimum number of intersections to detect a line."]
    pub threshold: vx_int32,
    #[doc = " \\brief The minimum number of points that can form a line. Line segments shorter than that are rejected."]
    pub line_length: vx_int32,
    #[doc = " \\brief The maximum allowed gap between points on the same line to link them."]
    pub line_gap: vx_int32,
    #[doc = " \\brief Optional restriction on theta. The max allowed value."]
    pub theta_max: vx_float32,
    #[doc = " \\brief Optional restriction on theta. The min allowed value."]
    pub theta_min: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_hough_lines_p_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_hough_lines_p_t>(),
        28usize,
        concat!("Size of: ", stringify!(_vx_hough_lines_p_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_hough_lines_p_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_hough_lines_p_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).rho as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(rho)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).theta as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(theta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).threshold as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).line_length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(line_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).line_gap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(line_gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).theta_max as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(theta_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_hough_lines_p_t>())).theta_min as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(theta_min)
        )
    );
}
#[doc = " \\brief Hough lines probability parameters."]
#[doc = " \\ingroup group_vision_function_hough_lines_p"]
pub type vx_hough_lines_p_t = _vx_hough_lines_p_t;
#[doc = " \\brief line struct"]
#[doc = " \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_line2d_t {
    #[doc = " \\brief x index of line start"]
    pub start_x: vx_float32,
    #[doc = " \\brief y index of line start"]
    pub start_y: vx_float32,
    #[doc = " \\brief x index of line end"]
    pub end_x: vx_float32,
    #[doc = " \\brief y index of line end"]
    pub end_y: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_line2d_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_line2d_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_line2d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_line2d_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_line2d_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_line2d_t>())).start_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_line2d_t>())).start_y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_line2d_t>())).end_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(end_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_line2d_t>())).end_y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(end_y)
        )
    );
}
#[doc = " \\brief line struct"]
#[doc = " \\ingroup group_basic_features"]
pub type vx_line2d_t = _vx_line2d_t;
#[doc = " \\brief Matrix Multiply Parameters"]
#[doc = ""]
#[doc = " transpose_input1/input2/input3 : if True the matrix is transposed before the operation, otherwise the matrix is used as is. \\n"]
#[doc = " \\ingroup group_vision_function_tensor_matrix_multiply"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_tensor_matrix_multiply_params_t {
    #[doc = " \\brief if True the matrix is transposed before the operation, otherwise the matrix is used as is"]
    pub transpose_input1: vx_bool,
    #[doc = " \\brief if True the matrix is transposed before the operation, otherwise the matrix is used as is"]
    pub transpose_input2: vx_bool,
    #[doc = " \\brief if True the matrix is transposed before the operation, otherwise the matrix is used as is"]
    pub transpose_input3: vx_bool,
}
#[test]
fn bindgen_test_layout__vx_tensor_matrix_multiply_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_tensor_matrix_multiply_params_t>(),
        12usize,
        concat!("Size of: ", stringify!(_vx_tensor_matrix_multiply_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_tensor_matrix_multiply_params_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_vx_tensor_matrix_multiply_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_tensor_matrix_multiply_params_t>())).transpose_input1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tensor_matrix_multiply_params_t),
            "::",
            stringify!(transpose_input1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_tensor_matrix_multiply_params_t>())).transpose_input2
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tensor_matrix_multiply_params_t),
            "::",
            stringify!(transpose_input2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_vx_tensor_matrix_multiply_params_t>())).transpose_input3
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tensor_matrix_multiply_params_t),
            "::",
            stringify!(transpose_input3)
        )
    );
}
#[doc = " \\brief Matrix Multiply Parameters"]
#[doc = ""]
#[doc = " transpose_input1/input2/input3 : if True the matrix is transposed before the operation, otherwise the matrix is used as is. \\n"]
#[doc = " \\ingroup group_vision_function_tensor_matrix_multiply"]
pub type vx_tensor_matrix_multiply_params_t = _vx_tensor_matrix_multiply_params_t;
#[doc = " \\brief The Kernel Information Structure. This is returned by the Context"]
#[doc = " to indicate which kernels are available in the OpenVX implementation."]
#[doc = " \\ingroup group_kernel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _vx_kernel_info_t {
    #[doc = " \\brief The kernel enumeration value from <tt>\\ref vx_kernel_e</tt> (or an"]
    #[doc = " extension thereof)."]
    #[doc = " \\see vxGetKernelByEnum"]
    pub enumeration: vx_enum,
    #[doc = " \\brief The kernel name in dotted hierarchical format."]
    #[doc = " e.g. \"org.khronos.openvx.sobel_3x3\""]
    #[doc = " \\see vxGetKernelByName"]
    pub name: [vx_char; 256usize],
}
#[test]
fn bindgen_test_layout__vx_kernel_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_kernel_info_t>(),
        260usize,
        concat!("Size of: ", stringify!(_vx_kernel_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_kernel_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_kernel_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_kernel_info_t>())).enumeration as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_kernel_info_t),
            "::",
            stringify!(enumeration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_kernel_info_t>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_kernel_info_t),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " \\brief The Kernel Information Structure. This is returned by the Context"]
#[doc = " to indicate which kernels are available in the OpenVX implementation."]
#[doc = " \\ingroup group_kernel"]
pub type vx_kernel_info_t = _vx_kernel_info_t;
#[doc = " \\brief The keypoint data structure."]
#[doc = " \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_keypoint_t {
    #[doc = "< \\brief The x coordinate."]
    pub x: vx_int32,
    #[doc = "< \\brief The y coordinate."]
    pub y: vx_int32,
    #[doc = "< \\brief The strength of the keypoint. Its definition is specific to the corner detector."]
    pub strength: vx_float32,
    #[doc = "< \\brief Initialized to 0 by corner detectors."]
    pub scale: vx_float32,
    #[doc = "< \\brief Initialized to 0 by corner detectors."]
    pub orientation: vx_float32,
    #[doc = "< \\brief A zero indicates a lost point. Initialized to 1 by corner detectors."]
    pub tracking_status: vx_int32,
    #[doc = "< \\brief A tracking method specific error. Initialized to 0 by corner detectors."]
    pub error: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_keypoint_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_keypoint_t>(),
        28usize,
        concat!("Size of: ", stringify!(_vx_keypoint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_keypoint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_keypoint_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).strength as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).scale as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).orientation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).tracking_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(tracking_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_keypoint_t>())).error as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(error)
        )
    );
}
#[doc = " \\brief The keypoint data structure."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_keypoint_t = _vx_keypoint_t;
#[doc = " \\brief The rectangle data structure that is shared with the users. The area of the rectangle can be computed as (end_x-start_x)*(end_y-start_y)."]
#[doc = " \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_rectangle_t {
    #[doc = "< \\brief The Start X coordinate."]
    pub start_x: vx_uint32,
    #[doc = "< \\brief The Start Y coordinate."]
    pub start_y: vx_uint32,
    #[doc = "< \\brief The End X coordinate."]
    pub end_x: vx_uint32,
    #[doc = "< \\brief The End Y coordinate."]
    pub end_y: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_rectangle_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_rectangle_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_rectangle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_rectangle_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_rectangle_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_rectangle_t>())).start_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_rectangle_t>())).start_y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_rectangle_t>())).end_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(end_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_rectangle_t>())).end_y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(end_y)
        )
    );
}
#[doc = " \\brief The rectangle data structure that is shared with the users. The area of the rectangle can be computed as (end_x-start_x)*(end_y-start_y)."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_rectangle_t = _vx_rectangle_t;
#[doc = " \\brief The 2D Coordinates structure."]
#[doc = " \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_coordinates2d_t {
    #[doc = "< \\brief The X coordinate."]
    pub x: vx_uint32,
    #[doc = "< \\brief The Y coordinate."]
    pub y: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_coordinates2d_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_coordinates2d_t>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_coordinates2d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_coordinates2d_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_coordinates2d_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates2d_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2d_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates2d_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2d_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief The 2D Coordinates structure."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_coordinates2d_t = _vx_coordinates2d_t;
#[doc = " \\brief The floating-point 2D Coordinates structure."]
#[doc = " \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_coordinates2df_t {
    #[doc = "< \\brief The X coordinate."]
    pub x: vx_float32,
    #[doc = "< \\brief The Y coordinate."]
    pub y: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_coordinates2df_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_coordinates2df_t>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_coordinates2df_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_coordinates2df_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_coordinates2df_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates2df_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2df_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates2df_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2df_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief The floating-point 2D Coordinates structure."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_coordinates2df_t = _vx_coordinates2df_t;
#[doc = " \\brief The 3D Coordinates structure."]
#[doc = " \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_coordinates3d_t {
    #[doc = "< \\brief The X coordinate."]
    pub x: vx_uint32,
    #[doc = "< \\brief The Y coordinate."]
    pub y: vx_uint32,
    #[doc = "< \\brief The Z coordinate."]
    pub z: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_coordinates3d_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_coordinates3d_t>(),
        12usize,
        concat!("Size of: ", stringify!(_vx_coordinates3d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_coordinates3d_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_coordinates3d_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates3d_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates3d_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates3d_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates3d_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_coordinates3d_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates3d_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " \\brief The 3D Coordinates structure."]
#[doc = " \\ingroup group_basic_features"]
pub type vx_coordinates3d_t = _vx_coordinates3d_t;
#[doc = " \\brief Union that describes the value of a pixel for any image format. Use the field"]
#[doc = " corresponding to the image format."]
#[doc = " \\ingroup group_image"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _vx_pixel_value_t {
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_RGB</tt> format in the R,G,B order"]
    pub RGB: [vx_uint8; 3usize],
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_RGBX</tt> format in the R,G,B,X order"]
    pub RGBX: [vx_uint8; 4usize],
    #[doc = "< \\brief All YUV formats in the Y,U,V order"]
    pub YUV: [vx_uint8; 3usize],
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U1</tt>"]
    pub U1: vx_bool,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U8</tt>"]
    pub U8: vx_uint8,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U16</tt>"]
    pub U16: vx_uint16,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_S16</tt>"]
    pub S16: vx_int16,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U32</tt>"]
    pub U32: vx_uint32,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_S32</tt>"]
    pub S32: vx_int32,
    pub reserved: [vx_uint8; 16usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__vx_pixel_value_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_pixel_value_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_pixel_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_pixel_value_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_pixel_value_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).RGB as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(RGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).RGBX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(RGBX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).YUV as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(YUV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).U1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).U8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).U16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).S16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(S16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).U32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).S32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(S32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_pixel_value_t>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\brief Union that describes the value of a pixel for any image format. Use the field"]
#[doc = " corresponding to the image format."]
#[doc = " \\ingroup group_image"]
pub type vx_pixel_value_t = _vx_pixel_value_t;
#[doc = " \\brief The HOG descriptor structure."]
#[doc = " \\ingroup group_vision_function_hog"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vx_hog_t {
    #[doc = " \\brief   The histogram cell width of type <tt>\\ref VX_TYPE_INT32</tt>."]
    pub cell_width: vx_int32,
    #[doc = " \\brief   The histogram cell height of type <tt>\\ref VX_TYPE_INT32</tt>."]
    pub cell_height: vx_int32,
    #[doc = " \\brief  The histogram block width of type <tt>\\ref VX_TYPE_INT32</tt>.  Must be divisible by cell_width."]
    pub block_width: vx_int32,
    #[doc = " \\brief  The histogram block height of type <tt>\\ref VX_TYPE_INT32</tt>.  Must be divisible by cell_height."]
    pub block_height: vx_int32,
    #[doc = " \\brief  The histogram block stride within the window of type <tt>\\ref VX_TYPE_INT32</tt>.  Must be an integral number of cell_width and cell_height."]
    pub block_stride: vx_int32,
    #[doc = " \\brief  The histogram size of type <tt>\\ref VX_TYPE_INT32</tt>."]
    pub num_bins: vx_int32,
    #[doc = " \\brief  The feature descriptor window width of type <tt>\\ref VX_TYPE_INT32</tt>"]
    pub window_width: vx_int32,
    #[doc = " \\brief  The feature descriptor window height of type <tt>\\ref VX_TYPE_INT32</tt>"]
    pub window_height: vx_int32,
    #[doc = " \\brief The feature descriptor window stride of type <tt>\\ref VX_TYPE_INT32</tt>"]
    pub window_stride: vx_int32,
    #[doc = " \\brief The threshold for the maximum L2-norm value for a histogram bin.  It is used as part of block normalization.  It defaults to 0.2."]
    pub threshold: vx_float32,
}
#[test]
fn bindgen_test_layout_vx_hog_t() {
    assert_eq!(
        ::std::mem::size_of::<vx_hog_t>(),
        40usize,
        concat!("Size of: ", stringify!(vx_hog_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vx_hog_t>(),
        4usize,
        concat!("Alignment of ", stringify!(vx_hog_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).cell_width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(cell_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).cell_height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(cell_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).block_width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(block_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).block_height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(block_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).block_stride as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(block_stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).num_bins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(num_bins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).window_width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(window_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).window_height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(window_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).window_stride as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(window_stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vx_hog_t>())).threshold as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(threshold)
        )
    );
}
#[doc = " \\brief Use with the enumeration <tt>\\ref VX_NODE_BORDER</tt> to set the"]
#[doc = " border mode behavior of a node that supports borders."]
#[doc = ""]
#[doc = " If the indicated border mode is not supported, an error <tt>\\ref VX_ERROR_NOT_SUPPORTED</tt> will be reported"]
#[doc = " either at the time the <tt>\\ref VX_NODE_BORDER</tt> is set or at the time of graph verification."]
#[doc = " \\ingroup group_borders"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _vx_border_t {
    #[doc = " \\brief See <tt>\\ref vx_border_e</tt>."]
    pub mode: vx_enum,
    #[doc = " \\brief For the mode <tt>\\ref VX_BORDER_CONSTANT</tt>, this union contains the"]
    #[doc = " value of out-of-bound pixels."]
    pub constant_value: vx_pixel_value_t,
}
#[test]
fn bindgen_test_layout__vx_border_t() {
    assert_eq!(
        ::std::mem::size_of::<_vx_border_t>(),
        20usize,
        concat!("Size of: ", stringify!(_vx_border_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_border_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_border_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_border_t>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_border_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_vx_border_t>())).constant_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_border_t),
            "::",
            stringify!(constant_value)
        )
    );
}
#[doc = " \\brief Use with the enumeration <tt>\\ref VX_NODE_BORDER</tt> to set the"]
#[doc = " border mode behavior of a node that supports borders."]
#[doc = ""]
#[doc = " If the indicated border mode is not supported, an error <tt>\\ref VX_ERROR_NOT_SUPPORTED</tt> will be reported"]
#[doc = " either at the time the <tt>\\ref VX_NODE_BORDER</tt> is set or at the time of graph verification."]
#[doc = " \\ingroup group_borders"]
pub type vx_border_t = _vx_border_t;
#[doc = " \\brief The type of the <tt>vxPublishKernels</tt> entry function of modules loaded"]
#[doc = " by <tt>\\ref vxLoadKernels</tt> and unloaded by <tt>\\ref vxUnloadKernels</tt>."]
#[doc = " \\param [in] context The reference to the context kernels must be added to."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_publish_kernels_f =
    ::std::option::Option<unsafe extern "C" fn(context: vx_context) -> vx_status>;
#[doc = " \\brief The type of the <tt>vxUnpublishKernels</tt> entry function of modules loaded"]
#[doc = " by <tt>\\ref vxLoadKernels</tt> and unloaded by <tt>\\ref vxUnloadKernels</tt>."]
#[doc = " \\param [in] context The reference to the context kernels have been added to."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_unpublish_kernels_f =
    ::std::option::Option<unsafe extern "C" fn(context: vx_context) -> vx_status>;
#[doc = " \\brief The pointer to the Host side kernel."]
#[doc = " \\param [in] node The handle to the node that contains this kernel."]
#[doc = " \\param [in] parameters The array of parameter references."]
#[doc = " \\param [in] num The number of parameters."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_kernel_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
    ) -> vx_status,
>;
#[doc = " \\brief The pointer to the kernel initializer. If the host code requires a call"]
#[doc = " to initialize data once all the parameters have been validated, this function is called"]
#[doc = " if not NULL."]
#[doc = " \\param [in] node The handle to the node that contains this kernel."]
#[doc = " \\param [in] parameters The array of parameter references."]
#[doc = " \\param [in] num The number of parameters."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_kernel_initialize_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
    ) -> vx_status,
>;
#[doc = " \\brief The pointer to the kernel deinitializer. If the host code requires a call"]
#[doc = " to deinitialize data during a node garbage collection, this function is called"]
#[doc = " if not NULL."]
#[doc = " \\param [in] node The handle to the node that contains this kernel."]
#[doc = " \\param [in] parameters The array of parameter references."]
#[doc = " \\param [in] num The number of parameters."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_kernel_deinitialize_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
    ) -> vx_status,
>;
#[doc = " \\brief The user-defined kernel node parameters validation function. The function only"]
#[doc = " needs to fill in the meta data structure(s)."]
#[doc = " \\note This function is called once for whole set of parameters."]
#[doc = " \\param [in] node The handle to the node that is being validated."]
#[doc = " \\param [in] parameters The array of parameters to be validated."]
#[doc = " \\param [in] num Number of parameters to be validated."]
#[doc = " \\param [in] metas A pointer to a pre-allocated array of structure references that the system holds."]
#[doc = " The system pre-allocates a number of vx_meta_format structures for the output parameters only,"]
#[doc = " indexed by the same indices as parameters[]. The validation function fills in the correct type, format,"]
#[doc = " and dimensionality for the system to use either to create memory or to check against existing memory."]
#[doc = " \\return An error code describing the validation status on parameters."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_kernel_validate_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
        metas: *mut vx_meta_format,
    ) -> vx_status,
>;
#[doc = " \\brief A user-defined callback function to set the valid rectangle of an output image."]
#[doc = ""]
#[doc = " The <tt>\\ref VX_VALID_RECT_CALLBACK</tt> attribute in the <tt>\\ref vx_meta_format</tt> object should be"]
#[doc = " set to the desired callback during user node's output validator. The callback must not call"]
#[doc = " <tt>\\ref vxGetValidRegionImage</tt> or <tt>\\ref vxSetImageValidRectangle</tt>.  Instead, an array of the"]
#[doc = " valid rectangles of all the input images is supplied to the callback to calculate the output"]
#[doc = " valid rectangle. The output of the user node may be a pyramid, or just an image.  If it is just an"]
#[doc = " image, the 'Out' array associated with that output only has one element.  If the output is a"]
#[doc = " pyramid, the array size is equal to the number of pyramid levels. Notice that the array memory"]
#[doc = " allocation passed to the callback is managed by the framework, the application must not allocate or"]
#[doc = " deallocate those pointers."]
#[doc = ""]
#[doc = " The behavior of the callback function vx_kernel_image_valid_rectangle_f is undefined"]
#[doc = " if one of the following is true:"]
#[doc = " - One of the input arguments of a user node is a pyramid or an array of images."]
#[doc = " - Either input or output argument of a user node is an array of pyramids."]
#[doc = ""]
#[doc = " \\param [in,out] node The handle to the node that is being validated."]
#[doc = " \\param [in] index The index of the output parameter for which a valid region should be set."]
#[doc = " \\param [in] input_valid A pointer to an array of valid regions of input images or images"]
#[doc = " contained in image container (e.g. pyramids). They are provided in same order as the parameter"]
#[doc = " list of the kernel's declaration."]
#[doc = " \\param [out] output_valid An array of valid regions that should be set for the output images or"]
#[doc = " image containers (e.g. pyramid) after graph processing. The length of the array should be equal"]
#[doc = " to the size of the image container (e.g. number of levels in the pyramid). For a simple output"]
#[doc = " image the array size is always one. Each rectangle supplies the valid region for one image. The"]
#[doc = " array memory allocation is managed by the framework."]
#[doc = " \\return An error code describing the validation status on parameters."]
#[doc = " \\ingroup group_user_kernels"]
pub type vx_kernel_image_valid_rectangle_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        index: vx_uint32,
        input_valid: *const *const vx_rectangle_t,
        output_valid: *const *mut vx_rectangle_t,
    ) -> vx_status,
>;
#[doc = " \\brief The log callback function."]
#[doc = " \\ingroup group_log"]
pub type vx_log_callback_f = ::std::option::Option<
    unsafe extern "C" fn(
        context: vx_context,
        ref_: vx_reference,
        status: vx_status,
        string: *const vx_char,
    ),
>;
#[doc = "< \\brief No Gap."]
pub const vx_map_flag_e_VX_NOGAP_X: vx_map_flag_e = 1;
#[doc = " \\brief The Map/Unmap operation enumeration."]
#[doc = " \\ingroup group_image"]
pub type vx_map_flag_e = ::std::os::raw::c_uint;
#[doc = " \\brief The base set of kernels as defined by Khronos."]
pub const vx_library_e_VX_LIBRARY_KHR_BASE: vx_library_e = 0;
#[doc = " \\brief The standard list of available libraries"]
#[doc = " \\ingroup group_kernel"]
pub type vx_library_e = ::std::os::raw::c_uint;
#[doc = " \\brief The Color Space conversion kernel."]
#[doc = " \\details The conversions are based on the <tt>\\ref vx_df_image_e</tt> code in the images."]
#[doc = " \\see group_vision_function_colorconvert"]
pub const vx_kernel_e_VX_KERNEL_COLOR_CONVERT: vx_kernel_e = 1;
#[doc = " \\brief The Generic Channel Extraction Kernel."]
#[doc = " \\details This kernel can remove individual color channels from an interleaved"]
#[doc = " or semi-planar, planar, sub-sampled planar image. A client could extract"]
#[doc = " a red channel from an interleaved RGB image or do a Luma extract from a"]
#[doc = " YUV format."]
#[doc = " \\see group_vision_function_channelextract"]
pub const vx_kernel_e_VX_KERNEL_CHANNEL_EXTRACT: vx_kernel_e = 2;
#[doc = " \\brief The Generic Channel Combine Kernel."]
#[doc = " \\details This kernel combine multiple individual planes into a single"]
#[doc = " multiplanar image of the type specified in the output image."]
#[doc = " \\see group_vision_function_channelcombine"]
pub const vx_kernel_e_VX_KERNEL_CHANNEL_COMBINE: vx_kernel_e = 3;
#[doc = " \\brief The Sobel 3x3 Filter Kernel."]
#[doc = " \\see group_vision_function_sobel3x3"]
pub const vx_kernel_e_VX_KERNEL_SOBEL_3x3: vx_kernel_e = 4;
#[doc = " \\brief The Magnitude Kernel."]
#[doc = " \\details This kernel produces a magnitude plane from two input gradients."]
#[doc = " \\see group_vision_function_magnitude"]
pub const vx_kernel_e_VX_KERNEL_MAGNITUDE: vx_kernel_e = 5;
#[doc = " \\brief The Phase Kernel."]
#[doc = " \\details This kernel produces a phase plane from two input gradients."]
#[doc = " \\see group_vision_function_phase"]
pub const vx_kernel_e_VX_KERNEL_PHASE: vx_kernel_e = 6;
#[doc = " \\brief The Scale Image Kernel."]
#[doc = " \\details This kernel provides resizing of an input image to an output image."]
#[doc = " The scaling factor is determined but the relative sizes of the input and"]
#[doc = " output."]
#[doc = " \\see group_vision_function_scale_image"]
pub const vx_kernel_e_VX_KERNEL_SCALE_IMAGE: vx_kernel_e = 7;
#[doc = " \\brief The Table Lookup kernel"]
#[doc = " \\see group_vision_function_lut"]
pub const vx_kernel_e_VX_KERNEL_TABLE_LOOKUP: vx_kernel_e = 8;
#[doc = " \\brief The Histogram Kernel."]
#[doc = " \\see group_vision_function_histogram"]
pub const vx_kernel_e_VX_KERNEL_HISTOGRAM: vx_kernel_e = 9;
#[doc = " \\brief The Histogram Equalization Kernel."]
#[doc = " \\see group_vision_function_equalize_hist"]
pub const vx_kernel_e_VX_KERNEL_EQUALIZE_HISTOGRAM: vx_kernel_e = 10;
#[doc = " \\brief The Absolute Difference Kernel."]
#[doc = " \\see group_vision_function_absdiff"]
pub const vx_kernel_e_VX_KERNEL_ABSDIFF: vx_kernel_e = 11;
#[doc = " \\brief The Mean and Standard Deviation Kernel."]
#[doc = " \\see group_vision_function_meanstddev"]
pub const vx_kernel_e_VX_KERNEL_MEAN_STDDEV: vx_kernel_e = 12;
#[doc = " \\brief The Threshold Kernel."]
#[doc = " \\see group_vision_function_threshold"]
pub const vx_kernel_e_VX_KERNEL_THRESHOLD: vx_kernel_e = 13;
#[doc = " \\brief The Integral Image Kernel."]
#[doc = " \\see group_vision_function_integral_image"]
pub const vx_kernel_e_VX_KERNEL_INTEGRAL_IMAGE: vx_kernel_e = 14;
#[doc = " \\brief The dilate kernel."]
#[doc = " \\see group_vision_function_dilate_image"]
pub const vx_kernel_e_VX_KERNEL_DILATE_3x3: vx_kernel_e = 15;
#[doc = " \\brief The erode kernel."]
#[doc = " \\see group_vision_function_erode_image"]
pub const vx_kernel_e_VX_KERNEL_ERODE_3x3: vx_kernel_e = 16;
#[doc = " \\brief The median image filter."]
#[doc = " \\see group_vision_function_median_image"]
pub const vx_kernel_e_VX_KERNEL_MEDIAN_3x3: vx_kernel_e = 17;
#[doc = " \\brief The box filter kernel."]
#[doc = " \\see group_vision_function_box_image"]
pub const vx_kernel_e_VX_KERNEL_BOX_3x3: vx_kernel_e = 18;
#[doc = " \\brief The gaussian filter kernel."]
#[doc = " \\see group_vision_function_gaussian_image"]
pub const vx_kernel_e_VX_KERNEL_GAUSSIAN_3x3: vx_kernel_e = 19;
#[doc = " \\brief The custom convolution kernel."]
#[doc = " \\see group_vision_function_custom_convolution"]
pub const vx_kernel_e_VX_KERNEL_CUSTOM_CONVOLUTION: vx_kernel_e = 20;
#[doc = " \\brief The gaussian image pyramid kernel."]
#[doc = " \\see group_vision_function_gaussian_pyramid"]
pub const vx_kernel_e_VX_KERNEL_GAUSSIAN_PYRAMID: vx_kernel_e = 21;
#[doc = " \\brief The min and max location kernel."]
#[doc = " \\see group_vision_function_minmaxloc"]
pub const vx_kernel_e_VX_KERNEL_MINMAXLOC: vx_kernel_e = 25;
#[doc = " \\brief The bit-depth conversion kernel."]
#[doc = " \\see group_vision_function_convertdepth"]
pub const vx_kernel_e_VX_KERNEL_CONVERTDEPTH: vx_kernel_e = 26;
#[doc = " \\brief The Canny Edge Detector."]
#[doc = " \\see group_vision_function_canny"]
pub const vx_kernel_e_VX_KERNEL_CANNY_EDGE_DETECTOR: vx_kernel_e = 27;
#[doc = " \\brief The Bitwise And Kernel."]
#[doc = " \\see group_vision_function_and"]
pub const vx_kernel_e_VX_KERNEL_AND: vx_kernel_e = 28;
#[doc = " \\brief The Bitwise Inclusive Or Kernel."]
#[doc = " \\see group_vision_function_or"]
pub const vx_kernel_e_VX_KERNEL_OR: vx_kernel_e = 29;
#[doc = " \\brief The Bitwise Exclusive Or Kernel."]
#[doc = " \\see group_vision_function_xor"]
pub const vx_kernel_e_VX_KERNEL_XOR: vx_kernel_e = 30;
#[doc = " \\brief The Bitwise Not Kernel."]
#[doc = " \\see group_vision_function_not"]
pub const vx_kernel_e_VX_KERNEL_NOT: vx_kernel_e = 31;
#[doc = " \\brief The Pixelwise Multiplication Kernel."]
#[doc = " \\see group_vision_function_mult"]
pub const vx_kernel_e_VX_KERNEL_MULTIPLY: vx_kernel_e = 32;
#[doc = " \\brief The Addition Kernel."]
#[doc = " \\see group_vision_function_add"]
pub const vx_kernel_e_VX_KERNEL_ADD: vx_kernel_e = 33;
#[doc = " \\brief The Subtraction Kernel."]
#[doc = " \\see group_vision_function_sub"]
pub const vx_kernel_e_VX_KERNEL_SUBTRACT: vx_kernel_e = 34;
#[doc = " \\brief The Warp Affine Kernel."]
#[doc = " \\see group_vision_function_warp_affine"]
pub const vx_kernel_e_VX_KERNEL_WARP_AFFINE: vx_kernel_e = 35;
#[doc = " \\brief The Warp Perspective Kernel."]
#[doc = " \\see group_vision_function_warp_perspective"]
pub const vx_kernel_e_VX_KERNEL_WARP_PERSPECTIVE: vx_kernel_e = 36;
#[doc = " \\brief The Harris Corners Kernel."]
#[doc = " \\see group_vision_function_harris"]
pub const vx_kernel_e_VX_KERNEL_HARRIS_CORNERS: vx_kernel_e = 37;
#[doc = " \\brief The FAST Corners Kernel."]
#[doc = " \\see group_vision_function_fast"]
pub const vx_kernel_e_VX_KERNEL_FAST_CORNERS: vx_kernel_e = 38;
#[doc = " \\brief The Optical Flow Pyramid (LK) Kernel."]
#[doc = " \\see group_vision_function_opticalflowpyrlk"]
pub const vx_kernel_e_VX_KERNEL_OPTICAL_FLOW_PYR_LK: vx_kernel_e = 39;
#[doc = " \\brief The Remap Kernel."]
#[doc = " \\see group_vision_function_remap"]
pub const vx_kernel_e_VX_KERNEL_REMAP: vx_kernel_e = 40;
#[doc = " \\brief The Half Scale Gaussian Kernel."]
#[doc = " \\see group_vision_function_scale_image"]
pub const vx_kernel_e_VX_KERNEL_HALFSCALE_GAUSSIAN: vx_kernel_e = 41;
#[doc = "< \\internal Used for VX1.0 bounds checking in the conformance test."]
pub const vx_kernel_e_VX_KERNEL_MAX_1_0: vx_kernel_e = 42;
#[doc = " \\brief The Laplacian Image Pyramid Kernel."]
#[doc = " \\see group_vision_function_laplacian_pyramid"]
pub const vx_kernel_e_VX_KERNEL_LAPLACIAN_PYRAMID: vx_kernel_e = 42;
#[doc = " \\brief The Laplacian Pyramid Reconstruct Kernel."]
#[doc = " \\see group_vision_function_laplacian_pyramid"]
pub const vx_kernel_e_VX_KERNEL_LAPLACIAN_RECONSTRUCT: vx_kernel_e = 43;
#[doc = " \\brief The Non Linear Filter Kernel."]
#[doc = " \\see group_vision_function_nonlinear_filter"]
pub const vx_kernel_e_VX_KERNEL_NON_LINEAR_FILTER: vx_kernel_e = 44;
#[doc = "< \\internal Used for VX1.1 bounds checking in the conformance test."]
pub const vx_kernel_e_VX_KERNEL_MAX_1_1: vx_kernel_e = 45;
#[doc = " \\brief The Match Template Kernel."]
#[doc = " \\see group_vision_match_template"]
pub const vx_kernel_e_VX_KERNEL_MATCH_TEMPLATE: vx_kernel_e = 45;
#[doc = " \\brief The LBP Kernel."]
#[doc = " \\see group_lbp"]
pub const vx_kernel_e_VX_KERNEL_LBP: vx_kernel_e = 46;
#[doc = " \\brief The hough lines probability Kernel."]
#[doc = " \\see group_vision_hough_lines_p"]
pub const vx_kernel_e_VX_KERNEL_HOUGH_LINES_P: vx_kernel_e = 47;
#[doc = " \\brief The tensor multiply Kernel."]
#[doc = " \\see group_vision_function_tensor_multiply"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_MULTIPLY: vx_kernel_e = 48;
#[doc = " \\brief The tensor add Kernel."]
#[doc = " \\see group_vision_function_tensor_add"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_ADD: vx_kernel_e = 49;
#[doc = " \\brief The tensor subtract Kernel."]
#[doc = " \\see group_vision_function_tensor_subtract"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_SUBTRACT: vx_kernel_e = 50;
#[doc = " \\brief The tensor table look up Kernel."]
#[doc = " \\see group_vision_function_tensor_tablelookup"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_TABLE_LOOKUP: vx_kernel_e = 51;
#[doc = " \\brief The tensor transpose Kernel."]
#[doc = " \\see group_vision_function_tensor_transpose"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_TRANSPOSE: vx_kernel_e = 52;
#[doc = " \\brief The tensor convert depth Kernel."]
#[doc = " \\see group_vision_function_tensor_convert_depth"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_CONVERT_DEPTH: vx_kernel_e = 53;
#[doc = " \\brief The tensor matrix multiply Kernel."]
#[doc = " \\see group_vision_function_tensor_matrix_multiply"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_MATRIX_MULTIPLY: vx_kernel_e = 54;
#[doc = " \\brief The data object copy kernel."]
#[doc = " \\see group_vision_function_copy"]
pub const vx_kernel_e_VX_KERNEL_COPY: vx_kernel_e = 55;
#[doc = " \\brief The non-max suppression kernel."]
#[doc = " \\see group_vision_function_nms"]
pub const vx_kernel_e_VX_KERNEL_NON_MAX_SUPPRESSION: vx_kernel_e = 56;
#[doc = " \\brief The scalar operation kernel."]
#[doc = " \\see group_control_flow"]
pub const vx_kernel_e_VX_KERNEL_SCALAR_OPERATION: vx_kernel_e = 57;
#[doc = " \\brief The  HOG features kernel."]
#[doc = " \\see group_vision_function_hog"]
pub const vx_kernel_e_VX_KERNEL_HOG_FEATURES: vx_kernel_e = 58;
#[doc = " \\brief The HOG Cells kernel."]
#[doc = " \\see group_vision_function_hog"]
pub const vx_kernel_e_VX_KERNEL_HOG_CELLS: vx_kernel_e = 59;
#[doc = " \\brief The bilateral filter kernel."]
#[doc = " \\see group_vision_function_bilateral_filter"]
pub const vx_kernel_e_VX_KERNEL_BILATERAL_FILTER: vx_kernel_e = 60;
#[doc = " \\brief The select kernel."]
#[doc = " \\see group_control_flow"]
pub const vx_kernel_e_VX_KERNEL_SELECT: vx_kernel_e = 61;
#[doc = "< \\internal Used for VX1.2 bounds checking in the conformance test."]
pub const vx_kernel_e_VX_KERNEL_MAX_1_2: vx_kernel_e = 62;
#[doc = " \\brief The max kernel."]
#[doc = " \\see group_vision_function_max"]
pub const vx_kernel_e_VX_KERNEL_MAX: vx_kernel_e = 62;
#[doc = " \\brief The min kernel."]
#[doc = " \\see group_vision_function_min"]
pub const vx_kernel_e_VX_KERNEL_MIN: vx_kernel_e = 63;
#[doc = " \\brief The weigthed average kernel."]
#[doc = " \\see group_vision_function_weighted_average"]
pub const vx_kernel_e_VX_KERNEL_WEIGHTED_AVERAGE: vx_kernel_e = 64;
#[doc = " \\brief The standard list of available vision kernels."]
#[doc = ""]
#[doc = " Each kernel listed here can be used with the <tt>\\ref vxGetKernelByEnum</tt> call."]
#[doc = " When programming the parameters, use"]
#[doc = " \\arg <tt>\\ref VX_INPUT</tt> for [in]"]
#[doc = " \\arg <tt>\\ref VX_OUTPUT</tt> for [out]"]
#[doc = ""]
#[doc = " When programming the parameters, use"]
#[doc = " \\arg <tt>\\ref VX_TYPE_IMAGE</tt> for a <tt>\\ref vx_image</tt> in the size field of <tt>\\ref vxGetParameterByIndex</tt> or <tt>\\ref vxSetParameterByIndex</tt>  * \\arg <tt>\\ref VX_TYPE_ARRAY</tt> for a <tt>\\ref vx_array</tt> in the size field of <tt>\\ref vxGetParameterByIndex</tt> or <tt>\\ref vxSetParameterByIndex</tt>  * \\arg or other appropriate types in \\ref vx_type_e."]
#[doc = " \\ingroup group_kernel"]
pub type vx_kernel_e = ::std::os::raw::c_uint;
