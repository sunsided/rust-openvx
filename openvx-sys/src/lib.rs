/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

pub const VX_MAX_IMPLEMENTATION_NAME: u32 = 64;
pub const VX_MAX_KERNEL_NAME: u32 = 256;
pub const VX_MAX_LOG_MESSAGE_LEN: u32 = 1024;
pub const VX_MAX_REFERENCE_NAME: u32 = 64;
pub const VX_VENDOR_MASK: u32 = 4293918720;
pub const VX_TYPE_MASK: u32 = 1048320;
pub const VX_LIBRARY_MASK: u32 = 1044480;
pub const VX_KERNEL_MASK: u32 = 4095;
pub const VX_ATTRIBUTE_ID_MASK: u32 = 255;
pub const VX_ENUM_TYPE_MASK: u32 = 1044480;
pub const VX_ENUM_MASK: u32 = 4095;
pub const VX_FMT_REF: &[u8; 3] = b"%p\0";
pub const VX_FMT_SIZE: &[u8; 4] = b"%zu\0";
pub const VX_SCALE_UNITY: u32 = 1024;
pub const VX_SCALE_PYRAMID_HALF: f64 = 0.5;
pub const VX_ENUM_IX_USE: u32 = 24;
pub const VX_TYPE_IMPORT: u32 = 2068;
pub const VX_LIBRARY_KHR_CLASS_EXTENSION: u32 = 2;
pub const VX_LIBRARY_KHR_PIPELINING_EXTENSION: u32 = 1;
pub const VX_IMAGE_RAW_MAX_EXPOSURES: u32 = 3;
pub const VX_KERNEL_SWAP_NAME: &[u8; 24] = b"org.khronos.openvx.swap\0";
pub const VX_KERNEL_MOVE_NAME: &[u8; 24] = b"org.khronos.openvx.move\0";
pub const VX_MAX_TILING_PLANES: u32 = 4;
pub const VX_TYPE_USER_DATA_OBJECT: u32 = 2070;
#[doc = "< \\brief The Khronos Group"]
pub const vx_vendor_id_e_VX_ID_KHRONOS: vx_vendor_id_e = 0;
#[doc = "< \\brief Texas Instruments, Inc."]
pub const vx_vendor_id_e_VX_ID_TI: vx_vendor_id_e = 1;
#[doc = "< \\brief Qualcomm, Inc."]
pub const vx_vendor_id_e_VX_ID_QUALCOMM: vx_vendor_id_e = 2;
#[doc = "< \\brief NVIDIA Corporation"]
pub const vx_vendor_id_e_VX_ID_NVIDIA: vx_vendor_id_e = 3;
#[doc = "< \\brief ARM Ltd."]
pub const vx_vendor_id_e_VX_ID_ARM: vx_vendor_id_e = 4;
#[doc = "< \\brief Berkley Design Technology, Inc."]
pub const vx_vendor_id_e_VX_ID_BDTI: vx_vendor_id_e = 5;
#[doc = "< \\brief Renasas Electronics"]
pub const vx_vendor_id_e_VX_ID_RENESAS: vx_vendor_id_e = 6;
#[doc = "< \\brief Vivante Corporation"]
pub const vx_vendor_id_e_VX_ID_VIVANTE: vx_vendor_id_e = 7;
#[doc = "< \\brief Xilinx Inc."]
pub const vx_vendor_id_e_VX_ID_XILINX: vx_vendor_id_e = 8;
#[doc = "< \\brief Axis Communications"]
pub const vx_vendor_id_e_VX_ID_AXIS: vx_vendor_id_e = 9;
#[doc = "< \\brief Movidius Ltd."]
pub const vx_vendor_id_e_VX_ID_MOVIDIUS: vx_vendor_id_e = 10;
#[doc = "< \\brief Samsung Electronics"]
pub const vx_vendor_id_e_VX_ID_SAMSUNG: vx_vendor_id_e = 11;
#[doc = "< \\brief Freescale Semiconductor"]
pub const vx_vendor_id_e_VX_ID_FREESCALE: vx_vendor_id_e = 12;
#[doc = "< \\brief Advanced Micro Devices"]
pub const vx_vendor_id_e_VX_ID_AMD: vx_vendor_id_e = 13;
#[doc = "< \\brief Broadcom Corporation"]
pub const vx_vendor_id_e_VX_ID_BROADCOM: vx_vendor_id_e = 14;
#[doc = "< \\brief Intel Corporation"]
pub const vx_vendor_id_e_VX_ID_INTEL: vx_vendor_id_e = 15;
#[doc = "< \\brief Marvell Technology Group Ltd."]
pub const vx_vendor_id_e_VX_ID_MARVELL: vx_vendor_id_e = 16;
#[doc = "< \\brief MediaTek, Inc."]
pub const vx_vendor_id_e_VX_ID_MEDIATEK: vx_vendor_id_e = 17;
#[doc = "< \\brief STMicroelectronics"]
pub const vx_vendor_id_e_VX_ID_ST: vx_vendor_id_e = 18;
#[doc = "< \\brief CEVA DSP"]
pub const vx_vendor_id_e_VX_ID_CEVA: vx_vendor_id_e = 19;
#[doc = "< \\brief Itseez, Inc."]
pub const vx_vendor_id_e_VX_ID_ITSEEZ: vx_vendor_id_e = 20;
#[doc = "< \\brief Imagination Technologies"]
pub const vx_vendor_id_e_VX_ID_IMAGINATION: vx_vendor_id_e = 21;
#[doc = "< \\brief NXP Semiconductors"]
pub const vx_vendor_id_e_VX_ID_NXP: vx_vendor_id_e = 22;
#[doc = "< \\brief Videantis"]
pub const vx_vendor_id_e_VX_ID_VIDEANTIS: vx_vendor_id_e = 23;
#[doc = "< \\brief Synopsys"]
pub const vx_vendor_id_e_VX_ID_SYNOPSYS: vx_vendor_id_e = 24;
#[doc = "< \\brief Cadence"]
pub const vx_vendor_id_e_VX_ID_CADENCE: vx_vendor_id_e = 25;
#[doc = "< \\brief Huawei"]
pub const vx_vendor_id_e_VX_ID_HUAWEI: vx_vendor_id_e = 26;
#[doc = "< \\brief Socionext"]
pub const vx_vendor_id_e_VX_ID_SOCIONEXT: vx_vendor_id_e = 27;
#[doc = "< \\brief Robert Bosch GmbH"]
pub const vx_vendor_id_e_VX_ID_BOSCH: vx_vendor_id_e = 28;
#[doc = "< \\brief For use by vxAllocateUserKernelId and vxAllocateUserKernelLibraryId"]
pub const vx_vendor_id_e_VX_ID_USER: vx_vendor_id_e = 4094;
pub const vx_vendor_id_e_VX_ID_MAX: vx_vendor_id_e = 4095;
#[doc = " \\brief For use by all Kernel authors until they can obtain an assigned ID."]
pub const vx_vendor_id_e_VX_ID_DEFAULT: vx_vendor_id_e = 4095;
#[doc = " \\brief The Vendor ID of the Implementation. As new vendors submit their\n implementations, this enumeration will grow.\n \\ingroup group_basic_features"]
pub type vx_vendor_id_e = ::std::os::raw::c_uint;
#[doc = " \\brief An 8 bit ASCII character.\n \\ingroup group_basic_features"]
pub type vx_char = ::std::os::raw::c_char;
#[doc = " \\brief An 8-bit unsigned value.\n \\ingroup group_basic_features"]
pub type vx_uint8 = u8;
#[doc = " \\brief A 16-bit unsigned value.\n \\ingroup group_basic_features"]
pub type vx_uint16 = u16;
#[doc = " \\brief A 32-bit unsigned value.\n \\ingroup group_basic_features"]
pub type vx_uint32 = u32;
#[doc = " \\brief A 64-bit unsigned value.\n \\ingroup group_basic_features"]
pub type vx_uint64 = u64;
#[doc = " \\brief An 8-bit signed value.\n \\ingroup group_basic_features"]
pub type vx_int8 = i8;
#[doc = " \\brief A 16-bit signed value.\n \\ingroup group_basic_features"]
pub type vx_int16 = i16;
#[doc = " \\brief A 32-bit signed value.\n \\ingroup group_basic_features"]
pub type vx_int32 = i32;
#[doc = " \\brief A 64-bit signed value.\n \\ingroup group_basic_features"]
pub type vx_int64 = i64;
pub type vx_bitfield = u32;
#[doc = " \\brief A 32-bit float value.\n \\ingroup group_basic_features"]
pub type vx_float32 = f32;
#[doc = " \\brief A 64-bit float value (aka double).\n \\ingroup group_basic_features"]
pub type vx_float64 = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_reference {
    _unused: [u8; 0],
}
#[doc = " \\brief A generic opaque reference to any object within OpenVX.\n \\details A user of OpenVX should not assume that this can be cast directly to anything;\n however, any object in OpenVX can be cast back to this for the purposes of\n querying attributes of the object or for passing the object as a parameter to\n functions that take a <tt>\\ref vx_reference</tt> type.\n If the API does not take that specific type but may take others, an\n error may be returned from the API.\n \\ingroup group_reference"]
pub type vx_reference = *mut _vx_reference;
#[doc = " \\brief Sets the standard enumeration type size to be a fixed quantity.\n \\details All enumerable fields must use this type as the container to\n enforce enumeration ranges and sizeof() operations.\n \\ingroup group_basic_features"]
pub type vx_enum = i32;
#[doc = " \\brief A wrapper of <tt>size_t</tt> to keep the naming convention uniform.\n \\ingroup group_basic_features"]
pub type vx_size = usize;
#[doc = " \\brief Used to hold a VX_DF_IMAGE code to describe the pixel format and color space.\n \\ingroup group_basic_features"]
pub type vx_df_image = u32;
#[doc = " \\brief Holds the address of a variable where the map/unmap functions return a map identifier.\n \\ingroup group_image"]
pub type vx_map_id = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_scalar {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a scalar.\n \\details A scalar can be up to 64 bits wide.\n \\see vxCreateScalar\n \\ingroup group_scalar\n \\extends vx_reference"]
pub type vx_scalar = *mut _vx_scalar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_image {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to an image.\n \\see vxCreateImage\n \\ingroup group_image\n \\extends vx_reference"]
pub type vx_image = *mut _vx_image;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_kernel {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to the descriptor of a kernel.\n \\see vxGetKernelByName\n \\see vxGetKernelByEnum\n \\ingroup group_kernel\n \\extends vx_reference"]
pub type vx_kernel = *mut _vx_kernel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_parameter {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a single parameter.\n \\see vxGetParameterByIndex\n \\ingroup group_parameter\n \\extends vx_reference"]
pub type vx_parameter = *mut _vx_parameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_node {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a kernel node.\n \\see vxCreateGenericNode\n \\ingroup group_node\n \\extends vx_reference"]
pub type vx_node = *mut _vx_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_graph {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to a graph\n \\see vxCreateGraph\n \\ingroup group_graph\n \\extends vx_reference"]
pub type vx_graph = *mut _vx_graph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_context {
    _unused: [u8; 0],
}
#[doc = " \\brief An opaque reference to the implementation context.\n \\see vxCreateContext\n \\ingroup group_context\n \\extends vx_reference"]
pub type vx_context = *mut _vx_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_delay {
    _unused: [u8; 0],
}
#[doc = " \\brief The delay object. This is like a ring buffer of objects that is\n maintained by the OpenVX implementation.\n \\see vxCreateDelay\n \\extends vx_reference\n \\ingroup group_delay"]
pub type vx_delay = *mut _vx_delay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_lut {
    _unused: [u8; 0],
}
#[doc = " \\brief The Look-Up Table (LUT) Object.\n \\extends vx_reference\n \\ingroup group_lut"]
pub type vx_lut = *mut _vx_lut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_distribution {
    _unused: [u8; 0],
}
#[doc = " \\brief The Distribution object. This has a user-defined number of bins over\n a user-defined range (within a uint32_t range).\n \\extends vx_reference\n \\ingroup group_distribution"]
pub type vx_distribution = *mut _vx_distribution;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_matrix {
    _unused: [u8; 0],
}
#[doc = " \\brief The Matrix Object. An MxN matrix of some unit type.\n \\extends vx_reference\n \\ingroup group_matrix"]
pub type vx_matrix = *mut _vx_matrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_pyramid {
    _unused: [u8; 0],
}
#[doc = " \\brief The Image Pyramid object. A set of scaled images.\n \\extends vx_reference\n \\ingroup group_pyramid"]
pub type vx_pyramid = *mut _vx_pyramid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_threshold {
    _unused: [u8; 0],
}
#[doc = " \\brief The Threshold Object. A thresholding object contains the types and\n limit values of the thresholding required.\n \\extends vx_reference\n \\ingroup group_threshold"]
pub type vx_threshold = *mut _vx_threshold;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_convolution {
    _unused: [u8; 0],
}
#[doc = " \\brief The Convolution Object. A user-defined convolution kernel of MxM elements.\n \\extends vx_reference\n \\ingroup group_convolution"]
pub type vx_convolution = *mut _vx_convolution;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_remap {
    _unused: [u8; 0],
}
#[doc = " \\brief The remap table Object. A remap table contains per-pixel mapping of\n output pixels to input pixels.\n \\ingroup group_remap"]
pub type vx_remap = *mut _vx_remap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_array {
    _unused: [u8; 0],
}
#[doc = " \\brief The Array Object. Array is a strongly-typed container for other data structures.\n \\ingroup group_array"]
pub type vx_array = *mut _vx_array;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_object_array {
    _unused: [u8; 0],
}
#[doc = " \\brief The ObjectArray Object. ObjectArray is a strongly-typed container of OpenVX data-objects.\n \\ingroup group_object_array"]
pub type vx_object_array = *mut _vx_object_array;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_tensor_t {
    _unused: [u8; 0],
}
#[doc = " \\brief The multidimensional data object (Tensor).\n \\see vxCreateTensor\n \\ingroup group_object_tensor\n \\extends vx_reference"]
pub type vx_tensor = *mut _vx_tensor_t;
#[doc = " \\brief The \"false\" value."]
pub const vx_bool_e_vx_false_e: vx_bool_e = 0;
#[doc = " \\brief The \"true\" value."]
pub const vx_bool_e_vx_true_e: vx_bool_e = 1;
#[doc = " \\brief A Boolean value.\n This allows 0 to be FALSE, as it is in C, and any non-zero to be TRUE.\n \\code\n vx_bool ret = vx_true_e;\n if (ret) printf(\"true!\\n\");\n ret = vx_false_e;\n if (!ret) printf(\"false!\\n\");\n \\endcode\n This would print both strings.\n \\see vx_bool\n \\ingroup group_basic_features"]
pub type vx_bool_e = ::std::os::raw::c_uint;
#[doc = " \\brief A formal boolean type with known fixed size.\n \\see vx_bool_e\n \\ingroup group_basic_features"]
pub type vx_bool = vx_enum;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_meta_format {
    _unused: [u8; 0],
}
#[doc = " \\brief This object is used by output validation functions to specify the meta data\n of the expected output data object.\n \\note When the actual output object of the user node is virtual, the information\n given through the vx_meta_format object allows the OpenVX framework to automatically\n create the data object when meta data were not specified by the application at object\n creation time.\n \\ingroup group_user_kernels"]
pub type vx_meta_format = *mut _vx_meta_format;
#[doc = "< \\brief An invalid type value. When passed an error must be returned."]
pub const vx_type_e_VX_TYPE_INVALID: vx_type_e = 0;
#[doc = "< \\brief A <tt>\\ref vx_char</tt>."]
pub const vx_type_e_VX_TYPE_CHAR: vx_type_e = 1;
#[doc = "< \\brief A <tt>\\ref vx_int8</tt>."]
pub const vx_type_e_VX_TYPE_INT8: vx_type_e = 2;
#[doc = "< \\brief A <tt>\\ref vx_uint8</tt>."]
pub const vx_type_e_VX_TYPE_UINT8: vx_type_e = 3;
#[doc = "< \\brief A <tt>\\ref vx_int16</tt>."]
pub const vx_type_e_VX_TYPE_INT16: vx_type_e = 4;
#[doc = "< \\brief A <tt>\\ref vx_uint16</tt>."]
pub const vx_type_e_VX_TYPE_UINT16: vx_type_e = 5;
#[doc = "< \\brief A <tt>\\ref vx_int32</tt>."]
pub const vx_type_e_VX_TYPE_INT32: vx_type_e = 6;
#[doc = "< \\brief A <tt>\\ref vx_uint32</tt>."]
pub const vx_type_e_VX_TYPE_UINT32: vx_type_e = 7;
#[doc = "< \\brief A <tt>\\ref vx_int64</tt>."]
pub const vx_type_e_VX_TYPE_INT64: vx_type_e = 8;
#[doc = "< \\brief A <tt>\\ref vx_uint64</tt>."]
pub const vx_type_e_VX_TYPE_UINT64: vx_type_e = 9;
#[doc = "< \\brief A <tt>\\ref vx_float32</tt>."]
pub const vx_type_e_VX_TYPE_FLOAT32: vx_type_e = 10;
#[doc = "< \\brief A <tt>\\ref vx_float64</tt>."]
pub const vx_type_e_VX_TYPE_FLOAT64: vx_type_e = 11;
#[doc = "< \\brief A <tt>\\ref vx_enum</tt>. Equivalent in size to a <tt>\\ref vx_int32</tt>."]
pub const vx_type_e_VX_TYPE_ENUM: vx_type_e = 12;
#[doc = "< \\brief A <tt>\\ref vx_size</tt>."]
pub const vx_type_e_VX_TYPE_SIZE: vx_type_e = 13;
#[doc = "< \\brief A <tt>\\ref vx_df_image</tt>."]
pub const vx_type_e_VX_TYPE_DF_IMAGE: vx_type_e = 14;
#[doc = "< \\brief A <tt>\\ref vx_float16</tt>."]
pub const vx_type_e_VX_TYPE_FLOAT16: vx_type_e = 15;
#[doc = "< \\brief A <tt>\\ref vx_bool</tt>."]
pub const vx_type_e_VX_TYPE_BOOL: vx_type_e = 16;
#[doc = "< \\brief A <tt>\\ref vx_rectangle_t</tt>."]
pub const vx_type_e_VX_TYPE_RECTANGLE: vx_type_e = 32;
#[doc = "< \\brief A <tt>\\ref vx_keypoint_t</tt>."]
pub const vx_type_e_VX_TYPE_KEYPOINT: vx_type_e = 33;
#[doc = "< \\brief A <tt>\\ref vx_coordinates2d_t</tt>."]
pub const vx_type_e_VX_TYPE_COORDINATES2D: vx_type_e = 34;
#[doc = "< \\brief A <tt>\\ref vx_coordinates3d_t</tt>."]
pub const vx_type_e_VX_TYPE_COORDINATES3D: vx_type_e = 35;
#[doc = "< \\brief A <tt>\\ref vx_coordinates2df_t</tt>."]
pub const vx_type_e_VX_TYPE_COORDINATES2DF: vx_type_e = 36;
#[doc = "< \\brief A <tt>\\ref vx_hog_t</tt>."]
pub const vx_type_e_VX_TYPE_HOG_PARAMS: vx_type_e = 40;
#[doc = "< \\brief A <tt>\\ref vx_hough_lines_p_t</tt>."]
pub const vx_type_e_VX_TYPE_HOUGH_LINES_PARAMS: vx_type_e = 41;
#[doc = "< \\brief A <tt>\\ref vx_line2d_t</tt>."]
pub const vx_type_e_VX_TYPE_LINE_2D: vx_type_e = 42;
#[doc = "< \\brief A <tt>\\ref vx_tensor_matrix_multiply_params_t</tt>."]
pub const vx_type_e_VX_TYPE_TENSOR_MATRIX_MULTIPLY_PARAMS: vx_type_e = 43;
#[doc = "< \\brief A user-defined struct base index."]
pub const vx_type_e_VX_TYPE_USER_STRUCT_START: vx_type_e = 256;
#[doc = "< \\brief A vendor-defined struct base index."]
pub const vx_type_e_VX_TYPE_VENDOR_STRUCT_START: vx_type_e = 1024;
#[doc = "< \\brief A Khronos defined object base index."]
pub const vx_type_e_VX_TYPE_KHRONOS_OBJECT_START: vx_type_e = 2048;
#[doc = "< \\brief A vendor defined object base index."]
pub const vx_type_e_VX_TYPE_VENDOR_OBJECT_START: vx_type_e = 3072;
#[doc = "< \\brief A value for comparison between Khronos defined structs and user structs."]
pub const vx_type_e_VX_TYPE_KHRONOS_STRUCT_MAX: vx_type_e = 255;
#[doc = "< \\brief A value for comparison between user structs and vendor structs."]
pub const vx_type_e_VX_TYPE_USER_STRUCT_END: vx_type_e = 1023;
#[doc = "< \\brief A value for comparison between vendor structs and Khronos defined objects."]
pub const vx_type_e_VX_TYPE_VENDOR_STRUCT_END: vx_type_e = 2047;
#[doc = "< \\brief A value for comparison between Khronos defined objects and vendor structs."]
pub const vx_type_e_VX_TYPE_KHRONOS_OBJECT_END: vx_type_e = 3071;
#[doc = "< \\brief A value used for bound checking of vendor objects"]
pub const vx_type_e_VX_TYPE_VENDOR_OBJECT_END: vx_type_e = 4095;
#[doc = "< \\brief A <tt>\\ref vx_reference</tt>."]
pub const vx_type_e_VX_TYPE_REFERENCE: vx_type_e = 2048;
#[doc = "< \\brief A <tt>\\ref vx_context</tt>."]
pub const vx_type_e_VX_TYPE_CONTEXT: vx_type_e = 2049;
#[doc = "< \\brief A <tt>\\ref vx_graph</tt>."]
pub const vx_type_e_VX_TYPE_GRAPH: vx_type_e = 2050;
#[doc = "< \\brief A <tt>\\ref vx_node</tt>."]
pub const vx_type_e_VX_TYPE_NODE: vx_type_e = 2051;
#[doc = "< \\brief A <tt>\\ref vx_kernel</tt>."]
pub const vx_type_e_VX_TYPE_KERNEL: vx_type_e = 2052;
#[doc = "< \\brief A <tt>\\ref vx_parameter</tt>."]
pub const vx_type_e_VX_TYPE_PARAMETER: vx_type_e = 2053;
#[doc = "< \\brief A <tt>\\ref vx_delay</tt>."]
pub const vx_type_e_VX_TYPE_DELAY: vx_type_e = 2054;
#[doc = "< \\brief A <tt>\\ref vx_lut</tt>."]
pub const vx_type_e_VX_TYPE_LUT: vx_type_e = 2055;
#[doc = "< \\brief A <tt>\\ref vx_distribution</tt>."]
pub const vx_type_e_VX_TYPE_DISTRIBUTION: vx_type_e = 2056;
#[doc = "< \\brief A <tt>\\ref vx_pyramid</tt>."]
pub const vx_type_e_VX_TYPE_PYRAMID: vx_type_e = 2057;
#[doc = "< \\brief A <tt>\\ref vx_threshold</tt>."]
pub const vx_type_e_VX_TYPE_THRESHOLD: vx_type_e = 2058;
#[doc = "< \\brief A <tt>\\ref vx_matrix</tt>."]
pub const vx_type_e_VX_TYPE_MATRIX: vx_type_e = 2059;
#[doc = "< \\brief A <tt>\\ref vx_convolution</tt>."]
pub const vx_type_e_VX_TYPE_CONVOLUTION: vx_type_e = 2060;
#[doc = "< \\brief A <tt>\\ref vx_scalar</tt>. when needed to be completely generic for kernel validation."]
pub const vx_type_e_VX_TYPE_SCALAR: vx_type_e = 2061;
#[doc = "< \\brief A <tt>\\ref vx_array</tt>."]
pub const vx_type_e_VX_TYPE_ARRAY: vx_type_e = 2062;
#[doc = "< \\brief A <tt>\\ref vx_image</tt>."]
pub const vx_type_e_VX_TYPE_IMAGE: vx_type_e = 2063;
#[doc = "< \\brief A <tt>\\ref vx_remap</tt>."]
pub const vx_type_e_VX_TYPE_REMAP: vx_type_e = 2064;
#[doc = "< \\brief An error object which has no type."]
pub const vx_type_e_VX_TYPE_ERROR: vx_type_e = 2065;
#[doc = "< \\brief A <tt>\\ref vx_meta_format</tt>."]
pub const vx_type_e_VX_TYPE_META_FORMAT: vx_type_e = 2066;
#[doc = "< \\brief A <tt>\\ref vx_object_array</tt>."]
pub const vx_type_e_VX_TYPE_OBJECT_ARRAY: vx_type_e = 2067;
#[doc = "< \\brief A <tt>\\ref vx_tensor</tt>."]
pub const vx_type_e_VX_TYPE_TENSOR: vx_type_e = 2069;
#[doc = " \\brief The type enumeration lists all the known types in OpenVX.\n \\ingroup group_basic_features"]
pub type vx_type_e = ::std::os::raw::c_uint;
#[doc = "< \\brief Indicates the lower bound of status codes in VX. Used for bounds checks only."]
pub const vx_status_e_VX_STATUS_MIN: vx_status_e = -25;
#[doc = "< \\brief Indicates that an operation did not complete due to a reference count being non-zero."]
pub const vx_status_e_VX_ERROR_REFERENCE_NONZERO: vx_status_e = -24;
#[doc = "< \\brief Indicates that the graph has more than one node outputting to the same data object. This is an invalid graph structure."]
pub const vx_status_e_VX_ERROR_MULTIPLE_WRITERS: vx_status_e = -23;
#[doc = "< \\brief Indicates that the graph is stopped due to an error or a callback that abandoned execution."]
pub const vx_status_e_VX_ERROR_GRAPH_ABANDONED: vx_status_e = -22;
#[doc = "< \\brief Indicates that the supplied graph already has been scheduled and may be currently executing."]
pub const vx_status_e_VX_ERROR_GRAPH_SCHEDULED: vx_status_e = -21;
#[doc = "< \\brief Indicates that the supplied parameter is from another scope and cannot be used in the current scope."]
pub const vx_status_e_VX_ERROR_INVALID_SCOPE: vx_status_e = -20;
#[doc = "< \\brief Indicates that the supplied node could not be created."]
pub const vx_status_e_VX_ERROR_INVALID_NODE: vx_status_e = -19;
#[doc = "< \\brief Indicates that the supplied graph has invalid connections (cycles)."]
pub const vx_status_e_VX_ERROR_INVALID_GRAPH: vx_status_e = -18;
#[doc = "< \\brief Indicates that the supplied type parameter is incorrect."]
pub const vx_status_e_VX_ERROR_INVALID_TYPE: vx_status_e = -17;
#[doc = "< \\brief Indicates that the supplied parameter has an incorrect value."]
pub const vx_status_e_VX_ERROR_INVALID_VALUE: vx_status_e = -16;
#[doc = "< \\brief Indicates that the supplied parameter is too big or too small in dimension."]
pub const vx_status_e_VX_ERROR_INVALID_DIMENSION: vx_status_e = -15;
#[doc = "< \\brief Indicates that the supplied parameter is in an invalid format."]
pub const vx_status_e_VX_ERROR_INVALID_FORMAT: vx_status_e = -14;
#[doc = "< \\brief Indicates that the link is not possible as specified. The parameters are incompatible."]
pub const vx_status_e_VX_ERROR_INVALID_LINK: vx_status_e = -13;
#[doc = "< \\brief Indicates that the reference provided is not valid."]
pub const vx_status_e_VX_ERROR_INVALID_REFERENCE: vx_status_e = -12;
#[doc = "< \\brief This is returned from <tt>\\ref vxLoadKernels</tt> when the module does not contain the entry point."]
pub const vx_status_e_VX_ERROR_INVALID_MODULE: vx_status_e = -11;
#[doc = "< \\brief Indicates that the supplied parameter information does not match the kernel contract."]
pub const vx_status_e_VX_ERROR_INVALID_PARAMETERS: vx_status_e = -10;
#[doc = "< \\brief Indicates that the object refered to has been optimized out of existence."]
pub const vx_status_e_VX_ERROR_OPTIMIZED_AWAY: vx_status_e = -9;
#[doc = "< \\brief Indicates that an internal or implicit allocation failed. Typically catastrophic. After detection, deconstruct the context. \\see vxVerifyGraph."]
pub const vx_status_e_VX_ERROR_NO_MEMORY: vx_status_e = -8;
#[doc = "< \\brief Indicates that an internal or implicit resource can not be acquired (not memory). This is typically catastrophic. After detection, deconstruct the context. \\see vxVerifyGraph."]
pub const vx_status_e_VX_ERROR_NO_RESOURCES: vx_status_e = -7;
#[doc = "< \\brief Indicates that the attempt to link two parameters together failed due to type incompatibilty."]
pub const vx_status_e_VX_ERROR_NOT_COMPATIBLE: vx_status_e = -6;
#[doc = "< \\brief Indicates to the system that the parameter must be allocated by the system."]
pub const vx_status_e_VX_ERROR_NOT_ALLOCATED: vx_status_e = -5;
#[doc = "< \\brief Indicates that the given graph has failed verification due to an insufficient number of required parameters, which cannot be automatically created. Typically this indicates required atomic parameters. \\see vxVerifyGraph."]
pub const vx_status_e_VX_ERROR_NOT_SUFFICIENT: vx_status_e = -4;
#[doc = "< \\brief Indicates that the requested set of parameters produce a configuration that cannot be supported. Refer to the supplied documentation on the configured kernels. \\see vx_kernel_e. This is also returned if a function to set an attribute is called on a Read-only attribute."]
pub const vx_status_e_VX_ERROR_NOT_SUPPORTED: vx_status_e = -3;
#[doc = "< \\brief Indicates that the requested kernel is missing. \\see vx_kernel_e vxGetKernelByName."]
pub const vx_status_e_VX_ERROR_NOT_IMPLEMENTED: vx_status_e = -2;
#[doc = "< \\brief Indicates a generic error code, used when no other describes the error."]
pub const vx_status_e_VX_FAILURE: vx_status_e = -1;
#[doc = "< \\brief No error."]
pub const vx_status_e_VX_SUCCESS: vx_status_e = 0;
#[doc = " \\brief The enumeration of all status codes.\n \\see vx_status.\n \\ingroup group_basic_features"]
pub type vx_status_e = ::std::os::raw::c_int;
#[doc = " \\brief A formal status type with known fixed size.\n \\see vx_status_e\n \\ingroup group_basic_features"]
pub type vx_status = vx_enum;
#[doc = " \\brief The formal typedef of the response from the callback.\n \\see vx_action_e\n \\ingroup group_node_callback"]
pub type vx_action = vx_enum;
#[doc = " \\brief A callback to the client after a particular node has completed.\n \\see vx_action\n \\see vxAssignNodeCallback\n \\param [in] node The node to which the callback was attached.\n \\return An action code from <tt>\\ref vx_action_e</tt>.\n \\ingroup group_node_callback"]
pub type vx_nodecomplete_f =
    ::std::option::Option<unsafe extern "C" fn(node: vx_node) -> vx_action>;
#[doc = "< \\brief Parameter Direction."]
pub const vx_enum_e_VX_ENUM_DIRECTION: vx_enum_e = 0;
#[doc = "< \\brief Action Codes."]
pub const vx_enum_e_VX_ENUM_ACTION: vx_enum_e = 1;
#[doc = "< \\brief Hint Values."]
pub const vx_enum_e_VX_ENUM_HINT: vx_enum_e = 2;
#[doc = "< \\brief Directive Values."]
pub const vx_enum_e_VX_ENUM_DIRECTIVE: vx_enum_e = 3;
#[doc = "< \\brief Interpolation Types."]
pub const vx_enum_e_VX_ENUM_INTERPOLATION: vx_enum_e = 4;
#[doc = "< \\brief Overflow Policies."]
pub const vx_enum_e_VX_ENUM_OVERFLOW: vx_enum_e = 5;
#[doc = "< \\brief Color Space."]
pub const vx_enum_e_VX_ENUM_COLOR_SPACE: vx_enum_e = 6;
#[doc = "< \\brief Color Space Range."]
pub const vx_enum_e_VX_ENUM_COLOR_RANGE: vx_enum_e = 7;
#[doc = "< \\brief Parameter State."]
pub const vx_enum_e_VX_ENUM_PARAMETER_STATE: vx_enum_e = 8;
#[doc = "< \\brief Channel Name."]
pub const vx_enum_e_VX_ENUM_CHANNEL: vx_enum_e = 9;
#[doc = "< \\brief Convert Policy."]
pub const vx_enum_e_VX_ENUM_CONVERT_POLICY: vx_enum_e = 10;
#[doc = "< \\brief Threshold Type List."]
pub const vx_enum_e_VX_ENUM_THRESHOLD_TYPE: vx_enum_e = 11;
#[doc = "< \\brief Border Mode List."]
pub const vx_enum_e_VX_ENUM_BORDER: vx_enum_e = 12;
#[doc = "< \\brief Comparison Values."]
pub const vx_enum_e_VX_ENUM_COMPARISON: vx_enum_e = 13;
#[doc = "< \\brief The memory type enumeration."]
pub const vx_enum_e_VX_ENUM_MEMORY_TYPE: vx_enum_e = 14;
#[doc = "< \\brief A termination criteria."]
pub const vx_enum_e_VX_ENUM_TERM_CRITERIA: vx_enum_e = 15;
#[doc = "< \\brief A norm type."]
pub const vx_enum_e_VX_ENUM_NORM_TYPE: vx_enum_e = 16;
#[doc = "< \\brief An accessor flag type."]
pub const vx_enum_e_VX_ENUM_ACCESSOR: vx_enum_e = 17;
#[doc = "< \\brief Rounding Policy."]
pub const vx_enum_e_VX_ENUM_ROUND_POLICY: vx_enum_e = 18;
#[doc = "< \\brief Target."]
pub const vx_enum_e_VX_ENUM_TARGET: vx_enum_e = 19;
#[doc = "< \\brief Unsupported Border Mode Policy List."]
pub const vx_enum_e_VX_ENUM_BORDER_POLICY: vx_enum_e = 20;
#[doc = "< \\brief Graph attribute states."]
pub const vx_enum_e_VX_ENUM_GRAPH_STATE: vx_enum_e = 21;
#[doc = "< \\brief Non-linear function list."]
pub const vx_enum_e_VX_ENUM_NONLINEAR: vx_enum_e = 22;
#[doc = "< \\brief Matrix pattern enumeration."]
pub const vx_enum_e_VX_ENUM_PATTERN: vx_enum_e = 23;
#[doc = "< \\brief Lbp format."]
pub const vx_enum_e_VX_ENUM_LBP_FORMAT: vx_enum_e = 24;
#[doc = "< \\brief Compare metric."]
pub const vx_enum_e_VX_ENUM_COMP_METRIC: vx_enum_e = 25;
#[doc = "< \\brief Scalar operation list."]
pub const vx_enum_e_VX_ENUM_SCALAR_OPERATION: vx_enum_e = 32;
#[doc = " \\brief The set of supported enumerations in OpenVX.\n \\details These can be extracted from enumerated values using <tt>\\ref VX_ENUM_TYPE</tt>.\n \\ingroup group_basic_features"]
pub type vx_enum_e = ::std::os::raw::c_uint;
#[doc = " \\brief Continue executing the graph with no changes."]
pub const vx_action_e_VX_ACTION_CONTINUE: vx_action_e = 4096;
#[doc = " \\brief Stop executing the graph."]
pub const vx_action_e_VX_ACTION_ABANDON: vx_action_e = 4097;
#[doc = " \\brief A return code enumeration from a <tt>\\ref vx_nodecomplete_f</tt> during execution.\n \\see <tt>vxAssignNodeCallback</tt>\n \\ingroup group_node_callback"]
pub type vx_action_e = ::std::os::raw::c_uint;
#[doc = " \\brief The parameter is an input only."]
pub const vx_direction_e_VX_INPUT: vx_direction_e = 0;
#[doc = " \\brief The parameter is an output only."]
pub const vx_direction_e_VX_OUTPUT: vx_direction_e = 1;
#[doc = " \\brief An indication of how a kernel will treat the given parameter.\n \\ingroup group_parameter"]
pub type vx_direction_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates to the implementation that user do not apply any specific\n  requirements for performance."]
pub const vx_hint_e_VX_HINT_PERFORMANCE_DEFAULT: vx_hint_e = 8193;
#[doc = " \\brief Indicates the user preference is low power consumption versus\n highest performance."]
pub const vx_hint_e_VX_HINT_PERFORMANCE_LOW_POWER: vx_hint_e = 8194;
#[doc = " \\brief Indicates the user preference for highest performance over\n low power consumption."]
pub const vx_hint_e_VX_HINT_PERFORMANCE_HIGH_SPEED: vx_hint_e = 8195;
#[doc = " \\brief These enumerations are given to the <tt>\\ref vxHint</tt> API to enable/disable platform\n optimizations and/or features. Hints are optional and usually are vendor-specific.\n \\see <tt>\\ref vxHint</tt>\n \\ingroup group_hint"]
pub type vx_hint_e = ::std::os::raw::c_uint;
#[doc = " \\brief Disables recording information for graph debugging."]
pub const vx_directive_e_VX_DIRECTIVE_DISABLE_LOGGING: vx_directive_e = 12288;
#[doc = " \\brief Enables recording information for graph debugging."]
pub const vx_directive_e_VX_DIRECTIVE_ENABLE_LOGGING: vx_directive_e = 12289;
#[doc = " \\brief Disables performance counters for the context. By default performance counters are disabled"]
pub const vx_directive_e_VX_DIRECTIVE_DISABLE_PERFORMANCE: vx_directive_e = 12290;
#[doc = " \\brief Enables performance counters for the context."]
pub const vx_directive_e_VX_DIRECTIVE_ENABLE_PERFORMANCE: vx_directive_e = 12291;
#[doc = " \\brief These enumerations are given to the \\c vxDirective API to enable/disable\n platform optimizations and/or features. Directives are not optional and\n usually are vendor-specific, by defining a vendor range of directives and\n starting their enumeration from there.\n \\see <tt>vxDirective</tt>\n \\ingroup group_directive"]
pub type vx_directive_e = ::std::os::raw::c_uint;
#[doc = " \\brief The graph should be verified before execution"]
pub const vx_graph_state_e_VX_GRAPH_STATE_UNVERIFIED: vx_graph_state_e = 86016;
#[doc = " \\brief The graph has been verified and has not been executed or scheduled for execution yet"]
pub const vx_graph_state_e_VX_GRAPH_STATE_VERIFIED: vx_graph_state_e = 86017;
#[doc = " \\brief The graph either has been scheduled and not completed, or is being executed"]
pub const vx_graph_state_e_VX_GRAPH_STATE_RUNNING: vx_graph_state_e = 86018;
#[doc = " \\brief The graph execution was abandoned"]
pub const vx_graph_state_e_VX_GRAPH_STATE_ABANDONED: vx_graph_state_e = 86019;
#[doc = " \\brief The graph execution is completed and the graph is not scheduled for execution"]
pub const vx_graph_state_e_VX_GRAPH_STATE_COMPLETED: vx_graph_state_e = 86020;
#[doc = " \\brief The Graph State Enumeration.\n \\ingroup group_graph"]
pub type vx_graph_state_e = ::std::os::raw::c_uint;
#[doc = " \\brief Returns the number of nodes in a graph. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_graph_attribute_e_VX_GRAPH_NUMNODES: vx_graph_attribute_e = 524800;
#[doc = " \\brief Returns the overall performance of the graph. Read-only. Use a <tt>\\ref vx_perf_t</tt> parameter.\n The accuracy of timing information is platform dependent.\n \\note Performance tracking must have been enabled. See <tt>\\ref vx_directive_e</tt>"]
pub const vx_graph_attribute_e_VX_GRAPH_PERFORMANCE: vx_graph_attribute_e = 524802;
#[doc = " \\brief Returns the number of explicitly declared parameters on the graph. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_graph_attribute_e_VX_GRAPH_NUMPARAMETERS: vx_graph_attribute_e = 524803;
#[doc = " \\brief Returns the state of the graph. See <tt>\\ref vx_graph_state_e</tt> enum."]
pub const vx_graph_attribute_e_VX_GRAPH_STATE: vx_graph_attribute_e = 524804;
#[doc = " \\brief The graph attributes list.\n \\ingroup group_graph"]
pub type vx_graph_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Results are the least significant bits of the output operand, as if\n stored in two's complement binary format in the size of its bit-depth."]
pub const vx_convert_policy_e_VX_CONVERT_POLICY_WRAP: vx_convert_policy_e = 40960;
#[doc = " \\brief Results are saturated to the bit depth of the output operand."]
pub const vx_convert_policy_e_VX_CONVERT_POLICY_SATURATE: vx_convert_policy_e = 40961;
#[doc = " \\brief The Conversion Policy Enumeration.\n \\ingroup group_basic_features"]
pub type vx_convert_policy_e = ::std::os::raw::c_uint;
#[doc = " \\brief A virtual image of no defined type."]
pub const vx_df_image_e_VX_DF_IMAGE_VIRT: vx_df_image_e = 1414678870;
#[doc = " \\brief A single plane of 24-bit pixel as 3 interleaved 8-bit units of\n R then G then B data. This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_RGB: vx_df_image_e = 843204434;
#[doc = " \\brief A single plane of 32-bit pixel as 4 interleaved 8-bit units of\n R then G then B data, then a <i>don't care</i> byte.\n This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_RGBX: vx_df_image_e = 1094862674;
#[doc = " \\brief A 2-plane YUV format of Luma (Y) and interleaved UV data at\n 4:2:0 sampling. This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_NV12: vx_df_image_e = 842094158;
#[doc = " \\brief A 2-plane YUV format of Luma (Y) and interleaved VU data at\n 4:2:0 sampling. This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_NV21: vx_df_image_e = 825382478;
#[doc = " \\brief A single plane of 32-bit macro pixel of U0, Y0, V0, Y1 bytes.\n This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_UYVY: vx_df_image_e = 1498831189;
#[doc = " \\brief A single plane of 32-bit macro pixel of Y0, U0, Y1, V0 bytes.\n This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_YUYV: vx_df_image_e = 1448695129;
#[doc = " \\brief A 3 plane of 8-bit 4:2:0 sampled Y, U, V planes.\n This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_IYUV: vx_df_image_e = 1448433993;
#[doc = " \\brief A 3 plane of 8 bit 4:4:4 sampled Y, U, V planes.\n This uses the BT709 full range by default."]
pub const vx_df_image_e_VX_DF_IMAGE_YUV4: vx_df_image_e = 878073177;
#[doc = " \\brief A single plane of unsigned 1-bit data packed eight pixels per byte.\n The least significant bit is the first pixel in each byte.\n See <tt>\\ref vx_imagepatch_addressing_t</tt> for more details."]
pub const vx_df_image_e_VX_DF_IMAGE_U1: vx_df_image_e = 825241685;
#[doc = " \\brief A single plane of unsigned 8-bit data.\n The range of data is not specified, as it may be extracted from a YUV or\n generated."]
pub const vx_df_image_e_VX_DF_IMAGE_U8: vx_df_image_e = 942682197;
#[doc = " \\brief A single plane of unsigned 16-bit data.\n The range of data is not specified, as it may be extracted from a YUV or\n generated."]
pub const vx_df_image_e_VX_DF_IMAGE_U16: vx_df_image_e = 909193301;
#[doc = " \\brief A single plane of signed 16-bit data.\n The range of data is not specified, as it may be extracted from a YUV or\n generated."]
pub const vx_df_image_e_VX_DF_IMAGE_S16: vx_df_image_e = 909193299;
#[doc = " \\brief A single plane of unsigned 32-bit data.\n The range of data is not specified, as it may be extracted from a YUV or\n generated."]
pub const vx_df_image_e_VX_DF_IMAGE_U32: vx_df_image_e = 842215509;
#[doc = " \\brief A single plane of unsigned 32-bit data.\n The range of data is not specified, as it may be extracted from a YUV or\n generated."]
pub const vx_df_image_e_VX_DF_IMAGE_S32: vx_df_image_e = 842215507;
#[doc = " \\brief Based on the VX_DF_IMAGE definition.\n \\note Use <tt>\\ref vx_df_image</tt> to contain these values.\n \\ingroup group_basic_features"]
pub type vx_df_image_e = ::std::os::raw::c_uint;
#[doc = " \\brief Any available target. An OpenVX implementation must support at least one target associated with this value"]
pub const vx_target_e_VX_TARGET_ANY: vx_target_e = 77824;
#[doc = " \\brief Target, explicitly specified by its (case-insensitive) name string."]
pub const vx_target_e_VX_TARGET_STRING: vx_target_e = 77825;
#[doc = " \\brief Start of Vendor specific target enumerates."]
pub const vx_target_e_VX_TARGET_VENDOR_BEGIN: vx_target_e = 81920;
#[doc = " \\brief The Target Enumeration.\n \\ingroup group_basic_features"]
pub type vx_target_e = ::std::os::raw::c_uint;
#[doc = " \\brief Returns the reference count of the object. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_reference_attribute_e_VX_REFERENCE_COUNT: vx_reference_attribute_e = 524288;
#[doc = " \\brief Returns the <tt>\\ref vx_type_e</tt> of the reference. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_reference_attribute_e_VX_REFERENCE_TYPE: vx_reference_attribute_e = 524289;
#[doc = " \\brief Used to query the reference for its name. Read-write. Use a *<tt>\\ref vx_char</tt> parameter."]
pub const vx_reference_attribute_e_VX_REFERENCE_NAME: vx_reference_attribute_e = 524290;
#[doc = " \\brief The reference attributes list.\n \\ingroup group_reference"]
pub type vx_reference_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the unique vendor ID. Read-only. Use a <tt>\\ref vx_uint16</tt>."]
pub const vx_context_attribute_e_VX_CONTEXT_VENDOR_ID: vx_context_attribute_e = 524544;
#[doc = " \\brief Queries the OpenVX Version Number. Read-only. Use a <tt>\\ref vx_uint16</tt>"]
pub const vx_context_attribute_e_VX_CONTEXT_VERSION: vx_context_attribute_e = 524545;
#[doc = " \\brief Queries the context for the number of \\e unique kernels. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_UNIQUE_KERNELS: vx_context_attribute_e = 524546;
#[doc = " \\brief Queries the context for the number of active modules. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_MODULES: vx_context_attribute_e = 524547;
#[doc = " \\brief Queries the context for the number of active references. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_REFERENCES: vx_context_attribute_e = 524548;
#[doc = " \\brief Queries the context for it's implementation name. Read-only. Use a <tt>\\ref vx_char</tt>[<tt>\\ref VX_MAX_IMPLEMENTATION_NAME</tt>] array"]
pub const vx_context_attribute_e_VX_CONTEXT_IMPLEMENTATION: vx_context_attribute_e = 524549;
#[doc = " \\brief Queries the number of bytes in the extensions string. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_EXTENSIONS_SIZE: vx_context_attribute_e = 524550;
#[doc = " \\brief Retrieves the extensions string. Read-only.\n This is a space-separated string of extension names. Each OpenVX official extension has a unique identifier,\n comprised of capital letters, numbers and the underscore character, prefixed with \"KHR_\", for example \"KHR_NEW_FEATURE\".\n Use a <tt>\\ref vx_char</tt> pointer allocated to the size returned from <tt>\\ref VX_CONTEXT_EXTENSIONS_SIZE</tt>."]
pub const vx_context_attribute_e_VX_CONTEXT_EXTENSIONS: vx_context_attribute_e = 524551;
#[doc = " \\brief The maximum width or height of a convolution matrix.\n Read-only. Use a <tt>\\ref vx_size</tt> parameter.\n Each vendor must support centered kernels of size w X h, where both w\n and h are odd numbers, 3 <= w <= n and 3 <= h <= n, where n is the value of the\n <tt>\\ref VX_CONTEXT_CONVOLUTION_MAX_DIMENSION</tt> attribute. n is an odd\n number that should not be smaller than 9. w and h may or may not be equal to\n each other. All combinations of w and h meeting the conditions above must be\n supported. The behavior of <tt>\\ref vxCreateConvolution</tt> is undefined for values\n larger than the value returned by this attribute."]
pub const vx_context_attribute_e_VX_CONTEXT_CONVOLUTION_MAX_DIMENSION: vx_context_attribute_e =
    524552;
#[doc = " \\brief The maximum window dimension of the OpticalFlowPyrLK kernel. The value of this attribute shall be equal to or greater than '9'.\n \\see <tt>\\ref VX_KERNEL_OPTICAL_FLOW_PYR_LK</tt>. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION:
    vx_context_attribute_e = 524553;
#[doc = " \\brief The border mode for immediate mode functions.\n \\details Graph mode functions are unaffected by this attribute. Read-write. Use a pointer to a <tt>\\ref vx_border_t</tt> structure as parameter.\n \\note The assumed default value for immediate mode functions is <tt>\\ref VX_BORDER_UNDEFINED</tt>."]
pub const vx_context_attribute_e_VX_CONTEXT_IMMEDIATE_BORDER: vx_context_attribute_e = 524554;
#[doc = " \\brief Returns the table of all unique the kernels that exist in the context.\n  Read-only. Use a <tt>\\ref vx_kernel_info_t</tt> array.\n \\pre You must call <tt>\\ref vxQueryContext</tt> with <tt>\\ref VX_CONTEXT_UNIQUE_KERNELS</tt>\n to compute the necessary size of the array."]
pub const vx_context_attribute_e_VX_CONTEXT_UNIQUE_KERNEL_TABLE: vx_context_attribute_e = 524555;
#[doc = " \\brief The unsupported border mode policy for immediate mode functions. Read-Write.\n \\details Graph mode functions are unaffected by this attribute. Use a <tt>\\ref vx_enum</tt> as parameter. Will contain a <tt>\\ref vx_border_policy_e</tt>.\n \\note The assumed default value for immediate mode functions is <tt>\\ref VX_BORDER_POLICY_DEFAULT_TO_UNDEFINED</tt>. Users should refer to the documentation of their implementation to determine what border modes are supported by each kernel."]
pub const vx_context_attribute_e_VX_CONTEXT_IMMEDIATE_BORDER_POLICY: vx_context_attribute_e =
    524556;
#[doc = " \\brief The dimension of the largest nonlinear filter supported. See <tt>\\ref vxNonLinearFilterNode</tt>.\n \\details The implementation must support all dimensions (height or width, not necessarily the same)\n up to the value of this attribute.  The lowest value that must be supported for this attribute is 9.\n Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_context_attribute_e_VX_CONTEXT_NONLINEAR_MAX_DIMENSION: vx_context_attribute_e =
    524557;
#[doc = " \\brief tensor Data maximal number of dimensions supported by the implementation."]
pub const vx_context_attribute_e_VX_CONTEXT_MAX_TENSOR_DIMS: vx_context_attribute_e = 524558;
#[doc = " \\brief A list of context attributes.\n \\ingroup group_context"]
pub type vx_context_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries a kernel for the number of parameters the kernel\n supports. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_kernel_attribute_e_VX_KERNEL_PARAMETERS: vx_kernel_attribute_e = 525312;
#[doc = " \\brief Queries the name of the kernel. Not settable.\n  Read-only. Use a <tt>\\ref vx_char</tt>[<tt>\\ref VX_MAX_KERNEL_NAME</tt>] array (not a <tt>\\ref vx_array</tt>)."]
pub const vx_kernel_attribute_e_VX_KERNEL_NAME: vx_kernel_attribute_e = 525313;
#[doc = " \\brief Queries the enum of the kernel. Not settable.\n  Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_kernel_attribute_e_VX_KERNEL_ENUM: vx_kernel_attribute_e = 525314;
#[doc = " \\brief The local data area allocated with each kernel when it becomes a\n node.  Read-write. Can be written only before user-kernel finalization.\n Use a <tt>\\ref vx_size</tt> parameter.\n \\note If not set it will default to zero."]
pub const vx_kernel_attribute_e_VX_KERNEL_LOCAL_DATA_SIZE: vx_kernel_attribute_e = 525315;
#[doc = " \\brief The kernel attributes list\n \\ingroup group_kernel"]
pub type vx_kernel_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the status of node execution. Read-only. Use a <tt>\\ref vx_status</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_STATUS: vx_node_attribute_e = 525056;
#[doc = " \\brief Queries the performance of the node execution.\n The accuracy of timing information is platform dependent and also depends on the graph\n optimizations. Read-only.\n \\note Performance tracking must have been enabled. See <tt>\\ref vx_directive_e</tt>."]
pub const vx_node_attribute_e_VX_NODE_PERFORMANCE: vx_node_attribute_e = 525057;
#[doc = " \\brief Gets or sets the border mode of the node.\n Read-write. Use a <tt>\\ref vx_border_t</tt> structure with a default value of VX_BORDER_UNDEFINED."]
pub const vx_node_attribute_e_VX_NODE_BORDER: vx_node_attribute_e = 525058;
#[doc = " \\brief Indicates the size of the kernel local memory area.\n Read-only. Can be written only at user-node (de)initialization if VX_KERNEL_LOCAL_DATA_SIZE==0.\n Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_LOCAL_DATA_SIZE: vx_node_attribute_e = 525059;
#[doc = " \\brief Indicates the pointer kernel local memory area.\n Read-Write. Can be written only at user-node (de)initialization if VX_KERNEL_LOCAL_DATA_SIZE==0.\n Use a void * parameter."]
pub const vx_node_attribute_e_VX_NODE_LOCAL_DATA_PTR: vx_node_attribute_e = 525060;
#[doc = " \\brief Indicates the number of node parameters, including optional parameters that are not passed.\n Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_PARAMETERS: vx_node_attribute_e = 525061;
#[doc = " \\brief Indicates whether the node is replicated. Read-only.\n Use a <tt>\\ref vx_bool</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_IS_REPLICATED: vx_node_attribute_e = 525062;
#[doc = " \\brief Indicates the replicated parameters. Read-only.\n Use a <tt>\\ref vx_bool</tt>* parameter."]
pub const vx_node_attribute_e_VX_NODE_REPLICATE_FLAGS: vx_node_attribute_e = 525063;
#[doc = " \\brief Indicates the behavior with respect to the valid rectangle. Read-only.\n Use a <tt>\\ref vx_bool</tt> parameter."]
pub const vx_node_attribute_e_VX_NODE_VALID_RECT_RESET: vx_node_attribute_e = 525064;
#[doc = " \\brief The node attributes list.\n \\ingroup group_node"]
pub type vx_node_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries a parameter for its index value on the kernel with which it is associated. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_INDEX: vx_parameter_attribute_e = 525568;
#[doc = " \\brief Queries a parameter for its direction value on the kernel with which it is associated. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_DIRECTION: vx_parameter_attribute_e = 525569;
#[doc = " \\brief Queries a parameter for its type, \\ref vx_type_e is returned. Read-only. The size of the parameter is implied for plain data objects. For opaque data objects like images and arrays a query to their attributes has to be called to determine the size."]
pub const vx_parameter_attribute_e_VX_PARAMETER_TYPE: vx_parameter_attribute_e = 525570;
#[doc = " \\brief Queries a parameter for its state. A value in <tt>\\ref vx_parameter_state_e</tt> is returned. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_STATE: vx_parameter_attribute_e = 525571;
#[doc = " \\brief Use to extract the reference contained in the parameter. Read-only. Use a <tt>\\ref vx_reference</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_REF: vx_parameter_attribute_e = 525572;
#[doc = " \\brief Use to extract the meta format contained in the parameter. Read-only. Use a <tt>\\ref vx_meta_format</tt> parameter."]
pub const vx_parameter_attribute_e_VX_PARAMETER_META_FORMAT: vx_parameter_attribute_e = 525573;
#[doc = " \\brief The parameter attributes list\n \\ingroup group_parameter"]
pub type vx_parameter_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries an image for its width. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_WIDTH: vx_image_attribute_e = 528128;
#[doc = " \\brief Queries an image for its height. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_HEIGHT: vx_image_attribute_e = 528129;
#[doc = " \\brief Queries an image for its format. Read-only. Use a <tt>\\ref vx_df_image</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_FORMAT: vx_image_attribute_e = 528130;
#[doc = " \\brief Queries an image for its number of planes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_PLANES: vx_image_attribute_e = 528131;
#[doc = " \\brief Queries an image for its color space (see <tt>\\ref vx_color_space_e</tt>). Read-write. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_SPACE: vx_image_attribute_e = 528132;
#[doc = " \\brief Queries an image for its channel range (see <tt>\\ref vx_channel_range_e</tt>). Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_RANGE: vx_image_attribute_e = 528133;
#[doc = " \\brief Queries memory type if created using vxCreateImageFromHandle. If vx_image was not created using\nvxCreateImageFromHandle, VX_MEMORY_TYPE_NONE is returned. Use a <tt>\\ref vx_memory_type_e</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_MEMORY_TYPE: vx_image_attribute_e = 528135;
#[doc = " \\brief Queries if an image is uniform. Read-only. Use a <tt>\\ref vx_bool</tt> parameter"]
pub const vx_image_attribute_e_VX_IMAGE_IS_UNIFORM: vx_image_attribute_e = 528136;
#[doc = " \\brief Queries the image uniform value if any. Read-only. Use a <tt>\\ref vx_pixel_value_t</tt> parameter."]
pub const vx_image_attribute_e_VX_IMAGE_UNIFORM_VALUE: vx_image_attribute_e = 528137;
#[doc = " \\brief The image attributes list.\n \\ingroup group_image"]
pub type vx_image_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the type of atomic that is contained in the scalar. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_scalar_attribute_e_VX_SCALAR_TYPE: vx_scalar_attribute_e = 527616;
#[doc = " \\brief The scalar attributes list.\n \\ingroup group_scalar"]
pub type vx_scalar_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief logical and."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_AND: vx_scalar_operation_e = 131072;
#[doc = " \\brief logical or."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_OR: vx_scalar_operation_e = 131073;
#[doc = " \\brief logical exclusive or."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_XOR: vx_scalar_operation_e = 131074;
#[doc = " \\brief logical nand."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_NAND: vx_scalar_operation_e = 131075;
#[doc = " \\brief comparison (equal)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_EQUAL: vx_scalar_operation_e = 131076;
#[doc = " \\brief comparison (not equal)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_NOTEQUAL: vx_scalar_operation_e = 131077;
#[doc = " \\brief comparison (less than)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_LESS: vx_scalar_operation_e = 131078;
#[doc = " \\brief comparison (less than or equal to)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_LESSEQ: vx_scalar_operation_e = 131079;
#[doc = " \\brief comparison (greater than)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_GREATER: vx_scalar_operation_e = 131080;
#[doc = " \\brief comparison (greater than or equal to)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_GREATEREQ: vx_scalar_operation_e = 131081;
#[doc = " \\brief arithmetic addition."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_ADD: vx_scalar_operation_e = 131082;
#[doc = " \\brief arithmetic subtraction."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_SUBTRACT: vx_scalar_operation_e = 131083;
#[doc = " \\brief arithmetic multiplication."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MULTIPLY: vx_scalar_operation_e = 131084;
#[doc = " \\brief arithmetic division."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_DIVIDE: vx_scalar_operation_e = 131085;
#[doc = " \\brief arithmetic (modulo operator)."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MODULUS: vx_scalar_operation_e = 131086;
#[doc = " \\brief minimum of two scalars."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MIN: vx_scalar_operation_e = 131087;
#[doc = " \\brief maximum of two scalars."]
pub const vx_scalar_operation_e_VX_SCALAR_OP_MAX: vx_scalar_operation_e = 131088;
#[doc = " \\brief A type of operation in which both operands are scalars.\n \\see group_scalar\n \\ingroup group_scalar"]
pub type vx_scalar_operation_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the value type of the LUT. Read-only. Use a <tt>\\ref vx_enum</tt>."]
pub const vx_lut_attribute_e_VX_LUT_TYPE: vx_lut_attribute_e = 526080;
#[doc = " \\brief Indicates the number of elements in the LUT. Read-only. Use a <tt>\\ref vx_size</tt>."]
pub const vx_lut_attribute_e_VX_LUT_COUNT: vx_lut_attribute_e = 526081;
#[doc = " \\brief Indicates the total size of the LUT in bytes. Read-only. Uses a <tt>\\ref vx_size</tt>."]
pub const vx_lut_attribute_e_VX_LUT_SIZE: vx_lut_attribute_e = 526082;
#[doc = " \\brief Indicates the index of the input value = 0. Read-only. Uses a <tt>\\ref vx_uint32</tt>."]
pub const vx_lut_attribute_e_VX_LUT_OFFSET: vx_lut_attribute_e = 526083;
#[doc = " \\brief The Look-Up Table (LUT) attribute list.\n \\ingroup group_lut"]
pub type vx_lut_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the number of dimensions in the distribution. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_DIMENSIONS: vx_distribution_attribute_e =
    526336;
#[doc = " \\brief Indicates the start of the values to use (inclusive). Read-only. Use a <tt>\\ref vx_int32</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_OFFSET: vx_distribution_attribute_e = 526337;
#[doc = " \\brief Indicates the total number of the consecutive values of the distribution interval."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_RANGE: vx_distribution_attribute_e = 526338;
#[doc = " \\brief Indicates the number of bins. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_BINS: vx_distribution_attribute_e = 526339;
#[doc = " \\brief Indicates the width of a bin. Equal to the range divided by the number of bins. If the range is not a\n multiple of the number of bins, it is not valid. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_WINDOW: vx_distribution_attribute_e = 526340;
#[doc = " \\brief Indicates the total size of the distribution in bytes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_distribution_attribute_e_VX_DISTRIBUTION_SIZE: vx_distribution_attribute_e = 526341;
#[doc = " \\brief The distribution attribute list.\n \\ingroup group_distribution"]
pub type vx_distribution_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief A threshold with only 1 value."]
pub const vx_threshold_type_e_VX_THRESHOLD_TYPE_BINARY: vx_threshold_type_e = 45056;
#[doc = " \\brief A threshold with 2 values (upper/lower). Use with Canny Edge Detection."]
pub const vx_threshold_type_e_VX_THRESHOLD_TYPE_RANGE: vx_threshold_type_e = 45057;
#[doc = " \\brief The Threshold types.\n \\ingroup group_threshold"]
pub type vx_threshold_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief The value type of the threshold. Read-only. Use a <tt>\\ref vx_enum</tt> parameter. Will contain a <tt>\\ref vx_threshold_type_e</tt>."]
pub const vx_threshold_attribute_e_VX_THRESHOLD_TYPE: vx_threshold_attribute_e = 526848;
#[doc = " \\brief The input image format the threshold was created for. Read-only. Use a <tt>\\ref vx_enum</tt> parameter. Will contain a <tt>\\ref vx_df_image_e</tt>."]
pub const vx_threshold_attribute_e_VX_THRESHOLD_INPUT_FORMAT: vx_threshold_attribute_e = 526855;
#[doc = " \\brief The output image format the threshold was created for. Read-only. Use a <tt>\\ref vx_enum</tt> parameter. Will contain a <tt>\\ref vx_df_image_e</tt>."]
pub const vx_threshold_attribute_e_VX_THRESHOLD_OUTPUT_FORMAT: vx_threshold_attribute_e = 526856;
#[doc = " \\brief The threshold attributes.\n \\ingroup group_threshold"]
pub type vx_threshold_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The value type of the matrix. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_TYPE: vx_matrix_attribute_e = 527104;
#[doc = " \\brief The M dimension of the matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_ROWS: vx_matrix_attribute_e = 527105;
#[doc = " \\brief The N dimension of the matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_COLUMNS: vx_matrix_attribute_e = 527106;
#[doc = " \\brief The total size of the matrix in bytes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_SIZE: vx_matrix_attribute_e = 527107;
#[doc = " \\brief The origin of the matrix with a default value of [floor(VX_MATRIX_COLUMNS/2),\nfloor(VX_MATRIX_ROWS/2)]. Read-only. Use a <tt>\\ref vx_coordinates2d_t</tt> parameter."]
pub const vx_matrix_attribute_e_VX_MATRIX_ORIGIN: vx_matrix_attribute_e = 527108;
#[doc = " \\brief The pattern of the matrix. See <tt>\\ref vx_pattern_e </tt>. Read-only. Use a\n <tt>\\ref vx_enum</tt> parameter. If the matrix was created via <tt>\\ref vxCreateMatrixFromPattern</tt>\n or <tt>\\ref vxCreateMatrixFromPatternAndOrigin</tt>, the attribute corresponds to the given pattern.\n Otherwise the attribute is <tt>\\ref VX_PATTERN_OTHER</tt>."]
pub const vx_matrix_attribute_e_VX_MATRIX_PATTERN: vx_matrix_attribute_e = 527109;
#[doc = " \\brief The matrix attributes.\n \\ingroup group_matrix"]
pub type vx_matrix_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The number of rows of the convolution matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_ROWS: vx_convolution_attribute_e = 527360;
#[doc = " \\brief The number of columns of the convolution matrix. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_COLUMNS: vx_convolution_attribute_e = 527361;
#[doc = " \\brief The scale of the convolution matrix. Read-write. Use a <tt>\\ref vx_uint32</tt> parameter.\n \\if OPENVX_STRICT_1_0\n \\note For 1.0, only powers of 2 are supported up to 2^31.\n \\endif"]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_SCALE: vx_convolution_attribute_e = 527362;
#[doc = " \\brief The total size of the convolution matrix in bytes. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_convolution_attribute_e_VX_CONVOLUTION_SIZE: vx_convolution_attribute_e = 527363;
#[doc = " \\brief The convolution attributes.\n \\ingroup group_convolution"]
pub type vx_convolution_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The number of levels of the pyramid. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_LEVELS: vx_pyramid_attribute_e = 526592;
#[doc = " \\brief The scale factor between each level of the pyramid. Read-only. Use a <tt>\\ref vx_float32</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_SCALE: vx_pyramid_attribute_e = 526593;
#[doc = " \\brief The width of the 0th image in pixels. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_WIDTH: vx_pyramid_attribute_e = 526594;
#[doc = " \\brief The height of the 0th image in pixels. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_HEIGHT: vx_pyramid_attribute_e = 526595;
#[doc = " \\brief The <tt>\\ref vx_df_image_e</tt> format of the image. Read-only. Use a <tt>\\ref vx_df_image</tt> parameter."]
pub const vx_pyramid_attribute_e_VX_PYRAMID_FORMAT: vx_pyramid_attribute_e = 526596;
#[doc = " \\brief The pyramid object attributes.\n \\ingroup group_pyramid"]
pub type vx_pyramid_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The source width. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_SOURCE_WIDTH: vx_remap_attribute_e = 528384;
#[doc = " \\brief The source height. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_SOURCE_HEIGHT: vx_remap_attribute_e = 528385;
#[doc = " \\brief The destination width. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_DESTINATION_WIDTH: vx_remap_attribute_e = 528386;
#[doc = " \\brief The destination height. Read-only. Use a <tt>\\ref vx_uint32</tt> parameter."]
pub const vx_remap_attribute_e_VX_REMAP_DESTINATION_HEIGHT: vx_remap_attribute_e = 528387;
#[doc = " \\brief The remap object attributes.\n \\ingroup group_remap"]
pub type vx_remap_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The type of the Array items. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_ITEMTYPE: vx_array_attribute_e = 527872;
#[doc = " \\brief The number of items in the Array. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_NUMITEMS: vx_array_attribute_e = 527873;
#[doc = " \\brief The maximal number of items that the Array can hold. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_CAPACITY: vx_array_attribute_e = 527874;
#[doc = " \\brief Queries an array item size. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_array_attribute_e_VX_ARRAY_ITEMSIZE: vx_array_attribute_e = 527875;
#[doc = " \\brief The array object attributes.\n \\ingroup group_array"]
pub type vx_array_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The type of the ObjectArray items. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_object_array_attribute_e_VX_OBJECT_ARRAY_ITEMTYPE: vx_object_array_attribute_e =
    529152;
#[doc = " \\brief The number of items in the ObjectArray. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_object_array_attribute_e_VX_OBJECT_ARRAY_NUMITEMS: vx_object_array_attribute_e =
    529153;
#[doc = " \\brief The ObjectArray object attributes.\n \\ingroup group_object_array"]
pub type vx_object_array_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Number of dimensions."]
pub const vx_tensor_attribute_e_VX_TENSOR_NUMBER_OF_DIMS: vx_tensor_attribute_e = 529664;
#[doc = " \\brief Dimension sizes."]
pub const vx_tensor_attribute_e_VX_TENSOR_DIMS: vx_tensor_attribute_e = 529665;
#[doc = " \\brief tensor Data element data type. <tt>vx_type_e</tt>"]
pub const vx_tensor_attribute_e_VX_TENSOR_DATA_TYPE: vx_tensor_attribute_e = 529666;
#[doc = " \\brief fixed point position when the input element type is integer."]
pub const vx_tensor_attribute_e_VX_TENSOR_FIXED_POINT_POSITION: vx_tensor_attribute_e = 529667;
#[doc = " \\brief tensor Data attributes.\n \\ingroup group_object_tensor"]
pub type vx_tensor_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Valid rectangle callback during output parameter validation. Write-only."]
pub const vx_meta_valid_rect_attribute_e_VX_VALID_RECT_CALLBACK: vx_meta_valid_rect_attribute_e =
    528897;
#[doc = " \\brief The meta valid rectangle attributes.\n \\ingroup group_user_kernels"]
pub type vx_meta_valid_rect_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_0: vx_channel_e = 36864;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_1: vx_channel_e = 36865;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_2: vx_channel_e = 36866;
#[doc = " \\brief Used by formats with unknown channel types."]
pub const vx_channel_e_VX_CHANNEL_3: vx_channel_e = 36867;
#[doc = " \\brief Use to extract the RED channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_R: vx_channel_e = 36880;
#[doc = " \\brief Use to extract the GREEN channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_G: vx_channel_e = 36881;
#[doc = " \\brief Use to extract the BLUE channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_B: vx_channel_e = 36882;
#[doc = " \\brief Use to extract the ALPHA channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_A: vx_channel_e = 36883;
#[doc = " \\brief Use to extract the LUMA channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_Y: vx_channel_e = 36884;
#[doc = " \\brief Use to extract the Cb/U channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_U: vx_channel_e = 36885;
#[doc = " \\brief Use to extract the Cr/V/Value channel, no matter the byte or packing order."]
pub const vx_channel_e_VX_CHANNEL_V: vx_channel_e = 36886;
#[doc = " \\brief The channel enumerations for channel extractions.\n \\see vxChannelExtractNode\n \\see vxuChannelExtract\n \\see VX_KERNEL_CHANNEL_EXTRACT\n \\ingroup group_basic_features"]
pub type vx_channel_e = ::std::os::raw::c_uint;
#[doc = " \\brief For memory allocated through OpenVX, this is the import type."]
pub const vx_memory_type_e_VX_MEMORY_TYPE_NONE: vx_memory_type_e = 57344;
#[doc = " \\brief The default memory type to import from the Host."]
pub const vx_memory_type_e_VX_MEMORY_TYPE_HOST: vx_memory_type_e = 57345;
#[doc = " \\brief An enumeration of memory import types.\n \\ingroup group_context"]
pub type vx_memory_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Output values are defined to match the source pixel whose center is nearest to the sample position."]
pub const vx_interpolation_type_e_VX_INTERPOLATION_NEAREST_NEIGHBOR: vx_interpolation_type_e =
    16384;
#[doc = " \\brief Output values are defined by bilinear interpolation between the pixels whose centers are closest\n to the sample position, weighted linearly by the distance of the sample from the pixel centers."]
pub const vx_interpolation_type_e_VX_INTERPOLATION_BILINEAR: vx_interpolation_type_e = 16385;
#[doc = " \\brief Output values are determined by averaging the source pixels whose areas fall under the\n area of the destination pixel, projected onto the source image."]
pub const vx_interpolation_type_e_VX_INTERPOLATION_AREA: vx_interpolation_type_e = 16386;
#[doc = " \\brief The image reconstruction filters supported by image resampling operations.\n\n The edge of a pixel is interpreted as being aligned to the edge of the image.\n The value for an output pixel is evaluated at the center of that pixel.\n\n This means, for example, that an even enlargement of a factor of two in nearest-neighbor\n interpolation will replicate every source pixel into a 2x2 quad in the destination, and that\n an even shrink by a factor of two in bilinear interpolation will create each destination pixel\n by average a 2x2 quad of source pixels.\n\n Samples that cross the boundary of the source image have values determined by the border\n mode - see <tt>\\ref vx_border_e</tt> and <tt>\\ref VX_NODE_BORDER</tt>.\n \\see vxuScaleImage\n \\see vxScaleImageNode\n \\see VX_KERNEL_SCALE_IMAGE\n \\see vxuWarpAffine\n \\see vxWarpAffineNode\n \\see VX_KERNEL_WARP_AFFINE\n \\see vxuWarpPerspective\n \\see vxWarpPerspectiveNode\n \\see VX_KERNEL_WARP_PERSPECTIVE\n \\ingroup group_basic_features"]
pub type vx_interpolation_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Nonlinear median filter."]
pub const vx_non_linear_filter_e_VX_NONLINEAR_FILTER_MEDIAN: vx_non_linear_filter_e = 90112;
#[doc = " \\brief Nonlinear Erode."]
pub const vx_non_linear_filter_e_VX_NONLINEAR_FILTER_MIN: vx_non_linear_filter_e = 90113;
#[doc = " \\brief Nonlinear Dilate."]
pub const vx_non_linear_filter_e_VX_NONLINEAR_FILTER_MAX: vx_non_linear_filter_e = 90114;
#[doc = " \\brief An enumeration of non-linear filter functions.\n \\ingroup group_basic_features"]
pub type vx_non_linear_filter_e = ::std::os::raw::c_uint;
#[doc = " \\brief Box pattern matrix"]
pub const vx_pattern_e_VX_PATTERN_BOX: vx_pattern_e = 94208;
#[doc = " \\brief Cross pattern matrix"]
pub const vx_pattern_e_VX_PATTERN_CROSS: vx_pattern_e = 94209;
#[doc = " \\brief A square matrix (rows = columns = size)"]
pub const vx_pattern_e_VX_PATTERN_DISK: vx_pattern_e = 94210;
#[doc = " \\brief Matrix with any pattern other than above."]
pub const vx_pattern_e_VX_PATTERN_OTHER: vx_pattern_e = 94211;
#[doc = " \\brief An enumeration of matrix patterns. See <tt>\\ref vxCreateMatrixFromPattern </tt>\n  and <tt>\\ref vxCreateMatrixFromPatternAndOrigin </tt>\n \\ingroup group_basic_features"]
pub type vx_pattern_e = ::std::os::raw::c_uint;
#[doc = " \\brief Use to indicate that no color space is used."]
pub const vx_color_space_e_VX_COLOR_SPACE_NONE: vx_color_space_e = 24576;
#[doc = " \\brief Use to indicate that the BT.601 coefficients and SMPTE C primaries are used for conversions."]
pub const vx_color_space_e_VX_COLOR_SPACE_BT601_525: vx_color_space_e = 24577;
#[doc = " \\brief Use to indicate that the BT.601 coefficients and BTU primaries are used for conversions."]
pub const vx_color_space_e_VX_COLOR_SPACE_BT601_625: vx_color_space_e = 24578;
#[doc = " \\brief Use to indicate that the BT.709 coefficients are used for conversions."]
pub const vx_color_space_e_VX_COLOR_SPACE_BT709: vx_color_space_e = 24579;
#[doc = " \\brief All images in VX are by default BT.709"]
pub const vx_color_space_e_VX_COLOR_SPACE_DEFAULT: vx_color_space_e = 24579;
#[doc = " \\brief The image color space list used by the <tt>\\ref VX_IMAGE_SPACE</tt> attribute of a <tt>\\ref vx_image</tt>.\n \\ingroup group_image"]
pub type vx_color_space_e = ::std::os::raw::c_uint;
#[doc = " \\brief Full range of the unit of the channel"]
pub const vx_channel_range_e_VX_CHANNEL_RANGE_FULL: vx_channel_range_e = 28672;
#[doc = " \\brief Restricted range of the unit of the channel based on the space given"]
pub const vx_channel_range_e_VX_CHANNEL_RANGE_RESTRICTED: vx_channel_range_e = 28673;
#[doc = " \\brief The image channel range list used by the <tt>\\ref VX_IMAGE_RANGE</tt> attribute of a <tt>\\ref vx_image</tt>.\n  \\ingroup group_image"]
pub type vx_channel_range_e = ::std::os::raw::c_uint;
#[doc = " \\brief Default. The parameter must be supplied. If not set, during\n Verify, an error is returned."]
pub const vx_parameter_state_e_VX_PARAMETER_STATE_REQUIRED: vx_parameter_state_e = 32768;
#[doc = " \\brief The parameter may be unspecified. The kernel takes care not\n to deference optional parameters until it is certain they are valid."]
pub const vx_parameter_state_e_VX_PARAMETER_STATE_OPTIONAL: vx_parameter_state_e = 32769;
#[doc = " \\brief The parameter state type.\n \\ingroup group_parameter"]
pub type vx_parameter_state_e = ::std::os::raw::c_uint;
#[doc = " \\brief No defined border mode behavior is given."]
pub const vx_border_e_VX_BORDER_UNDEFINED: vx_border_e = 49152;
#[doc = " \\brief For nodes that support this behavior, a constant value is\n \\e filled-in when accessing out-of-bounds pixels."]
pub const vx_border_e_VX_BORDER_CONSTANT: vx_border_e = 49153;
#[doc = " \\brief For nodes that support this behavior, a replication of the nearest\n edge pixels value is given for out-of-bounds pixels."]
pub const vx_border_e_VX_BORDER_REPLICATE: vx_border_e = 49154;
#[doc = " \\brief The border mode list.\n \\ingroup group_borders"]
pub type vx_border_e = ::std::os::raw::c_uint;
#[doc = " \\brief Use VX_BORDER_UNDEFINED instead of unsupported border modes."]
pub const vx_border_policy_e_VX_BORDER_POLICY_DEFAULT_TO_UNDEFINED: vx_border_policy_e = 81920;
#[doc = " \\brief Return VX_ERROR_NOT_SUPPORTED for unsupported border modes."]
pub const vx_border_policy_e_VX_BORDER_POLICY_RETURN_ERROR: vx_border_policy_e = 81921;
#[doc = " \\brief The unsupported border mode policy list.\n \\ingroup group_borders"]
pub type vx_border_policy_e = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates a termination after a set number of iterations."]
pub const vx_termination_criteria_e_VX_TERM_CRITERIA_ITERATIONS: vx_termination_criteria_e = 61440;
#[doc = " \\brief Indicates a termination after matching against the value of eplison provided to the function."]
pub const vx_termination_criteria_e_VX_TERM_CRITERIA_EPSILON: vx_termination_criteria_e = 61441;
#[doc = " \\brief Indicates that both an iterations and eplison method are employed. Whichever one matches first\n causes the termination."]
pub const vx_termination_criteria_e_VX_TERM_CRITERIA_BOTH: vx_termination_criteria_e = 61442;
#[doc = " \\brief The termination criteria list.\n \\see group_vision_function_opticalflowpyrlk\n \\ingroup group_context"]
pub type vx_termination_criteria_e = ::std::os::raw::c_uint;
#[doc = " \\brief The L1 normalization."]
pub const vx_norm_type_e_VX_NORM_L1: vx_norm_type_e = 65536;
#[doc = " \\brief The L2 normalization."]
pub const vx_norm_type_e_VX_NORM_L2: vx_norm_type_e = 65537;
#[doc = " \\brief A normalization type.\n \\see group_vision_function_canny\n \\ingroup group_vision_function_canny"]
pub type vx_norm_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief The type of objects in the delay. Read-only. Use a <tt>\\ref vx_enum</tt> parameter."]
pub const vx_delay_attribute_e_VX_DELAY_TYPE: vx_delay_attribute_e = 525824;
#[doc = " \\brief The number of items in the delay. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_delay_attribute_e_VX_DELAY_SLOTS: vx_delay_attribute_e = 525825;
#[doc = " \\brief The delay attribute list.\n \\ingroup group_delay"]
pub type vx_delay_attribute_e = ::std::os::raw::c_uint;
#[doc = " \\brief The memory shall be treated by the system as if it were read-only.\n If the User writes to this memory, the results are implementation defined."]
pub const vx_accessor_e_VX_READ_ONLY: vx_accessor_e = 69633;
#[doc = " \\brief The memory shall be treated by the system as if it were write-only.\n If the User reads from this memory, the results are implementation defined."]
pub const vx_accessor_e_VX_WRITE_ONLY: vx_accessor_e = 69634;
#[doc = " \\brief The memory shall be treated by the system as if it were readable and writeable."]
pub const vx_accessor_e_VX_READ_AND_WRITE: vx_accessor_e = 69635;
#[doc = " \\brief The memory accessor hint flags.\n These enumeration values are used to indicate desired \\e system behavior,\n not the \\b User intent. For example: these can be interpretted as hints to the\n system about cache operations or marshalling operations.\n \\ingroup group_context"]
pub type vx_accessor_e = ::std::os::raw::c_uint;
#[doc = " \\brief When scaling, this truncates the least significant values that are lost in operations."]
pub const vx_round_policy_e_VX_ROUND_POLICY_TO_ZERO: vx_round_policy_e = 73729;
#[doc = " \\brief When scaling, this rounds to nearest even output value."]
pub const vx_round_policy_e_VX_ROUND_POLICY_TO_NEAREST_EVEN: vx_round_policy_e = 73730;
#[doc = " \\brief The Round Policy Enumeration.\n \\ingroup group_context"]
pub type vx_round_policy_e = ::std::os::raw::c_uint;
#[doc = " \\brief local binary pattern"]
pub const vx_lbp_format_e_VX_LBP: vx_lbp_format_e = 98304;
#[doc = " \\brief Modified Local Binary Patterns"]
pub const vx_lbp_format_e_VX_MLBP: vx_lbp_format_e = 98305;
#[doc = " \\brief Uniform local binary pattern"]
pub const vx_lbp_format_e_VX_ULBP: vx_lbp_format_e = 98306;
#[doc = " \\brief Local binary pattern supported.\n \\ingroup group_vision_function_lbp"]
pub type vx_lbp_format_e = ::std::os::raw::c_uint;
#[doc = " \\brief hamming distance \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} XOR(T(\\grave{x},\\grave{y}),I(x+\\grave{x},y+\\grave{y}))\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_HAMMING: vx_comp_metric_e = 102400;
#[doc = " \\brief L1 distance \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} ABS(T(\\grave{x},\\grave{y}) - I(x+\\grave{x},y+\\grave{y}))\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_L1: vx_comp_metric_e = 102401;
#[doc = " \\brief L2 distance normalized by image size \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} (T(\\grave{x},\\grave{y}) - I(x+\\grave{x},y+\\grave{y}))^2\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_L2: vx_comp_metric_e = 102402;
#[doc = " \\brief cross correlation distance \\f$ R(x,y) = \\frac{1}{w*h}\\sum_{\\grave{x},\\grave{y}}^{w,h} (T(\\grave{x},\\grave{y})*I(x+\\grave{x},y+\\grave{y}))\\f$"]
pub const vx_comp_metric_e_VX_COMPARE_CCORR: vx_comp_metric_e = 102403;
#[doc = " \\brief L2 normalized distance \\f$ R(x,y) = \\frac{\\sum_{\\grave{x},\\grave{y}}^{w,h} (T(\\grave{x},\\grave{y}) - I(x+\\grave{x},y+\\grave{y}))^2}\n {\\sqrt{\\sum_{\\grave{x},\\grave{y}}^{w,h} T(\\grave{x},\\grave{y})^2 * I(x+\\grave{x},y+\\grave{y})^2}} \\f$"]
pub const vx_comp_metric_e_VX_COMPARE_L2_NORM: vx_comp_metric_e = 102404;
#[doc = " \\brief cross correlation normalized distance \\f$ R(x,y) = \\frac{\\sum_{\\grave{x},\\grave{y}}^{w,h} T(\\grave{x},\\grave{y}) * I(x+\\grave{x},y+\\grave{y})*2^{15}}\n {\\sqrt{\\sum_{\\grave{x},\\grave{y}}^{w,h} T(\\grave{x},\\grave{y})^2 * I(x+\\grave{x},y+\\grave{y})^2}} \\f$"]
pub const vx_comp_metric_e_VX_COMPARE_CCORR_NORM: vx_comp_metric_e = 102405;
#[doc = " \\brief comparing metrics.\n \\details In all the equations below w and h are width and height of the template image respectively.\n \\f$ R \\f$ is the compare map. \\f$ T \\f$ is the template image.\\f$ I \\f$ is the image on which the template is searched.\n \\ingroup group_vision_function_match_template"]
pub type vx_comp_metric_e = ::std::os::raw::c_uint;
#[doc = " \\brief The addressing image patch structure is used by the Host only\n to address pixels in an image patch. The fields of the structure are defined as:\n \\arg dim - The dimensions of the image in logical pixel units in the x & y direction.\n \\arg stride - The physical byte distance from a logical pixel to the next\n logically adjacent pixel in the positive x or y direction.\n \\arg scale - The relationship of scaling from the primary plane (typically\n the zero indexed plane) to this plane. An integer down-scaling factor of \\f$ f \\f$ shall be\n set to a value equal to \\f$ scale = \\frac{unity}{f} \\f$ and an integer up-scaling factor of \\f$ f \\f$\n shall be set to a value of \\f$ scale = unity * f \\f$. \\f$ unity \\f$ is defined as <tt>\\ref VX_SCALE_UNITY</tt>.\n \\arg step - The step is the number of logical pixel units to skip to\n arrive at the next physically unique pixel. For example, on a plane that is\n half-scaled in a dimension, the step in that dimension is 2 to indicate that\n every other pixel in that dimension is an alias. This is useful in situations\n where iteration over unique pixels is required, such as in serializing\n or de-serializing the image patch information.\n \\see <tt>\\ref vxMapImagePatch</tt>\n \\note For <tt>\\ref VX_DF_IMAGE_U1</tt> images it is defined that \\a stride_x == 0 since it is less than one byte.\n The least significant bit (bit number 0, value 1) in the first byte in the image,\n is the left-most pixel in the upper left corner, i.e. origo. A <tt>\\ref VX_DF_IMAGE_U1</tt> image always\n start on a byte boundary and each row has a \\a stride_y that is a multiple of whole bytes, which means padding\n bits of undefined value may be present at the end of each row.\n Imagepatches can only be accessed at a multiple of eight pixels: the x-coordinate must be a multiple of eight.\n Individual pixel access is also different: the byte at the imagepatch-calculated pointer value is a collection of eight pixels.\n Each byte can then be masked with the bit-mask <tt> 1 << (x % 8)</tt> to get individual pixel values (shifted <tt>x</tt> times).\n See \\ref sub_image_access for an example.\n \\ingroup group_image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_imagepatch_addressing_t {
    #[doc = "< \\brief Width of patch in X dimension in pixels."]
    pub dim_x: vx_uint32,
    #[doc = "< \\brief Height of patch in Y dimension in pixels."]
    pub dim_y: vx_uint32,
    #[doc = "< \\brief Stride in X dimension in bytes."]
    pub stride_x: vx_int32,
    #[doc = "< \\brief Stride in Y dimension in bytes."]
    pub stride_y: vx_int32,
    #[doc = "< \\brief Scale of X dimension. For sub-sampled planes this is the scaling factor of the dimension of the plane in relation to the zero plane. Use <tt>\\ref VX_SCALE_UNITY</tt> in the numerator."]
    pub scale_x: vx_uint32,
    #[doc = "< \\brief Scale of Y dimension. For sub-sampled planes this is the scaling factor of the dimension of the plane in relation to the zero plane. Use <tt>\\ref VX_SCALE_UNITY</tt> in the numerator."]
    pub scale_y: vx_uint32,
    #[doc = "< \\brief Step of X dimension in pixels."]
    pub step_x: vx_uint32,
    #[doc = "< \\brief Step of Y dimension in pixels."]
    pub step_y: vx_uint16,
    #[doc = "< \\brief Stride in X dimension in bits. Used when stride_x is not an integer number of bytes."]
    pub stride_x_bits: vx_uint16,
}
#[test]
fn bindgen_test_layout__vx_imagepatch_addressing_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_imagepatch_addressing_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_imagepatch_addressing_t>(),
        32usize,
        concat!("Size of: ", stringify!(_vx_imagepatch_addressing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_imagepatch_addressing_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_imagepatch_addressing_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(dim_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(dim_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(stride_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(stride_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(scale_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_y) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(scale_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(step_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(step_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride_x_bits) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_imagepatch_addressing_t),
            "::",
            stringify!(stride_x_bits)
        )
    );
}
#[doc = " \\brief The addressing image patch structure is used by the Host only\n to address pixels in an image patch. The fields of the structure are defined as:\n \\arg dim - The dimensions of the image in logical pixel units in the x & y direction.\n \\arg stride - The physical byte distance from a logical pixel to the next\n logically adjacent pixel in the positive x or y direction.\n \\arg scale - The relationship of scaling from the primary plane (typically\n the zero indexed plane) to this plane. An integer down-scaling factor of \\f$ f \\f$ shall be\n set to a value equal to \\f$ scale = \\frac{unity}{f} \\f$ and an integer up-scaling factor of \\f$ f \\f$\n shall be set to a value of \\f$ scale = unity * f \\f$. \\f$ unity \\f$ is defined as <tt>\\ref VX_SCALE_UNITY</tt>.\n \\arg step - The step is the number of logical pixel units to skip to\n arrive at the next physically unique pixel. For example, on a plane that is\n half-scaled in a dimension, the step in that dimension is 2 to indicate that\n every other pixel in that dimension is an alias. This is useful in situations\n where iteration over unique pixels is required, such as in serializing\n or de-serializing the image patch information.\n \\see <tt>\\ref vxMapImagePatch</tt>\n \\note For <tt>\\ref VX_DF_IMAGE_U1</tt> images it is defined that \\a stride_x == 0 since it is less than one byte.\n The least significant bit (bit number 0, value 1) in the first byte in the image,\n is the left-most pixel in the upper left corner, i.e. origo. A <tt>\\ref VX_DF_IMAGE_U1</tt> image always\n start on a byte boundary and each row has a \\a stride_y that is a multiple of whole bytes, which means padding\n bits of undefined value may be present at the end of each row.\n Imagepatches can only be accessed at a multiple of eight pixels: the x-coordinate must be a multiple of eight.\n Individual pixel access is also different: the byte at the imagepatch-calculated pointer value is a collection of eight pixels.\n Each byte can then be masked with the bit-mask <tt> 1 << (x % 8)</tt> to get individual pixel values (shifted <tt>x</tt> times).\n See \\ref sub_image_access for an example.\n \\ingroup group_image"]
pub type vx_imagepatch_addressing_t = _vx_imagepatch_addressing_t;
#[doc = " \\brief The performance measurement structure. The time or durations are in units of nano seconds.\n \\ingroup group_performance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_perf_t {
    #[doc = "< \\brief Holds the last measurement."]
    pub tmp: vx_uint64,
    #[doc = "< \\brief Holds the first measurement in a set."]
    pub beg: vx_uint64,
    #[doc = "< \\brief Holds the last measurement in a set."]
    pub end: vx_uint64,
    #[doc = "< \\brief Holds the summation of durations."]
    pub sum: vx_uint64,
    #[doc = "< \\brief Holds the average of the durations."]
    pub avg: vx_uint64,
    #[doc = "< \\brief Holds the minimum of the durations."]
    pub min: vx_uint64,
    #[doc = "< \\brief Holds the number of measurements."]
    pub num: vx_uint64,
    #[doc = "< \\brief Holds the maximum of the durations."]
    pub max: vx_uint64,
}
#[test]
fn bindgen_test_layout__vx_perf_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_perf_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_perf_t>(),
        64usize,
        concat!("Size of: ", stringify!(_vx_perf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_perf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_perf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(tmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(beg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sum) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(sum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(avg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_perf_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " \\brief The performance measurement structure. The time or durations are in units of nano seconds.\n \\ingroup group_performance"]
pub type vx_perf_t = _vx_perf_t;
#[doc = " \\brief Hough lines probability parameters.\n \\ingroup group_vision_function_hough_lines_p"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_hough_lines_p_t {
    #[doc = " \\brief  Distance resolution of the parameter in pixels."]
    pub rho: vx_float32,
    #[doc = " \\brief Angle resolution of the parameter in radians."]
    pub theta: vx_float32,
    #[doc = " \\brief The minimum number of intersections to detect a line."]
    pub threshold: vx_int32,
    #[doc = " \\brief The minimum number of points that can form a line. Line segments shorter than that are rejected."]
    pub line_length: vx_int32,
    #[doc = " \\brief The maximum allowed gap between points on the same line to link them."]
    pub line_gap: vx_int32,
    #[doc = " \\brief Optional restriction on theta. The max allowed value."]
    pub theta_max: vx_float32,
    #[doc = " \\brief Optional restriction on theta. The min allowed value."]
    pub theta_min: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_hough_lines_p_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_hough_lines_p_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_hough_lines_p_t>(),
        28usize,
        concat!("Size of: ", stringify!(_vx_hough_lines_p_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_hough_lines_p_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_hough_lines_p_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rho) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(rho)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(theta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(line_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_gap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(line_gap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theta_max) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(theta_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theta_min) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_hough_lines_p_t),
            "::",
            stringify!(theta_min)
        )
    );
}
#[doc = " \\brief Hough lines probability parameters.\n \\ingroup group_vision_function_hough_lines_p"]
pub type vx_hough_lines_p_t = _vx_hough_lines_p_t;
#[doc = " \\brief line struct\n \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_line2d_t {
    #[doc = " \\brief x index of line start"]
    pub start_x: vx_float32,
    #[doc = " \\brief y index of line start"]
    pub start_y: vx_float32,
    #[doc = " \\brief x index of line end"]
    pub end_x: vx_float32,
    #[doc = " \\brief y index of line end"]
    pub end_y: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_line2d_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_line2d_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_line2d_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_line2d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_line2d_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_line2d_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(end_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_line2d_t),
            "::",
            stringify!(end_y)
        )
    );
}
#[doc = " \\brief line struct\n \\ingroup group_basic_features"]
pub type vx_line2d_t = _vx_line2d_t;
#[doc = " \\brief Matrix Multiply Parameters\n\n transpose_input1/input2/input3 : if True the matrix is transposed before the operation, otherwise the matrix is used as is. \\n\n \\ingroup group_vision_function_tensor_matrix_multiply"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_tensor_matrix_multiply_params_t {
    #[doc = " \\brief if True the matrix is transposed before the operation, otherwise the matrix is used as is"]
    pub transpose_input1: vx_bool,
    #[doc = " \\brief if True the matrix is transposed before the operation, otherwise the matrix is used as is"]
    pub transpose_input2: vx_bool,
    #[doc = " \\brief if True the matrix is transposed before the operation, otherwise the matrix is used as is"]
    pub transpose_input3: vx_bool,
}
#[test]
fn bindgen_test_layout__vx_tensor_matrix_multiply_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_tensor_matrix_multiply_params_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_tensor_matrix_multiply_params_t>(),
        12usize,
        concat!("Size of: ", stringify!(_vx_tensor_matrix_multiply_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_tensor_matrix_multiply_params_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_vx_tensor_matrix_multiply_params_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transpose_input1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tensor_matrix_multiply_params_t),
            "::",
            stringify!(transpose_input1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transpose_input2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tensor_matrix_multiply_params_t),
            "::",
            stringify!(transpose_input2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transpose_input3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tensor_matrix_multiply_params_t),
            "::",
            stringify!(transpose_input3)
        )
    );
}
#[doc = " \\brief Matrix Multiply Parameters\n\n transpose_input1/input2/input3 : if True the matrix is transposed before the operation, otherwise the matrix is used as is. \\n\n \\ingroup group_vision_function_tensor_matrix_multiply"]
pub type vx_tensor_matrix_multiply_params_t = _vx_tensor_matrix_multiply_params_t;
#[doc = " \\brief The Kernel Information Structure. This is returned by the Context\n to indicate which kernels are available in the OpenVX implementation.\n \\ingroup group_kernel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_kernel_info_t {
    #[doc = " \\brief The kernel enumeration value from <tt>\\ref vx_kernel_e</tt> (or an\n extension thereof).\n \\see vxGetKernelByEnum"]
    pub enumeration: vx_enum,
    #[doc = " \\brief The kernel name in dotted hierarchical format.\n e.g. \"org.khronos.openvx.sobel_3x3\"\n \\see vxGetKernelByName"]
    pub name: [vx_char; 256usize],
}
#[test]
fn bindgen_test_layout__vx_kernel_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_kernel_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_kernel_info_t>(),
        260usize,
        concat!("Size of: ", stringify!(_vx_kernel_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_kernel_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_kernel_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumeration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_kernel_info_t),
            "::",
            stringify!(enumeration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_kernel_info_t),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " \\brief The Kernel Information Structure. This is returned by the Context\n to indicate which kernels are available in the OpenVX implementation.\n \\ingroup group_kernel"]
pub type vx_kernel_info_t = _vx_kernel_info_t;
#[doc = " \\brief The keypoint data structure.\n \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_keypoint_t {
    #[doc = "< \\brief The x coordinate."]
    pub x: vx_int32,
    #[doc = "< \\brief The y coordinate."]
    pub y: vx_int32,
    #[doc = "< \\brief The strength of the keypoint. Its definition is specific to the corner detector."]
    pub strength: vx_float32,
    #[doc = "< \\brief Initialized to 0 by corner detectors."]
    pub scale: vx_float32,
    #[doc = "< \\brief Initialized to 0 by corner detectors."]
    pub orientation: vx_float32,
    #[doc = "< \\brief A zero indicates a lost point. Initialized to 1 by corner detectors."]
    pub tracking_status: vx_int32,
    #[doc = "< \\brief A tracking method specific error. Initialized to 0 by corner detectors."]
    pub error: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_keypoint_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_keypoint_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_keypoint_t>(),
        28usize,
        concat!("Size of: ", stringify!(_vx_keypoint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_keypoint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_keypoint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracking_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(tracking_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_keypoint_t),
            "::",
            stringify!(error)
        )
    );
}
#[doc = " \\brief The keypoint data structure.\n \\ingroup group_basic_features"]
pub type vx_keypoint_t = _vx_keypoint_t;
#[doc = " \\brief The rectangle data structure that is shared with the users. The area of the rectangle can be computed as (end_x-start_x)*(end_y-start_y).\n \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_rectangle_t {
    #[doc = "< \\brief The Start X coordinate."]
    pub start_x: vx_uint32,
    #[doc = "< \\brief The Start Y coordinate."]
    pub start_y: vx_uint32,
    #[doc = "< \\brief The End X coordinate."]
    pub end_x: vx_uint32,
    #[doc = "< \\brief The End Y coordinate."]
    pub end_y: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_rectangle_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_rectangle_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_rectangle_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_rectangle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_rectangle_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_rectangle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(end_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_rectangle_t),
            "::",
            stringify!(end_y)
        )
    );
}
#[doc = " \\brief The rectangle data structure that is shared with the users. The area of the rectangle can be computed as (end_x-start_x)*(end_y-start_y).\n \\ingroup group_basic_features"]
pub type vx_rectangle_t = _vx_rectangle_t;
#[doc = " \\brief The 2D Coordinates structure.\n \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_coordinates2d_t {
    #[doc = "< \\brief The X coordinate."]
    pub x: vx_uint32,
    #[doc = "< \\brief The Y coordinate."]
    pub y: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_coordinates2d_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_coordinates2d_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_coordinates2d_t>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_coordinates2d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_coordinates2d_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_coordinates2d_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2d_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2d_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief The 2D Coordinates structure.\n \\ingroup group_basic_features"]
pub type vx_coordinates2d_t = _vx_coordinates2d_t;
#[doc = " \\brief The floating-point 2D Coordinates structure.\n \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_coordinates2df_t {
    #[doc = "< \\brief The X coordinate."]
    pub x: vx_float32,
    #[doc = "< \\brief The Y coordinate."]
    pub y: vx_float32,
}
#[test]
fn bindgen_test_layout__vx_coordinates2df_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_coordinates2df_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_coordinates2df_t>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_coordinates2df_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_coordinates2df_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_coordinates2df_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2df_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates2df_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief The floating-point 2D Coordinates structure.\n \\ingroup group_basic_features"]
pub type vx_coordinates2df_t = _vx_coordinates2df_t;
#[doc = " \\brief The 3D Coordinates structure.\n \\ingroup group_basic_features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_coordinates3d_t {
    #[doc = "< \\brief The X coordinate."]
    pub x: vx_uint32,
    #[doc = "< \\brief The Y coordinate."]
    pub y: vx_uint32,
    #[doc = "< \\brief The Z coordinate."]
    pub z: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_coordinates3d_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_coordinates3d_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_coordinates3d_t>(),
        12usize,
        concat!("Size of: ", stringify!(_vx_coordinates3d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_coordinates3d_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_coordinates3d_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates3d_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates3d_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_coordinates3d_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " \\brief The 3D Coordinates structure.\n \\ingroup group_basic_features"]
pub type vx_coordinates3d_t = _vx_coordinates3d_t;
#[doc = " \\brief Union that describes the value of a pixel for any image format. Use the field\n corresponding to the image format.\n \\ingroup group_image"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _vx_pixel_value_t {
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_RGB</tt> format in the R,G,B order"]
    pub RGB: [vx_uint8; 3usize],
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_RGBX</tt> format in the R,G,B,X order"]
    pub RGBX: [vx_uint8; 4usize],
    #[doc = "< \\brief All YUV formats in the Y,U,V order"]
    pub YUV: [vx_uint8; 3usize],
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U1</tt>"]
    pub U1: vx_bool,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U8</tt>"]
    pub U8: vx_uint8,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U16</tt>"]
    pub U16: vx_uint16,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_S16</tt>"]
    pub S16: vx_int16,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_U32</tt>"]
    pub U32: vx_uint32,
    #[doc = "< \\brief <tt>\\ref VX_DF_IMAGE_S32</tt>"]
    pub S32: vx_int32,
    pub reserved: [vx_uint8; 16usize],
}
#[test]
fn bindgen_test_layout__vx_pixel_value_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_pixel_value_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_pixel_value_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_pixel_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_pixel_value_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_pixel_value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RGB) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(RGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RGBX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(RGBX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).YUV) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(YUV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(S16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(U32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(S32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_pixel_value_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\brief Union that describes the value of a pixel for any image format. Use the field\n corresponding to the image format.\n \\ingroup group_image"]
pub type vx_pixel_value_t = _vx_pixel_value_t;
#[doc = " \\brief The HOG descriptor structure.\n \\ingroup group_vision_function_hog"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vx_hog_t {
    #[doc = " \\brief   The histogram cell width of type <tt>\\ref VX_TYPE_INT32</tt>."]
    pub cell_width: vx_int32,
    #[doc = " \\brief   The histogram cell height of type <tt>\\ref VX_TYPE_INT32</tt>."]
    pub cell_height: vx_int32,
    #[doc = " \\brief  The histogram block width of type <tt>\\ref VX_TYPE_INT32</tt>.  Must be divisible by cell_width."]
    pub block_width: vx_int32,
    #[doc = " \\brief  The histogram block height of type <tt>\\ref VX_TYPE_INT32</tt>.  Must be divisible by cell_height."]
    pub block_height: vx_int32,
    #[doc = " \\brief  The histogram block stride within the window of type <tt>\\ref VX_TYPE_INT32</tt>.  Must be an integral number of cell_width and cell_height."]
    pub block_stride: vx_int32,
    #[doc = " \\brief  The histogram size of type <tt>\\ref VX_TYPE_INT32</tt>."]
    pub num_bins: vx_int32,
    #[doc = " \\brief  The feature descriptor window width of type <tt>\\ref VX_TYPE_INT32</tt>"]
    pub window_width: vx_int32,
    #[doc = " \\brief  The feature descriptor window height of type <tt>\\ref VX_TYPE_INT32</tt>"]
    pub window_height: vx_int32,
    #[doc = " \\brief The feature descriptor window stride of type <tt>\\ref VX_TYPE_INT32</tt>"]
    pub window_stride: vx_int32,
    #[doc = " \\brief The threshold for the maximum L2-norm value for a histogram bin.  It is used as part of block normalization.  It defaults to 0.2."]
    pub threshold: vx_float32,
}
#[test]
fn bindgen_test_layout_vx_hog_t() {
    const UNINIT: ::std::mem::MaybeUninit<vx_hog_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vx_hog_t>(),
        40usize,
        concat!("Size of: ", stringify!(vx_hog_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vx_hog_t>(),
        4usize,
        concat!("Alignment of ", stringify!(vx_hog_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cell_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(cell_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cell_height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(cell_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(block_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_stride) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(block_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(num_bins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(window_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(window_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_stride) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(window_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_hog_t),
            "::",
            stringify!(threshold)
        )
    );
}
#[doc = " \\brief Use with the enumeration <tt>\\ref VX_NODE_BORDER</tt> to set the\n border mode behavior of a node that supports borders.\n\n If the indicated border mode is not supported, an error <tt>\\ref VX_ERROR_NOT_SUPPORTED</tt> will be reported\n either at the time the <tt>\\ref VX_NODE_BORDER</tt> is set or at the time of graph verification.\n \\ingroup group_borders"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _vx_border_t {
    #[doc = " \\brief See <tt>\\ref vx_border_e</tt>."]
    pub mode: vx_enum,
    #[doc = " \\brief For the mode <tt>\\ref VX_BORDER_CONSTANT</tt>, this union contains the\n value of out-of-bound pixels."]
    pub constant_value: vx_pixel_value_t,
}
#[test]
fn bindgen_test_layout__vx_border_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_border_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_border_t>(),
        20usize,
        concat!("Size of: ", stringify!(_vx_border_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_border_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_border_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_border_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constant_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_border_t),
            "::",
            stringify!(constant_value)
        )
    );
}
#[doc = " \\brief Use with the enumeration <tt>\\ref VX_NODE_BORDER</tt> to set the\n border mode behavior of a node that supports borders.\n\n If the indicated border mode is not supported, an error <tt>\\ref VX_ERROR_NOT_SUPPORTED</tt> will be reported\n either at the time the <tt>\\ref VX_NODE_BORDER</tt> is set or at the time of graph verification.\n \\ingroup group_borders"]
pub type vx_border_t = _vx_border_t;
#[doc = " \\brief The type of the <tt>vxPublishKernels</tt> entry function of modules loaded\n by <tt>\\ref vxLoadKernels</tt> and unloaded by <tt>\\ref vxUnloadKernels</tt>.\n \\param [in] context The reference to the context kernels must be added to.\n \\ingroup group_user_kernels"]
pub type vx_publish_kernels_f =
    ::std::option::Option<unsafe extern "C" fn(context: vx_context) -> vx_status>;
#[doc = " \\brief The type of the <tt>vxUnpublishKernels</tt> entry function of modules loaded\n by <tt>\\ref vxLoadKernels</tt> and unloaded by <tt>\\ref vxUnloadKernels</tt>.\n \\param [in] context The reference to the context kernels have been added to.\n \\ingroup group_user_kernels"]
pub type vx_unpublish_kernels_f =
    ::std::option::Option<unsafe extern "C" fn(context: vx_context) -> vx_status>;
#[doc = " \\brief The pointer to the Host side kernel.\n \\param [in] node The handle to the node that contains this kernel.\n \\param [in] parameters The array of parameter references.\n \\param [in] num The number of parameters.\n \\ingroup group_user_kernels"]
pub type vx_kernel_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
    ) -> vx_status,
>;
#[doc = " \\brief The pointer to the kernel initializer. If the host code requires a call\n to initialize data once all the parameters have been validated, this function is called\n if not NULL.\n \\param [in] node The handle to the node that contains this kernel.\n \\param [in] parameters The array of parameter references.\n \\param [in] num The number of parameters.\n \\ingroup group_user_kernels"]
pub type vx_kernel_initialize_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
    ) -> vx_status,
>;
#[doc = " \\brief The pointer to the kernel deinitializer. If the host code requires a call\n to deinitialize data during a node garbage collection, this function is called\n if not NULL.\n \\param [in] node The handle to the node that contains this kernel.\n \\param [in] parameters The array of parameter references.\n \\param [in] num The number of parameters.\n \\ingroup group_user_kernels"]
pub type vx_kernel_deinitialize_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
    ) -> vx_status,
>;
#[doc = " \\brief The user-defined kernel node parameters validation function. The function only\n needs to fill in the meta data structure(s).\n \\note This function is called once for whole set of parameters.\n \\param [in] node The handle to the node that is being validated.\n \\param [in] parameters The array of parameters to be validated.\n \\param [in] num Number of parameters to be validated.\n \\param [in] metas A pointer to a pre-allocated array of structure references that the system holds.\n The system pre-allocates a number of vx_meta_format structures for the output parameters only,\n indexed by the same indices as parameters[]. The validation function fills in the correct type, format,\n and dimensionality for the system to use either to create memory or to check against existing memory.\n \\return An error code describing the validation status on parameters.\n \\ingroup group_user_kernels"]
pub type vx_kernel_validate_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        parameters: *const vx_reference,
        num: vx_uint32,
        metas: *mut vx_meta_format,
    ) -> vx_status,
>;
#[doc = " \\brief A user-defined callback function to set the valid rectangle of an output image.\n\n The <tt>\\ref VX_VALID_RECT_CALLBACK</tt> attribute in the <tt>\\ref vx_meta_format</tt> object should be\n set to the desired callback during user node's output validator. The callback must not call\n <tt>\\ref vxGetValidRegionImage</tt> or <tt>\\ref vxSetImageValidRectangle</tt>.  Instead, an array of the\n valid rectangles of all the input images is supplied to the callback to calculate the output\n valid rectangle. The output of the user node may be a pyramid, or just an image.  If it is just an\n image, the 'Out' array associated with that output only has one element.  If the output is a\n pyramid, the array size is equal to the number of pyramid levels. Notice that the array memory\n allocation passed to the callback is managed by the framework, the application must not allocate or\n deallocate those pointers.\n\n The behavior of the callback function vx_kernel_image_valid_rectangle_f is undefined\n if one of the following is true:\n - One of the input arguments of a user node is a pyramid or an array of images.\n - Either input or output argument of a user node is an array of pyramids.\n\n \\param [in,out] node The handle to the node that is being validated.\n \\param [in] index The index of the output parameter for which a valid region should be set.\n \\param [in] input_valid A pointer to an array of valid regions of input images or images\n contained in image container (e.g. pyramids). They are provided in same order as the parameter\n list of the kernel's declaration.\n \\param [out] output_valid An array of valid regions that should be set for the output images or\n image containers (e.g. pyramid) after graph processing. The length of the array should be equal\n to the size of the image container (e.g. number of levels in the pyramid). For a simple output\n image the array size is always one. Each rectangle supplies the valid region for one image. The\n array memory allocation is managed by the framework.\n \\return An error code describing the validation status on parameters.\n \\ingroup group_user_kernels"]
pub type vx_kernel_image_valid_rectangle_f = ::std::option::Option<
    unsafe extern "C" fn(
        node: vx_node,
        index: vx_uint32,
        input_valid: *const *const vx_rectangle_t,
        output_valid: *const *mut vx_rectangle_t,
    ) -> vx_status,
>;
#[doc = " \\brief The log callback function.\n \\ingroup group_log"]
pub type vx_log_callback_f = ::std::option::Option<
    unsafe extern "C" fn(
        context: vx_context,
        ref_: vx_reference,
        status: vx_status,
        string: *const vx_char,
    ),
>;
#[doc = "< \\brief No Gap."]
pub const vx_map_flag_e_VX_NOGAP_X: vx_map_flag_e = 1;
#[doc = " \\brief The Map/Unmap operation enumeration.\n \\ingroup group_image"]
pub type vx_map_flag_e = ::std::os::raw::c_uint;
#[doc = " \\brief The base set of kernels as defined by Khronos."]
pub const vx_library_e_VX_LIBRARY_KHR_BASE: vx_library_e = 0;
#[doc = " \\brief The standard list of available libraries\n \\ingroup group_kernel"]
pub type vx_library_e = ::std::os::raw::c_uint;
#[doc = " \\brief The Color Space conversion kernel.\n \\details The conversions are based on the <tt>\\ref vx_df_image_e</tt> code in the images.\n \\see group_vision_function_colorconvert"]
pub const vx_kernel_e_VX_KERNEL_COLOR_CONVERT: vx_kernel_e = 1;
#[doc = " \\brief The Generic Channel Extraction Kernel.\n \\details This kernel can remove individual color channels from an interleaved\n or semi-planar, planar, sub-sampled planar image. A client could extract\n a red channel from an interleaved RGB image or do a Luma extract from a\n YUV format.\n \\see group_vision_function_channelextract"]
pub const vx_kernel_e_VX_KERNEL_CHANNEL_EXTRACT: vx_kernel_e = 2;
#[doc = " \\brief The Generic Channel Combine Kernel.\n \\details This kernel combine multiple individual planes into a single\n multiplanar image of the type specified in the output image.\n \\see group_vision_function_channelcombine"]
pub const vx_kernel_e_VX_KERNEL_CHANNEL_COMBINE: vx_kernel_e = 3;
#[doc = " \\brief The Sobel 3x3 Filter Kernel.\n \\see group_vision_function_sobel3x3"]
pub const vx_kernel_e_VX_KERNEL_SOBEL_3x3: vx_kernel_e = 4;
#[doc = " \\brief The Magnitude Kernel.\n \\details This kernel produces a magnitude plane from two input gradients.\n \\see group_vision_function_magnitude"]
pub const vx_kernel_e_VX_KERNEL_MAGNITUDE: vx_kernel_e = 5;
#[doc = " \\brief The Phase Kernel.\n \\details This kernel produces a phase plane from two input gradients.\n \\see group_vision_function_phase"]
pub const vx_kernel_e_VX_KERNEL_PHASE: vx_kernel_e = 6;
#[doc = " \\brief The Scale Image Kernel.\n \\details This kernel provides resizing of an input image to an output image.\n The scaling factor is determined but the relative sizes of the input and\n output.\n \\see group_vision_function_scale_image"]
pub const vx_kernel_e_VX_KERNEL_SCALE_IMAGE: vx_kernel_e = 7;
#[doc = " \\brief The Table Lookup kernel\n \\see group_vision_function_lut"]
pub const vx_kernel_e_VX_KERNEL_TABLE_LOOKUP: vx_kernel_e = 8;
#[doc = " \\brief The Histogram Kernel.\n \\see group_vision_function_histogram"]
pub const vx_kernel_e_VX_KERNEL_HISTOGRAM: vx_kernel_e = 9;
#[doc = " \\brief The Histogram Equalization Kernel.\n \\see group_vision_function_equalize_hist"]
pub const vx_kernel_e_VX_KERNEL_EQUALIZE_HISTOGRAM: vx_kernel_e = 10;
#[doc = " \\brief The Absolute Difference Kernel.\n \\see group_vision_function_absdiff"]
pub const vx_kernel_e_VX_KERNEL_ABSDIFF: vx_kernel_e = 11;
#[doc = " \\brief The Mean and Standard Deviation Kernel.\n \\see group_vision_function_meanstddev"]
pub const vx_kernel_e_VX_KERNEL_MEAN_STDDEV: vx_kernel_e = 12;
#[doc = " \\brief The Threshold Kernel.\n \\see group_vision_function_threshold"]
pub const vx_kernel_e_VX_KERNEL_THRESHOLD: vx_kernel_e = 13;
#[doc = " \\brief The Integral Image Kernel.\n \\see group_vision_function_integral_image"]
pub const vx_kernel_e_VX_KERNEL_INTEGRAL_IMAGE: vx_kernel_e = 14;
#[doc = " \\brief The dilate kernel.\n \\see group_vision_function_dilate_image"]
pub const vx_kernel_e_VX_KERNEL_DILATE_3x3: vx_kernel_e = 15;
#[doc = " \\brief The erode kernel.\n \\see group_vision_function_erode_image"]
pub const vx_kernel_e_VX_KERNEL_ERODE_3x3: vx_kernel_e = 16;
#[doc = " \\brief The median image filter.\n \\see group_vision_function_median_image"]
pub const vx_kernel_e_VX_KERNEL_MEDIAN_3x3: vx_kernel_e = 17;
#[doc = " \\brief The box filter kernel.\n \\see group_vision_function_box_image"]
pub const vx_kernel_e_VX_KERNEL_BOX_3x3: vx_kernel_e = 18;
#[doc = " \\brief The gaussian filter kernel.\n \\see group_vision_function_gaussian_image"]
pub const vx_kernel_e_VX_KERNEL_GAUSSIAN_3x3: vx_kernel_e = 19;
#[doc = " \\brief The custom convolution kernel.\n \\see group_vision_function_custom_convolution"]
pub const vx_kernel_e_VX_KERNEL_CUSTOM_CONVOLUTION: vx_kernel_e = 20;
#[doc = " \\brief The gaussian image pyramid kernel.\n \\see group_vision_function_gaussian_pyramid"]
pub const vx_kernel_e_VX_KERNEL_GAUSSIAN_PYRAMID: vx_kernel_e = 21;
#[doc = " \\brief The min and max location kernel.\n \\see group_vision_function_minmaxloc"]
pub const vx_kernel_e_VX_KERNEL_MINMAXLOC: vx_kernel_e = 25;
#[doc = " \\brief The bit-depth conversion kernel.\n \\see group_vision_function_convertdepth"]
pub const vx_kernel_e_VX_KERNEL_CONVERTDEPTH: vx_kernel_e = 26;
#[doc = " \\brief The Canny Edge Detector.\n \\see group_vision_function_canny"]
pub const vx_kernel_e_VX_KERNEL_CANNY_EDGE_DETECTOR: vx_kernel_e = 27;
#[doc = " \\brief The Bitwise And Kernel.\n \\see group_vision_function_and"]
pub const vx_kernel_e_VX_KERNEL_AND: vx_kernel_e = 28;
#[doc = " \\brief The Bitwise Inclusive Or Kernel.\n \\see group_vision_function_or"]
pub const vx_kernel_e_VX_KERNEL_OR: vx_kernel_e = 29;
#[doc = " \\brief The Bitwise Exclusive Or Kernel.\n \\see group_vision_function_xor"]
pub const vx_kernel_e_VX_KERNEL_XOR: vx_kernel_e = 30;
#[doc = " \\brief The Bitwise Not Kernel.\n \\see group_vision_function_not"]
pub const vx_kernel_e_VX_KERNEL_NOT: vx_kernel_e = 31;
#[doc = " \\brief The Pixelwise Multiplication Kernel.\n \\see group_vision_function_mult"]
pub const vx_kernel_e_VX_KERNEL_MULTIPLY: vx_kernel_e = 32;
#[doc = " \\brief The Addition Kernel.\n \\see group_vision_function_add"]
pub const vx_kernel_e_VX_KERNEL_ADD: vx_kernel_e = 33;
#[doc = " \\brief The Subtraction Kernel.\n \\see group_vision_function_sub"]
pub const vx_kernel_e_VX_KERNEL_SUBTRACT: vx_kernel_e = 34;
#[doc = " \\brief The Warp Affine Kernel.\n \\see group_vision_function_warp_affine"]
pub const vx_kernel_e_VX_KERNEL_WARP_AFFINE: vx_kernel_e = 35;
#[doc = " \\brief The Warp Perspective Kernel.\n \\see group_vision_function_warp_perspective"]
pub const vx_kernel_e_VX_KERNEL_WARP_PERSPECTIVE: vx_kernel_e = 36;
#[doc = " \\brief The Harris Corners Kernel.\n \\see group_vision_function_harris"]
pub const vx_kernel_e_VX_KERNEL_HARRIS_CORNERS: vx_kernel_e = 37;
#[doc = " \\brief The FAST Corners Kernel.\n \\see group_vision_function_fast"]
pub const vx_kernel_e_VX_KERNEL_FAST_CORNERS: vx_kernel_e = 38;
#[doc = " \\brief The Optical Flow Pyramid (LK) Kernel.\n \\see group_vision_function_opticalflowpyrlk"]
pub const vx_kernel_e_VX_KERNEL_OPTICAL_FLOW_PYR_LK: vx_kernel_e = 39;
#[doc = " \\brief The Remap Kernel.\n \\see group_vision_function_remap"]
pub const vx_kernel_e_VX_KERNEL_REMAP: vx_kernel_e = 40;
#[doc = " \\brief The Half Scale Gaussian Kernel.\n \\see group_vision_function_scale_image"]
pub const vx_kernel_e_VX_KERNEL_HALFSCALE_GAUSSIAN: vx_kernel_e = 41;
#[doc = "< \\internal Used for VX1.0 bounds checking in the conformance test."]
pub const vx_kernel_e_VX_KERNEL_MAX_1_0: vx_kernel_e = 42;
#[doc = " \\brief The Laplacian Image Pyramid Kernel.\n \\see group_vision_function_laplacian_pyramid"]
pub const vx_kernel_e_VX_KERNEL_LAPLACIAN_PYRAMID: vx_kernel_e = 42;
#[doc = " \\brief The Laplacian Pyramid Reconstruct Kernel.\n \\see group_vision_function_laplacian_pyramid"]
pub const vx_kernel_e_VX_KERNEL_LAPLACIAN_RECONSTRUCT: vx_kernel_e = 43;
#[doc = " \\brief The Non Linear Filter Kernel.\n \\see group_vision_function_nonlinear_filter"]
pub const vx_kernel_e_VX_KERNEL_NON_LINEAR_FILTER: vx_kernel_e = 44;
#[doc = "< \\internal Used for VX1.1 bounds checking in the conformance test."]
pub const vx_kernel_e_VX_KERNEL_MAX_1_1: vx_kernel_e = 45;
#[doc = " \\brief The Match Template Kernel.\n \\see group_vision_match_template"]
pub const vx_kernel_e_VX_KERNEL_MATCH_TEMPLATE: vx_kernel_e = 45;
#[doc = " \\brief The LBP Kernel.\n \\see group_lbp"]
pub const vx_kernel_e_VX_KERNEL_LBP: vx_kernel_e = 46;
#[doc = " \\brief The hough lines probability Kernel.\n \\see group_vision_hough_lines_p"]
pub const vx_kernel_e_VX_KERNEL_HOUGH_LINES_P: vx_kernel_e = 47;
#[doc = " \\brief The tensor multiply Kernel.\n \\see group_vision_function_tensor_multiply"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_MULTIPLY: vx_kernel_e = 48;
#[doc = " \\brief The tensor add Kernel.\n \\see group_vision_function_tensor_add"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_ADD: vx_kernel_e = 49;
#[doc = " \\brief The tensor subtract Kernel.\n \\see group_vision_function_tensor_subtract"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_SUBTRACT: vx_kernel_e = 50;
#[doc = " \\brief The tensor table look up Kernel.\n \\see group_vision_function_tensor_tablelookup"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_TABLE_LOOKUP: vx_kernel_e = 51;
#[doc = " \\brief The tensor transpose Kernel.\n \\see group_vision_function_tensor_transpose"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_TRANSPOSE: vx_kernel_e = 52;
#[doc = " \\brief The tensor convert depth Kernel.\n \\see group_vision_function_tensor_convert_depth"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_CONVERT_DEPTH: vx_kernel_e = 53;
#[doc = " \\brief The tensor matrix multiply Kernel.\n \\see group_vision_function_tensor_matrix_multiply"]
pub const vx_kernel_e_VX_KERNEL_TENSOR_MATRIX_MULTIPLY: vx_kernel_e = 54;
#[doc = " \\brief The data object copy kernel.\n \\see group_vision_function_copy"]
pub const vx_kernel_e_VX_KERNEL_COPY: vx_kernel_e = 55;
#[doc = " \\brief The non-max suppression kernel.\n \\see group_vision_function_nms"]
pub const vx_kernel_e_VX_KERNEL_NON_MAX_SUPPRESSION: vx_kernel_e = 56;
#[doc = " \\brief The scalar operation kernel.\n \\see group_control_flow"]
pub const vx_kernel_e_VX_KERNEL_SCALAR_OPERATION: vx_kernel_e = 57;
#[doc = " \\brief The  HOG features kernel.\n \\see group_vision_function_hog"]
pub const vx_kernel_e_VX_KERNEL_HOG_FEATURES: vx_kernel_e = 58;
#[doc = " \\brief The HOG Cells kernel.\n \\see group_vision_function_hog"]
pub const vx_kernel_e_VX_KERNEL_HOG_CELLS: vx_kernel_e = 59;
#[doc = " \\brief The bilateral filter kernel.\n \\see group_vision_function_bilateral_filter"]
pub const vx_kernel_e_VX_KERNEL_BILATERAL_FILTER: vx_kernel_e = 60;
#[doc = " \\brief The select kernel.\n \\see group_control_flow"]
pub const vx_kernel_e_VX_KERNEL_SELECT: vx_kernel_e = 61;
#[doc = "< \\internal Used for VX1.2 bounds checking in the conformance test."]
pub const vx_kernel_e_VX_KERNEL_MAX_1_2: vx_kernel_e = 62;
#[doc = " \\brief The max kernel.\n \\see group_vision_function_max"]
pub const vx_kernel_e_VX_KERNEL_MAX: vx_kernel_e = 62;
#[doc = " \\brief The min kernel.\n \\see group_vision_function_min"]
pub const vx_kernel_e_VX_KERNEL_MIN: vx_kernel_e = 63;
#[doc = " \\brief The weigthed average kernel.\n \\see group_vision_function_weighted_average"]
pub const vx_kernel_e_VX_KERNEL_WEIGHTED_AVERAGE: vx_kernel_e = 64;
#[doc = " \\brief The data object swap kernel. (If implemented)\n \\see group_vision_function_swap"]
pub const vx_kernel_e_VX_KERNEL_SWAP: vx_kernel_e = 65;
#[doc = " \\brief The data object move kernel. (If implemented)\n \\see group_vision_function_move"]
pub const vx_kernel_e_VX_KERNEL_MOVE: vx_kernel_e = 66;
#[doc = " \\brief The standard list of available vision kernels.\n\n Each kernel listed here can be used with the <tt>\\ref vxGetKernelByEnum</tt> call.\n When programming the parameters, use\n \\arg <tt>\\ref VX_INPUT</tt> for [in]\n \\arg <tt>\\ref VX_OUTPUT</tt> for [out]\n\n When programming the parameters, use\n \\arg <tt>\\ref VX_TYPE_IMAGE</tt> for a <tt>\\ref vx_image</tt> in the size field of <tt>\\ref vxGetParameterByIndex</tt> or <tt>\\ref vxSetParameterByIndex</tt>  * \\arg <tt>\\ref VX_TYPE_ARRAY</tt> for a <tt>\\ref vx_array</tt> in the size field of <tt>\\ref vxGetParameterByIndex</tt> or <tt>\\ref vxSetParameterByIndex</tt>  * \\arg or other appropriate types in \\ref vx_type_e.\n \\ingroup group_kernel"]
pub type vx_kernel_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Creates a <tt>\\ref vx_context</tt>.\n \\details This creates a top-level object context for OpenVX.\n \\note This is required to do anything else.\n \\returns The reference to the implementation context <tt>\\ref vx_context</tt>. Any possible errors\n preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_context\n \\post <tt>\\ref vxReleaseContext</tt>"]
    pub fn vxCreateContext() -> vx_context;
}
extern "C" {
    #[doc = " \\brief Releases the OpenVX object context.\n \\details All reference counted objects are garbage-collected by the return of this call.\n No calls are possible using the parameter context after the context has been\n released until a new reference from <tt>\\ref vxCreateContext</tt> is returned.\n All outstanding references to OpenVX objects from this context are invalid\n after this call.\n \\param [in] context The pointer to the reference to the context.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE context is not a valid <tt>\\ref vx_context</tt> reference.\n \\ingroup group_context\n \\pre <tt>\\ref vxCreateContext</tt>"]
    pub fn vxReleaseContext(context: *mut vx_context) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves the context from any reference from within a context.\n \\param [in] reference The reference from which to extract the context.\n \\ingroup group_context\n \\return The overall context that created the particular\n reference. Any possible errors preventing a successful completion of this function\n should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxGetContext(reference: vx_reference) -> vx_context;
}
extern "C" {
    #[doc = " \\brief Queries the context for some specific information.\n \\param [in] context The reference to the context.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_context_attribute_e</tt>.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\retval VX_ERROR_NOT_SUPPORTED If the attribute is not supported on this implementation.\n \\ingroup group_context"]
    pub fn vxQueryContext(
        context: vx_context,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets an attribute on the context.\n \\param [in] context The handle to the overall context.\n \\param [in] attribute The attribute to set from <tt>\\ref vx_context_attribute_e</tt>.\n \\param [in] ptr The pointer to the data to which to set the attribute.\n \\param [in] size The size in bytes of the data to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\retval VX_ERROR_NOT_SUPPORTED If the attribute is not settable.\n \\ingroup group_context"]
    pub fn vxSetContextAttribute(
        context: vx_context,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Provides a generic API to give platform-specific hints to the implementation.\n \\param [in] reference The reference to the object to hint at.\n This could be <tt>\\ref vx_context</tt>, <tt>\\ref vx_graph</tt>, <tt>\\ref vx_node</tt>, <tt>\\ref vx_image</tt>, <tt>\\ref vx_array</tt>, or any other reference.\n \\param [in] hint A <tt>\\ref vx_hint_e</tt> \\a hint to give to a \\ref vx_context. This is a platform-specific optimization or implementation mechanism.\n \\param [in] data Optional vendor specific data.\n \\param [in] data_size Size of the data structure \\p data.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE reference is not a valid <tt>\\ref vx_reference</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED If the hint is not supported.\n \\ingroup group_hint"]
    pub fn vxHint(
        reference: vx_reference,
        hint: vx_enum,
        data: *const ::std::os::raw::c_void,
        data_size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Provides a generic API to give platform-specific directives to the implementations.\n \\param [in] reference The reference to the object to set the directive on.\n This could be <tt>\\ref vx_context</tt>, <tt>\\ref vx_graph</tt>, <tt>\\ref vx_node</tt>, <tt>\\ref vx_image</tt>, <tt>\\ref vx_array</tt>, or any other reference.\n \\param [in] directive The directive to set. See <tt>\\ref vx_directive_e</tt>.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE reference is not a valid <tt>\\ref vx_reference</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED If the directive is not supported.\n \\note The performance counter directives are only available for the reference \\ref vx_context.\n       Error VX_ERROR_NOT_SUPPORTED is returned when used with any other reference.\n \\ingroup group_directive"]
    pub fn vxDirective(reference: vx_reference, directive: vx_enum) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Provides a generic API to return status values from Object constructors if they\n fail.\n \\note Users do not need to strictly check every object creator as the errors\n should properly propagate and be detected during verification time or run-time.\n \\code\n vx_image img = vxCreateImage(context, 639, 480, VX_DF_IMAGE_UYVY);\n vx_status status = vxGetStatus((vx_reference)img);\n // status == VX_ERROR_INVALID_DIMENSIONS\n vxReleaseImage(&img);\n \\endcode\n \\pre Appropriate Object Creator function.\n \\post Appropriate Object Release function.\n \\param [in] reference The reference to check for construction errors.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval * Some error occurred, please check enumeration list and constructor.\n \\ingroup group_basic_features"]
    pub fn vxGetStatus(reference: vx_reference) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Registers user-defined structures to the context.\n \\param [in] context  The reference to the implementation context.\n \\param [in] size     The size of user struct in bytes.\n \\return A <tt>\\ref vx_enum</tt> value that is a type given to the User\n to refer to their custom structure when declaring a <tt>\\ref vx_array</tt>\n of that structure.\n \\retval VX_TYPE_INVALID If the namespace of types has been exhausted.\n \\note This call should only be used once within the lifetime of a context for\n a specific structure.\n \\ingroup group_adv_array"]
    pub fn vxRegisterUserStruct(context: vx_context, size: vx_size) -> vx_enum;
}
extern "C" {
    #[doc = " \\brief Registers user-defined structures to the context, and associates a name to it.\n \\param [in] context     The reference to the implementation context.\n \\param [in] size        The size of user struct in bytes.\n \\param [in] *type_name  Pointer to the '\\0' terminated string that identifies the\n                         user struct type. The string is copied by the function so\n                         that it stays the property of the caller. NULL means that\n                         the user struct is not named. The length of the string\n                         shall be lower than VX_MAX_REFERENCE_NAME bytes.\n \\return A <tt>\\ref vx_enum</tt> value that is a type given to the User\n to refer to their custom structure when declaring a <tt>\\ref vx_array</tt>\n of that structure.\n \\retval VX_TYPE_INVALID If the namespace of types has been exhausted.\n \\note This call should only be used once within the lifetime of a context for\n a specific structure.\n \\ingroup group_adv_array"]
    pub fn vxRegisterUserStructWithName(
        context: vx_context,
        size: vx_size,
        type_name: *const vx_char,
    ) -> vx_enum;
}
extern "C" {
    #[doc = " \\brief Returns the name of the user-defined structure associated with the enumeration given.\n \\param [in] context     The reference to the implementation context.\n \\param [in] type_name   The enumeration value of the user struct\n \\param [out] name_size  Name of the user struct\n \\param [in] name_size   The size of allocated buffer pointed to by type_name\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS user_struct_type was valid, and name was found and returned\n \\retval VX_ERROR_INVALID_PARAMETERS user_struct_type was not a valid user struct enumeration.\n \\retval VX_ERROR_NO_MEMORY name_size is too small to hold the name of the user struct type.\n \\retval VX_FAILURE user_struct_type does not have an associated type name.\n \\pre <tt>\\ref vxRegisterUserStructWithName</tt> should be called for this user struct.\n \\ingroup group_adv_array"]
    pub fn vxGetUserStructNameByEnum(
        context: vx_context,
        user_struct_type: vx_enum,
        type_name: *mut vx_char,
        name_size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Returns the enum of the user-defined structure associated with the name given\n \\param [in] context           The reference to the implementation context.\n \\param [in] type_name         Pointer to the '\\0' terminated string that identifies the user\n                               struct type. The length of the string shall be lower than VX_MAX_REFERENCE_NAME bytes.\n \\param [out] user_struct_type The enumeration value of the user struct\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS type_name was valid, and enumeration was found and returned\n \\retval VX_FAILURE type_name does not match any user struct enumeration.\n \\pre <tt>\\ref vxRegisterUserStructWithName</tt> should be called for this user struct.\n \\ingroup group_adv_array"]
    pub fn vxGetUserStructEnumByName(
        context: vx_context,
        type_name: *const vx_char,
        user_struct_type: *mut vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allocates and registers user-defined kernel enumeration to a context.\n The allocated enumeration is from available pool of 4096 enumerations reserved\n for dynamic allocation from VX_KERNEL_BASE(VX_ID_USER,0).\n \\param [in] context  The reference to the implementation context.\n \\param [out] pKernelEnumId  pointer to return <tt>\\ref vx_enum</tt> for user-defined kernel.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE If the context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_NO_RESOURCES The enumerations has been exhausted.\n \\ingroup group_user_kernels"]
    pub fn vxAllocateUserKernelId(context: vx_context, pKernelEnumId: *mut vx_enum) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allocates and registers user-defined kernel library ID to a context.\n\n The allocated library ID is from available pool of library IDs (1..255)\n reserved for dynamic allocation. The returned libraryId can be used by\n user-kernel library developer to specify individual kernel enum IDs in\n a header file, shown below:\n \\code\n #define MY_KERNEL_ID1(libraryId) (VX_KERNEL_BASE(VX_ID_USER,libraryId) + 0);\n #define MY_KERNEL_ID2(libraryId) (VX_KERNEL_BASE(VX_ID_USER,libraryId) + 1);\n #define MY_KERNEL_ID3(libraryId) (VX_KERNEL_BASE(VX_ID_USER,libraryId) + 2);\n \\endcode\n \\param [in] context  The reference to the implementation context.\n \\param [out] pLibraryId  pointer to <tt>\\ref vx_enum</tt> for user-kernel libraryId.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_NO_RESOURCES The enumerations has been exhausted.\n \\ingroup group_user_kernels"]
    pub fn vxAllocateUserKernelLibraryId(
        context: vx_context,
        pLibraryId: *mut vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets the default target of the immediate mode. Upon successful execution of this\n function any future execution of immediate mode function is attempted on the new default\n target of the context.\n \\param [in] context  The reference to the implementation context.\n \\param [in] target_enum  The default immediate mode target enum to be set\n to the <tt>\\ref vx_context</tt> object. Use a <tt>\\ref vx_target_e</tt>.\n \\param [in] target_string  The target name ASCII string. This contains a valid value\n when target_enum is set to <tt>\\ref VX_TARGET_STRING</tt>, otherwise it is ignored.\n \\ingroup group_context\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Default target set; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE If the context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED If the specified target is not supported in this context."]
    pub fn vxSetImmediateModeTarget(
        context: vx_context,
        target_enum: vx_enum,
        target_string: *const ::std::os::raw::c_char,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to an image buffer.\n \\details Not guaranteed to exist until the <tt>\\ref vx_graph</tt> containing it has been verified.\n \\param [in] context The reference to the implementation context.\n \\param [in] width The image width in pixels. The image in the formats of\n <tt>\\ref VX_DF_IMAGE_NV12</tt>, <tt>\\ref VX_DF_IMAGE_NV21</tt>, <tt>\\ref VX_DF_IMAGE_IYUV</tt>,\n <tt>\\ref VX_DF_IMAGE_UYVY</tt>, <tt>\\ref VX_DF_IMAGE_YUYV</tt> must have even width.\n \\param [in] height The image height in pixels. The image in the formats of\n <tt>\\ref VX_DF_IMAGE_NV12</tt>, <tt>\\ref VX_DF_IMAGE_NV21</tt>, <tt>\\ref VX_DF_IMAGE_IYUV</tt>\n must have even height.\n \\param [in] color The VX_DF_IMAGE (<tt>\\ref vx_df_image_e</tt>) code that represents the format\n of the image and the color space.\n \\returns An image reference <tt>\\ref vx_image</tt>. Any possible errors preventing a successful\n creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\see vxMapImagePatch to obtain direct memory access to the image data.\n \\ingroup group_image"]
    pub fn vxCreateImage(
        context: vx_context,
        width: vx_uint32,
        height: vx_uint32,
        color: vx_df_image,
    ) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Creates an image from another image given a rectangle. This second\n reference refers to the data in the original image. Updates to this image\n updates the parent image. The rectangle must be defined within the pixel space\n of the parent image.\n \\param [in] img The reference to the parent image.\n \\param [in] rect The region of interest rectangle. Must contain points within\n the parent image pixel space.\n \\returns An image reference <tt>\\ref vx_image</tt> to the sub-image. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_image"]
    pub fn vxCreateImageFromROI(img: vx_image, rect: *const vx_rectangle_t) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Creates a reference to an image object that has a singular,\n uniform value in all pixels. The uniform image created is read-only.\n \\param [in] context The reference to the implementation context.\n \\param [in] width The image width in pixels. The image in the formats of\n <tt>\\ref VX_DF_IMAGE_NV12</tt>, <tt>\\ref VX_DF_IMAGE_NV21</tt>, <tt>\\ref VX_DF_IMAGE_IYUV</tt>,\n <tt>\\ref VX_DF_IMAGE_UYVY</tt>, <tt>\\ref VX_DF_IMAGE_YUYV</tt> must have even width.\n \\param [in] height The image height in pixels. The image in the formats of\n <tt>\\ref VX_DF_IMAGE_NV12</tt>, <tt>\\ref VX_DF_IMAGE_NV21</tt>,\n <tt>\\ref VX_DF_IMAGE_IYUV</tt> must have even height.\n \\param [in] color The VX_DF_IMAGE (\\ref vx_df_image_e) code that represents the format of the image and the color space.\n \\param [in] value The pointer to the pixel value to which to set all pixels. See <tt>\\ref vx_pixel_value_t</tt>.\n \\returns An image reference <tt>\\ref vx_image</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n <tt>\\see vxMapImagePatch</tt> to obtain direct memory access to the image data.\n \\note <tt>\\ref vxMapImagePatch</tt> and <tt>\\ref vxUnmapImagePatch</tt> may be called with\n a uniform image reference.\n \\ingroup group_image"]
    pub fn vxCreateUniformImage(
        context: vx_context,
        width: vx_uint32,
        height: vx_uint32,
        color: vx_df_image,
        value: *const vx_pixel_value_t,
    ) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to an image buffer with no direct\n user access. This function allows setting the image width, height, or format.\n \\details Virtual data objects allow users to connect various nodes within a\n graph via data references without access to that data, but they also permit the\n implementation to take maximum advantage of possible optimizations. Use this\n API to create a data reference to link two or more nodes together when the\n intermediate data are not required to be accessed by outside entities. This API\n in particular allows the user to define the image format of the data without\n requiring the exact dimensions. Virtual objects are scoped within the graph\n they are declared a part of, and can't be shared outside of this scope.\n All of the following constructions of virtual images are valid.\n \\code\n vx_context context = vxCreateContext();\n vx_graph graph = vxCreateGraph(context);\n vx_image virt[] = {\n     vxCreateVirtualImage(graph, 0, 0, VX_DF_IMAGE_U8), // no specified dimension\n     vxCreateVirtualImage(graph, 320, 240, VX_DF_IMAGE_VIRT), // no specified format\n     vxCreateVirtualImage(graph, 640, 480, VX_DF_IMAGE_U8), // no user access\n };\n \\endcode\n \\param [in] graph The reference to the parent graph.\n \\param [in] width The width of the image in pixels. A value of zero informs the interface\n that the value is unspecified. The image in the formats of <tt>\\ref VX_DF_IMAGE_NV12</tt>,\n <tt>\\ref VX_DF_IMAGE_NV21</tt>, <tt>\\ref VX_DF_IMAGE_IYUV</tt>, <tt>\\ref VX_DF_IMAGE_UYVY</tt>,\n <tt>\\ref VX_DF_IMAGE_YUYV</tt> must have even width.\n \\param [in] height The height of the image in pixels. A value of zero informs the interface\n that the value is unspecified. The image in the formats of <tt>\\ref VX_DF_IMAGE_NV12</tt>,\n <tt>\\ref VX_DF_IMAGE_NV21</tt>, <tt>\\ref VX_DF_IMAGE_IYUV</tt> must have even height.\n \\param [in] color The VX_DF_IMAGE (<tt>\\ref vx_df_image_e</tt>) code that represents the format\n of the image and the color space. A value of <tt>\\ref VX_DF_IMAGE_VIRT</tt> informs the\n interface that the format is unspecified.\n \\returns An image reference <tt>\\ref vx_image</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note Passing this reference to <tt>\\ref vxMapImagePatch</tt> will return an error.\n \\ingroup group_image"]
    pub fn vxCreateVirtualImage(
        graph: vx_graph,
        width: vx_uint32,
        height: vx_uint32,
        color: vx_df_image,
    ) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Creates a reference to an image object that was externally allocated.\n \\param [in] context The reference to the implementation context.\n \\param [in] color See the <tt>\\ref vx_df_image_e</tt> codes. This mandates the\n number of planes needed to be valid in the \\a addrs and \\a ptrs arrays based on the format given.\n \\param [in] addrs[] The array of image patch addressing structures that\n define the dimension and stride of the array of pointers. See note below.\n \\param [in] ptrs[] The array of platform-defined references to each plane. See note below.\n \\param [in] memory_type <tt>\\ref vx_memory_type_e</tt>. When giving <tt>\\ref VX_MEMORY_TYPE_HOST</tt>\n the \\a ptrs array is assumed to be HOST accessible pointers to memory.\n \\returns An image reference <tt>\\ref vx_image</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note The user must call vxMapImagePatch prior to accessing the pixels of an image, even if the\n image was created via <tt>\\ref vxCreateImageFromHandle</tt>. Reads or writes to memory referenced\n by ptrs[ ] after calling <tt>\\ref vxCreateImageFromHandle</tt> without first calling\n <tt>\\ref vxMapImagePatch</tt> will result in undefined behavior.\n The property of addr[] and ptrs[] arrays is kept by the caller (It means that the implementation will\n make an internal copy of the provided information. \\a addr and \\a ptrs can then simply be application's\n local variables).\n Only \\a dim_x, \\a dim_y, \\a stride_x and \\a stride_y fields of the <tt>\\ref vx_imagepatch_addressing_t</tt> need to be\n provided by the application. Other fields (\\a step_x, \\a step_y, \\a scale_x & \\a scale_y) are ignored by this function.\n The layout of the imported memory must follow a row-major order. In other words, \\a stride_x should be\n sufficiently large so that there is no overlap between data elements corresponding to different\n pixels, and \\a stride_y >= \\a stride_x * \\a dim_x.\n\n In order to release the image back to the application we should use <tt>\\ref vxSwapImageHandle</tt>.\n An exception is for <tt>\\ref VX_DF_IMAGE_U1</tt> images where \\a stride_x == 0 and instead\n \\a stride_y >= &lceil;\\a dim_x / 8&rceil;.\n\n Import type of the created image is available via the image attribute <tt>\\ref vx_image_attribute_e</tt> parameter.\n\n \\ingroup group_image"]
    pub fn vxCreateImageFromHandle(
        context: vx_context,
        color: vx_df_image,
        addrs: *const vx_imagepatch_addressing_t,
        ptrs: *const *mut ::std::os::raw::c_void,
        memory_type: vx_enum,
    ) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Swaps the image handle of an image previously created from handle.\n\n This function sets the new image handle (i.e. pointer to all image planes)\n and returns the previous one.\n\n Once this function call has completed, the application gets back the\n ownership of the memory referenced by the previous handle. This memory\n contains up-to-date pixel data, and the application can safely reuse or\n release it.\n\n The memory referenced by the new handle must have been allocated\n consistently with the image properties since the import type,\n memory layout and dimensions are unchanged (see addrs, color, and\n memory_type in <tt>\\ref vxCreateImageFromHandle</tt>).\n\n All images created from ROI or channel with this image as parent or ancestor\n will automatically use the memory referenced by the new handle.\n\n The behavior of <tt>\\ref vxSwapImageHandle</tt> when called from a user node is undefined.\n \\param [in] image The reference to an image created from handle\n \\param [in] new_ptrs[] pointer to a caller owned array that contains\n the new image handle (image plane pointers)\n \\arg new_ptrs is non NULL. new_ptrs[i] must be non NULL for each i such as\n 0 < i < nbPlanes, otherwise, this is an error. The address of the storage memory\n for image plane i is set to new_ptrs[i]\n \\arg new_ptrs is NULL: the previous image storage memory is reclaimed by the\n caller, while no new handle is provided.\n \\param [out] prev_ptrs[] pointer to a caller owned array in which\n the application returns the previous image handle\n \\arg prev_ptrs is non NULL. prev_ptrs must have at least as many\n elements as the number of image planes. For each i such as\n 0 < i < nbPlanes , prev_ptrs[i] is set to the address of the previous storage\n memory for plane i.\n \\arg prev_ptrs NULL: the previous handle is not returned.\n \\param [in] num_planes Number of planes in the image. This must be set equal to the number of planes of the input image.\n  The number of elements in new_ptrs and prev_ptrs arrays must be equal to or greater than num_planes.\n If either array has more than num_planes elements, the extra elements are ignored. If either array is smaller\n than num_planes, the results are undefined.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n reference.\n \\retval VX_ERROR_INVALID_PARAMETERS The image was not created from handle or\n the content of new_ptrs is not valid.\n \\retval VX_FAILURE The image was already being accessed.\n \\ingroup group_image"]
    pub fn vxSwapImageHandle(
        image: vx_image,
        new_ptrs: *const *mut ::std::os::raw::c_void,
        prev_ptrs: *mut *mut ::std::os::raw::c_void,
        num_planes: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves various attributes of an image.\n \\param [in] image The reference to the image to query.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_image_attribute_e</tt>.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\retval VX_ERROR_NOT_SUPPORTED If the attribute is not supported on this implementation.\n \\ingroup group_image"]
    pub fn vxQueryImage(
        image: vx_image,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows setting attributes on the image.\n \\param [in] image The reference to the image on which to set the attribute.\n \\param [in] attribute The attribute to set. Use a <tt>\\ref vx_image_attribute_e</tt> enumeration.\n \\param [in] ptr The pointer to the location from which to read the value.\n \\param [in] size The size in bytes of the object pointed to by \\a ptr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\ingroup group_image"]
    pub fn vxSetImageAttribute(
        image: vx_image,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Initialize an image with the given pixel value.\n \\param [in] image The reference to the image to initialize.\n \\param [in] pixel_value The pointer to the constant pixel value to initialize all image pixels. See <tt>\\ref vx_pixel_value_t</tt>.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE If the image is a uniform image, a virtual image, or not a <tt>\\ref vx_image</tt>.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\note All pixels of the entire image are initialized to the indicated pixel value, independently from the valid region.\n The valid region of the image is unaffected by this function. The image remains mutable after the call to this function,\n so its pixels and mutable attributes may be changed by subsequent functions.\n \\ingroup group_image"]
    pub fn vxSetImagePixelValues(
        image: vx_image,
        pixel_value: *const vx_pixel_value_t,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Releases a reference to an image object.\n The object may not be garbage collected until its total reference count is zero.\n\n An implementation may defer the actual object destruction after its total\n reference count is zero (potentially until context destruction). Thus,\n releasing an image created from handle\n (see <tt>\\ref vxCreateImageFromHandle</tt>) and all others objects that may\n reference it (nodes, ROI, or channel for instance) are not sufficient to get back the\n ownership of the memory referenced by the current image handle. The only way\n for this is to call <tt>\\ref vxSwapImageHandle</tt>) before releasing the\n image.\n\n \\param [in] image The pointer to the image to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\ingroup group_image"]
    pub fn vxReleaseImage(image: *mut vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Accesses a specific indexed pixel in an image patch.\n \\param [in] ptr The base pointer of the patch as returned from <tt>\\ref vxMapImagePatch</tt>.\n \\param [in] index The 0 based index of the pixel count in the patch. Indexes increase horizontally by 1 then wrap around to the next row.\n \\param [in] addr The pointer to the addressing mode information returned from <tt>\\ref vxMapImagePatch</tt>.\n \\return void * Returns the pointer to the specified pixel.\n \\pre <tt>\\ref vxMapImagePatch</tt>\n \\note Some special restrictions apply to <tt>\\ref VX_DF_IMAGE_U1</tt> images.\n \\ingroup group_image"]
    pub fn vxFormatImagePatchAddress1d(
        ptr: *mut ::std::os::raw::c_void,
        index: vx_uint32,
        addr: *const vx_imagepatch_addressing_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Accesses a specific pixel at a 2d coordinate in an image patch.\n \\param [in] ptr The base pointer of the patch as returned from <tt>\\ref vxMapImagePatch</tt>.\n \\param [in] x The x dimension within the patch.\n \\param [in] y The y dimension within the patch.\n \\param [in] addr The pointer to the addressing mode information returned from <tt>\\ref vxMapImagePatch</tt>.\n \\return void * Returns the pointer to the specified pixel.\n \\pre <tt>\\ref vxMapImagePatch</tt>\n \\note Some special restrictions apply to <tt>\\ref VX_DF_IMAGE_U1</tt> images.\n \\ingroup group_image"]
    pub fn vxFormatImagePatchAddress2d(
        ptr: *mut ::std::os::raw::c_void,
        x: vx_uint32,
        y: vx_uint32,
        addr: *const vx_imagepatch_addressing_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Retrieves the valid region of the image as a rectangle.\n \\param [in] image The image from which to retrieve the valid region.\n \\param [out] rect The destination rectangle.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS Invalid rect.\n \\note This rectangle can be passed directly to <tt>\\ref vxMapImagePatch</tt> to get\n the full valid region of the image.\n \\note Some special restrictions apply to <tt>\\ref VX_DF_IMAGE_U1</tt> images.\n \\ingroup group_image"]
    pub fn vxGetValidRegionImage(image: vx_image, rect: *mut vx_rectangle_t) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy a rectangular patch from/into an image object plane.\n \\param [in] image The reference to the image object that is the source or the\n destination of the copy.\n \\param [in] image_rect The coordinates of the image patch. The patch must be within\n the bounds of the image. (start_x, start_y) gives the coordinates of the topleft\n pixel inside the patch, while (end_x, end_y) gives the coordinates of the bottomright\n element out of the patch. Must be 0 <= start < end <= number of pixels in the image dimension.\n \\param [in] image_plane_index The plane index of the image object that is the source or the\n destination of the patch copy.\n \\param [in] user_addr The address of a structure describing the layout of the\n user memory location pointed by user_ptr. In the structure, only dim_x, dim_y,\n stride_x and stride_y fields must be provided, other fields are ignored by the function.\n The layout of the user memory must follow a row major order:\n stride_x >= pixel size in bytes, and stride_y >= stride_x * dim_x.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the image\n object if the copy was requested in write mode. The accessible memory must be large enough\n to contain the specified patch with the specified layout:\n accessible memory in bytes >= (end_y - start_y) * stride_y.\n \\param [in] usage This declares the effect of the copy with regard to the image object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. For uniform images, only VX_READ_ONLY\n is supported. For other images, Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt> are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data is copied from the image object into the application memory\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data is copied into the image object from the application memory\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual image that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\note The application may ask for data outside the bounds of the valid region, but\n such data has an undefined value.\n \\note Some special restrictions apply to <tt>\\ref VX_DF_IMAGE_U1</tt> images.\n \\ingroup group_image"]
    pub fn vxCopyImagePatch(
        image: vx_image,
        image_rect: *const vx_rectangle_t,
        image_plane_index: vx_uint32,
        user_addr: *const vx_imagepatch_addressing_t,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to a rectangular patch of an image object plane.\n \\param [in] image The reference to the image object that contains the patch to map.\n \\param [in] rect The coordinates of image patch. The patch must be within the\n bounds of the image. (start_x, start_y) gives the coordinate of the topleft\n element inside the patch, while (end_x, end_y) give the coordinate of\n the bottomright element out of the patch. Must be 0 <= start < end.\n \\param [in] plane_index The plane index of the image object to be accessed.\n \\param [out] map_id The address of a <tt>\\ref vx_map_id</tt> variable where the function\n returns a map identifier.\n \\arg (*map_id) must eventually be provided as the map_id parameter of a call to\n <tt>\\ref vxUnmapImagePatch</tt>.\n \\param [out] addr The address of a <tt>\\ref vx_imagepatch_addressing_t</tt> structure\n describing the memory layout of the image patch to access. The function fills the\n structure pointed by addr with the layout information that the application must\n consult to access the pixel data at address (*ptr). The layout of the mapped memory\n follows a row-major order: stride_x>0, stride_y>0 and stride_y >= stride_x * dim_x.\n An exception is for <tt>\\ref VX_DF_IMAGE_U1</tt> where \\a stride_x == 0,\n _stride_x_bits_ > 0 and _stride_y_ {geq} (_stride_x_bits_ * _dim_x_ + 7) / 8\n (i.e., at least the number of bytes needed to hold _dim_x_ pixels).\n If the image object being accessed was created via\n <tt>\\ref vxCreateImageFromHandle</tt>, then the returned memory layout will be\n the identical to that of the addressing structure provided when\n <tt>\\ref vxCreateImageFromHandle</tt> was called.\n \\param [out] ptr The address of a pointer that the function sets to the\n address where the requested data can be accessed. This returned (*ptr) address\n is only valid between the call to this function and the corresponding call to\n <tt>\\ref vxUnmapImagePatch</tt>.\n If image was created via <tt>\\ref vxCreateImageFromHandle</tt> then the returned\n address (*ptr) will be the address of the patch in the original pixel buffer\n provided when image was created.\n \\param [in] usage This declares the access mode for the image patch, using\n the <tt>\\ref vx_accessor_e</tt> enumeration. For uniform images, only VX_READ_ONLY\n is supported.\n \\arg <tt>\\ref VX_READ_ONLY</tt>: after the function call, the content of the memory location\n pointed by (*ptr) contains the image patch data. Writing into this memory location\n is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_READ_AND_WRITE</tt>: after the function call, the content of the memory\n location pointed by (*ptr) contains the image patch data; writing into this memory\n is allowed only for the location of pixels only and will result in a modification\n of the written pixels in the image object once the patch is unmapped. Writing into\n a gap between pixels (when addr->stride_x > pixel size in bytes or addr->stride_y > addr->stride_x*addr->dim_x)\n is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt>: after the function call, the memory location pointed by (*ptr)\n contains undefined data; writing each pixel of the patch is required prior to\n unmapping. Pixels not written by the application before unmap will become\n undefined after unmap, even if they were well defined before map. Like for\n VX_READ_AND_WRITE, writing into a gap between pixels is forbidden and its behavior\n is undefined.\n \\param [in] mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory where the image patch is requested to be mapped.\n \\param [in] flags An integer that allows passing options to the map operation.\n Use the <tt>\\ref vx_map_flag_e</tt> enumeration.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual image that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\note The user may ask for data outside the bounds of the valid region, but\n such data has an undefined value.\n \\ingroup group_image\n \\post <tt>\\ref vxUnmapImagePatch </tt> with same (*map_id) value."]
    pub fn vxMapImagePatch(
        image: vx_image,
        rect: *const vx_rectangle_t,
        plane_index: vx_uint32,
        map_id: *mut vx_map_id,
        addr: *mut vx_imagepatch_addressing_t,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
        mem_type: vx_enum,
        flags: vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to a image object patch that were previously mapped.\n Unmapping an image patch invalidates the memory location from which the patch could\n be accessed by the application. Accessing this memory location after the unmap function\n completes has an undefined behavior.\n \\param [in] image The reference to the image object to unmap.\n \\param [out] map_id The unique map identifier that was returned by <tt>\\ref vxMapImagePatch</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_image\n \\pre <tt>\\ref vxMapImagePatch</tt> with same map_id value"]
    pub fn vxUnmapImagePatch(image: vx_image, map_id: vx_map_id) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Create a sub-image from a single plane channel of another image.\n\n The sub-image refers to the data in the original image. Updates to this image\n update the parent image and reversely.\n\n The function supports only channels that occupy an entire plane of a multi-planar\n images, as listed below. Other cases are not supported.\n     VX_CHANNEL_Y from YUV4, IYUV, NV12, NV21\n     VX_CHANNEL_U from YUV4, IYUV\n     VX_CHANNEL_V from YUV4, IYUV\n\n \\param [in] img          The reference to the parent image.\n \\param [in] channel      The <tt>\\ref vx_channel_e</tt> channel to use.\n\n \\returns An image reference <tt>\\ref vx_image</tt> to the sub-image. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_image"]
    pub fn vxCreateImageFromChannel(img: vx_image, channel: vx_enum) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Sets the valid rectangle for an image according to a supplied rectangle.\n \\note Setting or changing the valid region from within a user node by means other than the call-back, for\n example by calling <tt>\\ref vxSetImageValidRectangle</tt>, might result in an incorrect valid region calculation\n by the framework.\n \\param [in] image  The reference to the image.\n \\param [in] rect   The value to be set to the image valid rectangle. A NULL indicates that the valid region is the entire image.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS The rect does not define a proper valid rectangle.\n \\ingroup group_image"]
    pub fn vxSetImageValidRectangle(image: vx_image, rect: *const vx_rectangle_t) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Registers a module with kernels in a context.\n \\details This function registers the appropriate publish and unpublish functions\n with the module name if the module is not a dynamic library, so <tt>\\ref vxLoadKernels</tt> and\n <tt>\\ref vxUnloadKernels</tt> can be called.\n \\param [in] context The reference to the context the kernels must be added to.\n \\param [in] module The short name of the module to load.\n \\param [in] publish must add kernels to the context by calling <tt>\\ref vxAddUserKernel</tt>\n for each new kernel. It is called by <tt>\\ref vxLoadKernels</tt>.\n \\param [in] unpublish must remove kernels from the context by calling <tt>\\ref vxRemoveKernel</tt>\n for each kernel the <tt>vxPublishKernels</tt> has added. It is called by <tt>\\ref vxUnloadKernels</tt>.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\ingroup group_user_kernels\n \\see vxLoadKernels"]
    pub fn vxRegisterKernelLibrary(
        context: vx_context,
        module: *const vx_char,
        publish: vx_publish_kernels_f,
        unpublish: vx_unpublish_kernels_f,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Loads a library of kernels, called module, into a context.\n\n The module must be registered by <tt>vxRegisterKernelLibrary</tt> if it is not\n a dynamic library or the module must be a dynamic library with by convention, two exported functions\n named <tt>vxPublishKernels</tt> and <tt>vxUnpublishKernels</tt>.\n\n <tt>vxPublishKernels</tt> must have type <tt>\\ref vx_publish_kernels_f</tt>,\n and must add kernels to the context by calling <tt>\\ref vxAddUserKernel</tt>\n for each new kernel. <tt>vxPublishKernels</tt> is called by <tt>\\ref vxLoadKernels</tt>.\n\n <tt>vxUnpublishKernels</tt> must have type <tt>\\ref vx_unpublish_kernels_f</tt>,\n and must remove kernels from the context by calling <tt>\\ref vxRemoveKernel</tt>\n for each kernel the <tt>vxPublishKernels</tt> has added.\n <tt>vxUnpublishKernels</tt> is called by <tt>\\ref vxUnloadKernels</tt>.\n\n \\note When all references to loaded kernels are released, the module\n may be automatically unloaded.\n \\param [in] context The reference to the context the kernels must be added to.\n \\param [in] module The short name of the module to load. On systems where\n there are specific naming conventions for modules, the name passed\n should ignore such conventions. For example: \\c libxyz.so should be\n passed as just \\c xyz and the implementation will <i>do the right thing</i> that\n the platform requires.\n \\note This API uses the system pre-defined paths for modules.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\ingroup group_user_kernels\n \\pre <tt>\\ref vxRegisterKernelLibrary</tt> if the module is not a dynamic library\n \\see vxGetKernelByName"]
    pub fn vxLoadKernels(context: vx_context, module: *const vx_char) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unloads all kernels from the OpenVX context that had been loaded from\n the module using the \\ref vxLoadKernels function.\n\n The kernel unloading is performed by calling the <tt>vxUnpublishKernels</tt>\n exported function of the module.\n \\note <tt>vxUnpublishKernels</tt> is defined in the description of\n <tt>\\ref vxLoadKernels</tt>.\n\n \\param [in] context The reference to the context the kernels must be removed from.\n \\param [in] module The short name of the module to unload. On systems where\n there are specific naming conventions for modules, the name passed\n should ignore such conventions. For example: \\c libxyz.so should be\n passed as just \\c xyz and the implementation will <i>do the right thing</i>\n that the platform requires.\n \\note This API uses the system pre-defined paths for modules.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE context is not a valid <tt>\\ref vx_context</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are\nincorrect.\n \\ingroup group_user_kernels\n \\see vxLoadKernels"]
    pub fn vxUnloadKernels(context: vx_context, module: *const vx_char) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Obtains a reference to a kernel using a string to specify the name.\n \\details User Kernels follow a \"dotted\" heirarchical syntax. For example:\n \"com.company.example.xyz\". The following are strings specifying the kernel names:\n\n org.khronos.openvx.color_convert\n\n org.khronos.openvx.channel_extract\n\n org.khronos.openvx.channel_combine\n\n org.khronos.openvx.sobel_3x3\n\n org.khronos.openvx.magnitude\n\n org.khronos.openvx.phase\n\n org.khronos.openvx.scale_image\n\n org.khronos.openvx.table_lookup\n\n org.khronos.openvx.histogram\n\n org.khronos.openvx.equalize_histogram\n\n org.khronos.openvx.absdiff\n\n org.khronos.openvx.mean_stddev\n\n org.khronos.openvx.threshold\n\n org.khronos.openvx.integral_image\n\n org.khronos.openvx.dilate_3x3\n\n org.khronos.openvx.erode_3x3\n\n org.khronos.openvx.median_3x3\n\n org.khronos.openvx.box_3x3\n\n org.khronos.openvx.gaussian_3x3\n\n org.khronos.openvx.custom_convolution\n\n org.khronos.openvx.gaussian_pyramid\n\n org.khronos.openvx.minmaxloc\n\n org.khronos.openvx.convertdepth\n\n org.khronos.openvx.canny_edge_detector\n\n org.khronos.openvx.and\n\n org.khronos.openvx.or\n\n org.khronos.openvx.xor\n\n org.khronos.openvx.not\n\n org.khronos.openvx.multiply\n\n org.khronos.openvx.add\n\n org.khronos.openvx.subtract\n\n org.khronos.openvx.warp_affine\n\n org.khronos.openvx.warp_perspective\n\n org.khronos.openvx.harris_corners\n\n org.khronos.openvx.fast_corners\n\n org.khronos.openvx.optical_flow_pyr_lk\n\n org.khronos.openvx.remap\n\n org.khronos.openvx.halfscale_gaussian\n\n org.khronos.openvx.laplacian_pyramid\n\n org.khronos.openvx.laplacian_reconstruct\n\n org.khronos.openvx.non_linear_filter\n\n org.khronos.openvx.match_template\n\n org.khronos.openvx.lbp\n\n org.khronos.openvx.hough_lines_p\n\n org.khronos.openvx.tensor_multiply\n\n org.khronos.openvx.tensor_add\n\n org.khronos.openvx.tensor_subtract\n\n org.khronos.openvx.tensor_table_lookup\n\n org.khronos.openvx.tensor_transpose\n\n org.khronos.openvx.tensor_convert_depth\n\n org.khronos.openvx.tensor_matrix_multiply\n\n org.khronos.openvx.copy\n\n org.khronos.openvx.non_max_suppression\n\n org.khronos.openvx.scalar_operation\n\n org.khronos.openvx.hog_features\n\n org.khronos.openvx.hog_cells\n\n org.khronos.openvx.bilateral_filter\n\n org.khronos.openvx.select\n\n org.khronos.openvx.min\n\n org.khronos.openvx.max\n\n org.khronos.openvx.weighted_average\n\n \\param [in] context The reference to the implementation context.\n \\param [in] name The string of the name of the kernel to get.\n \\return A kernel reference. Any possible errors preventing a successful\n completion of the function should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_kernel\n \\pre <tt>\\ref vxLoadKernels</tt> if the kernel is not provided by the\n OpenVX implementation.\n \\note User Kernels should follow a \"dotted\" hierarchical syntax. For example:\n \"com.company.example.xyz\"."]
    pub fn vxGetKernelByName(context: vx_context, name: *const vx_char) -> vx_kernel;
}
extern "C" {
    #[doc = " \\brief Obtains a reference to the kernel using the <tt>\\ref vx_kernel_e</tt> enumeration.\n \\details Enum values above the standard set are assumed to apply to\n loaded libraries.\n \\param [in] context The reference to the implementation context.\n \\param [in] kernel A value from <tt>\\ref vx_kernel_e</tt> or a vendor or client-defined value.\n \\return A <tt>\\ref vx_kernel</tt> reference. Any possible errors preventing a successful completion\n of the function should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_kernel\n \\pre <tt>\\ref vxLoadKernels</tt> if the kernel is not provided by the\n OpenVX implementation."]
    pub fn vxGetKernelByEnum(context: vx_context, kernel: vx_enum) -> vx_kernel;
}
extern "C" {
    #[doc = " \\brief This allows the client to query the kernel to get information about\n the number of parameters, enum values, etc.\n \\param [in] kernel The kernel reference to query.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_kernel_attribute_e</tt>.\n \\param [out] ptr The pointer to the location at which to store the resulting value.\n \\param [in] size The size of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid <tt>\\ref vx_kernel</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\retval VX_ERROR_NOT_SUPPORTED If the attribute value is not supported in this implementation.\n \\ingroup group_kernel"]
    pub fn vxQueryKernel(
        kernel: vx_kernel,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Release the reference to the kernel.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] kernel The pointer to the kernel reference to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid <tt>\\ref vx_kernel</tt> reference.\n \\ingroup group_kernel"]
    pub fn vxReleaseKernel(kernel: *mut vx_kernel) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows users to add custom kernels to a context at run-time.\n \\param [in] context The reference to the context the kernel must be added to.\n \\param [in] name The string to use to match the kernel.  The length of the string\n shall be lower than VX_MAX_KERNEL_NAME bytes.\n \\param [in] enumeration The enumerated value of the kernel to be used by clients.\n \\param [in] func_ptr The process-local function pointer to be invoked.\n \\param [in] numParams The number of parameters for this kernel.\n \\param [in] validate The pointer to <tt>\\ref vx_kernel_validate_f</tt>, which validates\n parameters to this kernel.\n \\param [in] init The kernel initialization function.\n \\param [in] deinit The kernel de-initialization function.\n \\return A <tt>\\ref vx_kernel</tt> reference. Any possible errors\n preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_user_kernels"]
    pub fn vxAddUserKernel(
        context: vx_context,
        name: *const vx_char,
        enumeration: vx_enum,
        func_ptr: vx_kernel_f,
        numParams: vx_uint32,
        validate: vx_kernel_validate_f,
        init: vx_kernel_initialize_f,
        deinit: vx_kernel_deinitialize_f,
    ) -> vx_kernel;
}
extern "C" {
    #[doc = " \\brief This API is called after all parameters have been added to the\n kernel and the kernel is \\e ready to be used. Notice that the reference to the kernel created\n by vxAddUserKernel is still valid after the call to vxFinalizeKernel.\n If an error occurs, the kernel is not available for usage by the clients of OpenVX. Typically\n this is due to a mismatch between the number of parameters requested and given.\n \\param [in] kernel The reference to the loaded kernel from <tt>\\ref vxAddUserKernel</tt>.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid <tt>\\ref vx_kernel</tt> reference.\n \\pre <tt>\\ref vxAddUserKernel</tt> and <tt>\\ref vxAddParameterToKernel</tt>\n \\ingroup group_user_kernels"]
    pub fn vxFinalizeKernel(kernel: vx_kernel) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows users to set the signatures of the custom kernel.\n \\param [in] kernel The reference to the kernel added with <tt>\\ref vxAddUserKernel</tt>.\n \\param [in] index The index of the parameter to add.\n \\param [in] dir The direction of the parameter. This must be either <tt>\\ref VX_INPUT</tt> or\n <tt>\\ref VX_OUTPUT</tt>.\n \\param [in] data_type The type of parameter. This must be a value from <tt>\\ref vx_type_e</tt>.\n \\param [in] state The state of the parameter (required or not). This must be a value from <tt>\\ref vx_parameter_state_e</tt>.\n \\return A <tt>\\ref vx_status_e</tt> enumerated value.\n \\retval VX_SUCCESS Parameter is successfully set on kernel; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid <tt>\\ref vx_kernel</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If the parameter is not valid for any reason.\n \\pre <tt>\\ref vxAddUserKernel</tt>\n \\ingroup group_user_kernels"]
    pub fn vxAddParameterToKernel(
        kernel: vx_kernel,
        index: vx_uint32,
        dir: vx_enum,
        data_type: vx_enum,
        state: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Removes a custom kernel from its context and releases it.\n \\param [in] kernel The reference to the kernel to remove. Returned from <tt>\\ref vxAddUserKernel</tt>.\n \\note Any kernel enumerated in the base standard\n cannot be removed; only kernels added through <tt>\\ref vxAddUserKernel</tt> can\n be removed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration. The function returns to the\n application full control over the memory resources provided at the kernel creation time.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid <tt>\\ref vx_kernel</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS If a base kernel is passed in.\n \\retval VX_FAILURE If the application has not released all references to the kernel\n object OR if the application has not released all references to a node that is using\n this kernel OR if the application has not released all references to a graph which\n has nodes that is using this kernel.\n \\ingroup group_user_kernels"]
    pub fn vxRemoveKernel(kernel: vx_kernel) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets kernel attributes.\n \\param [in] kernel The reference to the kernel.\n \\param [in] attribute The enumeration of the attributes. See <tt>\\ref vx_kernel_attribute_e</tt>.\n \\param [in] ptr The pointer to the location from which to read the attribute.\n \\param [in] size The size in bytes of the data area indicated by \\a ptr in bytes.\n \\note After a kernel has been passed to <tt>\\ref vxFinalizeKernel</tt>, no attributes\n can be altered.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid <tt>\\ref vx_kernel</tt> reference.\n \\ingroup group_user_kernels"]
    pub fn vxSetKernelAttribute(
        kernel: vx_kernel,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves a <tt>\\ref vx_parameter</tt> from a <tt>\\ref vx_kernel</tt>.\n \\param [in] kernel The reference to the kernel.\n \\param [in] index The index of the parameter.\n \\return A <tt>\\ref vx_parameter</tt> reference. Any possible errors preventing a\n successful completion of the function should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_parameter"]
    pub fn vxGetKernelParameterByIndex(kernel: vx_kernel, index: vx_uint32) -> vx_parameter;
}
extern "C" {
    #[doc = " \\brief Creates an empty graph.\n \\param [in] context The reference to the implementation context.\n \\returns A graph reference <tt>\\ref vx_graph</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_graph"]
    pub fn vxCreateGraph(context: vx_context) -> vx_graph;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a graph.\n The object may not be garbage collected until its total reference count is zero.\n Once the reference count is zero, all node references in the graph are automatically\n released as well. Releasing the graph will only release the nodes if the nodes were\n not previously released by the application. Data referenced by those nodes may not\n be released as the user may still have references to the data.\n \\param [in] graph The pointer to the graph to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\ingroup group_graph"]
    pub fn vxReleaseGraph(graph: *mut vx_graph) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Verifies the state of the graph before it is executed.\n This is useful to catch programmer errors and contract errors. If not verified,\n the graph verifies before being processed.\n \\pre Memory for data objects is not guarenteed to exist before\n this call. \\post After this call data objects exist unless\n the implementation optimized them out.\n \\param [in] graph The reference to the graph to verify.\n \\return A status code for graphs with more than one error; it is\n undefined which error will be returned. Register a log callback using <tt>\\ref vxRegisterLogCallback</tt>\n to receive each specific error in the graph.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\retval VX_ERROR_MULTIPLE_WRITERS If the graph contains more than one writer\n to any data object.\n \\retval VX_ERROR_INVALID_NODE If a node in the graph is invalid or failed be created.\n \\retval VX_ERROR_INVALID_GRAPH If the graph contains cycles or some other invalid topology.\n \\retval VX_ERROR_INVALID_TYPE If any parameter on a node is given the wrong type.\n \\retval VX_ERROR_INVALID_VALUE If any value of any parameter is out of bounds of specification.\n \\retval VX_ERROR_INVALID_FORMAT If the image format is not compatible.\n \\ingroup group_graph\n \\see vxProcessGraph"]
    pub fn vxVerifyGraph(graph: vx_graph) -> vx_status;
}
extern "C" {
    #[doc = " \\brief This function causes the synchronous processing of a graph. If the graph\n has not been verified, then the implementation verifies the graph\n immediately. If verification fails this function returns a status\n identical to what <tt>\\ref vxVerifyGraph</tt> would return. After\n the graph verfies successfully then processing occurs. If the graph was\n previously verified via <tt>\\ref vxVerifyGraph</tt> or <tt>\\ref vxProcessGraph</tt>\n then the graph is processed. This function blocks until the graph is completed.\n \\param [in] graph The graph to execute.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Graph has been processed; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\retval VX_FAILURE A catastrophic error occurred during processing.\n \\ingroup group_graph"]
    pub fn vxProcessGraph(graph: vx_graph) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Schedules a graph for future execution. If the graph\n has not been verified, then the implementation verifies the graph\n immediately. If verification fails this function returns a status\n identical to what <tt>\\ref vxVerifyGraph</tt> would return. After\n the graph verfies successfully then processing occurs. If the graph was\n previously verified via <tt>\\ref vxVerifyGraph</tt> or <tt>\\ref vxProcessGraph</tt>\n then the graph is processed.\n \\param [in] graph The graph to schedule.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS The graph has been scheduled; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\retval VX_ERROR_NO_RESOURCES The graph cannot be scheduled now.\n \\retval VX_ERROR_NOT_SUFFICIENT The graph is not verified and has failed\n forced verification.\n \\ingroup group_graph"]
    pub fn vxScheduleGraph(graph: vx_graph) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Waits for a specific graph to complete. If the graph has been scheduled multiple\n times since the last call to vxWaitGraph, then vxWaitGraph returns only when the last\n scheduled execution completes.\n \\param [in] graph The graph to wait on.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS The graph has successfully completed execution and its outputs are the\n valid results of the most recent execution; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\retval VX_FAILURE An error occurred or the graph was never scheduled. Output data of the\n graph is undefined.\n \\pre <tt>\\ref vxScheduleGraph</tt>\n \\ingroup group_graph"]
    pub fn vxWaitGraph(graph: vx_graph) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the user to query attributes of the Graph.\n \\param [in] graph The reference to the created graph.\n \\param [in] attribute The <tt>\\ref vx_graph_attribute_e</tt> type needed.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\ingroup group_graph"]
    pub fn vxQueryGraph(
        graph: vx_graph,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the attributes of the Graph to be set to the provided value.\n \\param [in] graph The reference to the graph.\n \\param [in] attribute The <tt>\\ref vx_graph_attribute_e</tt> type needed.\n \\param [in] ptr The location from which to read the value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n \\ingroup group_graph"]
    pub fn vxSetGraphAttribute(
        graph: vx_graph,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Adds the given parameter extracted from a <tt>\\ref vx_node</tt> to the graph.\n \\param [in] graph The graph reference that contains the node.\n \\param [in] parameter The parameter reference to add to the graph from the node.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Parameter added to Graph; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference or parameter is not a valid <tt>\\ref vx_parameter</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS The parameter is of a node not in this\n graph.\n \\ingroup group_graph_parameters"]
    pub fn vxAddParameterToGraph(graph: vx_graph, parameter: vx_parameter) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets a reference to the parameter on the graph. The implementation\n must set this parameter on the originating node as well.\n \\param [in] graph The graph reference.\n \\param [in] index The parameter index.\n \\param [in] value The reference to set to the parameter.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Parameter set to Graph; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference or\n value is not a valid <tt>\\ref vx_reference</tt>.\n \\retval VX_ERROR_INVALID_PARAMETERS The parameter index is out of bounds or the\n dir parameter is incorrect.\n \\ingroup group_graph_parameters"]
    pub fn vxSetGraphParameterByIndex(
        graph: vx_graph,
        index: vx_uint32,
        value: vx_reference,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves a <tt>\\ref vx_parameter</tt> from a <tt>\\ref vx_graph</tt>.\n \\param [in] graph The graph.\n \\param [in] index The index of the parameter.\n \\return <tt>\\ref vx_parameter</tt> reference. Any possible errors preventing a successful\n function completion should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_graph_parameters"]
    pub fn vxGetGraphParameterByIndex(graph: vx_graph, index: vx_uint32) -> vx_parameter;
}
extern "C" {
    #[doc = " \\brief Returns a Boolean to indicate the state of graph verification.\n \\param [in] graph The reference to the graph to check.\n \\return A <tt>\\ref vx_bool</tt> value.\n \\retval vx_true_e The graph is verified.\n \\retval vx_false_e The graph is not verified. It must be verified before\n execution either through <tt>\\ref vxVerifyGraph</tt> or automatically through\n <tt>\\ref vxProcessGraph</tt> or <tt>\\ref vxScheduleGraph</tt>.\n \\ingroup group_graph"]
    pub fn vxIsGraphVerified(graph: vx_graph) -> vx_bool;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a node object for a given kernel.\n \\details This node has no references assigned as parameters after completion.\n The client is then required to set these parameters manually by <tt>\\ref vxSetParameterByIndex</tt>.\n When clients supply their own node creation functions (for use with User Kernels), this is the API\n to use along with the parameter setting API.\n \\param [in] graph The reference to the graph in which this node exists.\n \\param [in] kernel The kernel reference to associate with this new node.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note A call to this API sets all parameters to NULL.\n \\ingroup group_adv_node\n \\post Call <tt>\\ref vxSetParameterByIndex</tt> for as many parameters as needed to be set."]
    pub fn vxCreateGenericNode(graph: vx_graph, kernel: vx_kernel) -> vx_node;
}
extern "C" {
    #[doc = " \\brief Allows a user to query information out of a node.\n \\param [in] node The reference to the node to query.\n \\param [in] attribute Use <tt>\\ref vx_node_attribute_e</tt> value to query for information.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytesin bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS The type or size is incorrect.\n \\ingroup group_node"]
    pub fn vxQueryNode(
        node: vx_node,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows a user to set attribute of a node before Graph Validation.\n \\param [in] node The reference to the node to set.\n \\param [in] attribute Use <tt>\\ref vx_node_attribute_e</tt> value to set the desired attribute.\n \\param [in] ptr The pointer to the desired value of the attribute.\n \\param [in] size The size in bytes of the objects to which \\a ptr points.\n \\note Some attributes are inherited from the <tt>\\ref vx_kernel</tt>, which was used\n to create the node. Some of these can be overridden using this API, notably\n \\ref VX_NODE_LOCAL_DATA_SIZE and \\ref VX_NODE_LOCAL_DATA_PTR.\n \\ingroup group_node\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS The attribute was set; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS size is not correct for the type needed."]
    pub fn vxSetNodeAttribute(
        node: vx_node,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a Node object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] node The pointer to the reference of the node to release.\n \\ingroup group_node\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference."]
    pub fn vxReleaseNode(node: *mut vx_node) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Removes a Node from its parent Graph and releases it.\n \\param [in] node The pointer to the node to remove and release.\n \\ingroup group_node\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference."]
    pub fn vxRemoveNode(node: *mut vx_node) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Assigns a callback to a node.\n If a callback already exists in this node, this function must return an error\n and the user may clear the callback by passing a NULL pointer as the callback.\n \\param [in] node The reference to the node.\n \\param [in] callback The callback to associate with completion of this\n specific node.\n \\warning This must be used with <b><i>extreme</i></b> caution as it can \\e ruin\n optimizations in the power/performance efficiency of a graph.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Callback assigned; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference.\n \\ingroup group_node_callback"]
    pub fn vxAssignNodeCallback(node: vx_node, callback: vx_nodecomplete_f) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves the current node callback function pointer set on the node.\n \\param [in] node The reference to the <tt>\\ref vx_node</tt> object.\n \\ingroup group_node_callback\n \\return vx_nodecomplete_f The pointer to the callback function.\n \\retval NULL No callback is set.\n \\retval * The node callback function."]
    pub fn vxRetrieveNodeCallback(node: vx_node) -> vx_nodecomplete_f;
}
extern "C" {
    #[doc = " \\brief Sets the node target to the provided value. A success invalidates the graph\n that the node belongs to (<tt>\\ref vxVerifyGraph</tt> must be called before the next execution)\n \\param [in] node  The reference to the <tt>\\ref vx_node</tt> object.\n \\param [in] target_enum  The target enum to be set to the <tt>\\ref vx_node</tt> object.\n Use a <tt>\\ref vx_target_e</tt>.\n \\param [in] target_string  The target name ASCII string. This contains a valid value\n when target_enum is set to <tt>\\ref VX_TARGET_STRING</tt>, otherwise it is ignored.\n \\ingroup group_node\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Node target set; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED If the node kernel is not supported by the specified target."]
    pub fn vxSetNodeTarget(
        node: vx_node,
        target_enum: vx_enum,
        target_string: *const ::std::os::raw::c_char,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates replicas of the same node first_node to process a set of objects\n stored in <tt>\\ref vx_pyramid</tt> or <tt>\\ref vx_object_array</tt>.\n first_node needs to have as parameter levels 0 of a <tt>\\ref vx_pyramid</tt> or the index 0 of a <tt>\\ref vx_object_array</tt>.\n Replica nodes are not accessible by the application through any means. An application request for removal of\n first_node from the graph will result in removal of all replicas. Any change of parameter or attribute of\n first_node will be propagated to the replicas. <tt>\\ref vxVerifyGraph</tt> shall enforce consistency of parameters and attributes\n in the replicas.\n \\param [in] graph The reference to the graph.\n \\param [in] first_node The reference to the node in the graph that will be replicated.\n \\param [in] replicate an array of size equal to the number of node parameters, vx_true_e for the parameters\n that should be iterated over (should be a reference to a vx_pyramid or a vx_object_array),\n vx_false_e for the parameters that should be the same across replicated nodes and for optional\n parameters that are not used. Should be vx_true_e for all output parameters.\n \\param [in] number_of_parameters number of elements in the replicate array\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference, or first_node is not a\n valid <tt>\\ref vx_node</tt> reference.\n \\retval VX_ERROR_NOT_COMPATIBLE At least one of replicated parameters is not of level 0 of a pyramid or at index 0 of an object array.\n \\retval VX_FAILURE If the node does not belong to the graph, or the number of objects in the parent objects of inputs and output are not the same.\n \\ingroup group_node"]
    pub fn vxReplicateNode(
        graph: vx_graph,
        first_node: vx_node,
        replicate: *mut vx_bool,
        number_of_parameters: vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves a <tt>\\ref vx_parameter</tt> from a <tt>\\ref vx_node</tt>.\n \\param [in] node The node from which to extract the parameter.\n \\param [in] index The index of the parameter to which to get a reference.\n \\return A parameter reference <tt>\\ref vx_parameter</tt>. Any possible errors preventing a successful\n completion of the function should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_parameter"]
    pub fn vxGetParameterByIndex(node: vx_node, index: vx_uint32) -> vx_parameter;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a parameter object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] param The pointer to the parameter to release.\n \\ingroup group_parameter\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE param is not a valid <tt>\\ref vx_parameter</tt> reference."]
    pub fn vxReleaseParameter(param: *mut vx_parameter) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets the specified parameter data for a kernel on the node.\n \\param [in] node The node that contains the kernel.\n \\param [in] index The index of the parameter desired.\n \\param [in] value The desired value of the parameter.\n \\note A user may not provide a NULL value for a mandatory parameter of this API.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE node is not a valid <tt>\\ref vx_node</tt> reference, or value\n is not a valid <tt>\\ref vx_reference</tt> reference.\n \\ingroup group_parameter\n \\see vxSetParameterByReference"]
    pub fn vxSetParameterByIndex(node: vx_node, index: vx_uint32, value: vx_reference)
        -> vx_status;
}
extern "C" {
    #[doc = " \\brief Associates a parameter reference and a data reference with a kernel\n on a node.\n \\param [in] parameter The reference to the kernel parameter.\n \\param [in] value The value to associate with the kernel parameter.\n \\note A user may not provide a NULL value for a mandatory parameter of this API.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE parameter is not a valid <tt>\\ref vx_parameter</tt> reference,\n or value is not a valid <tt>\\ref vx_reference</tt> reference..\n \\ingroup group_parameter\n \\see vxGetParameterByIndex"]
    pub fn vxSetParameterByReference(parameter: vx_parameter, value: vx_reference) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the client to query a parameter to determine its meta-information.\n \\param [in] parameter The reference to the parameter.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_parameter_attribute_e</tt>.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE parameter is not a valid <tt>\\ref vx_parameter</tt> reference.\n \\ingroup group_parameter"]
    pub fn vxQueryParameter(
        parameter: vx_parameter,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a scalar object. Also see \\ref sub_node_parameters.\n \\param [in] context The reference to the system context.\n \\param [in] data_type The type of data to hold. Must be greater than\n <tt>\\ref VX_TYPE_INVALID</tt> and less than or equal to <tt>\\ref VX_TYPE_VENDOR_STRUCT_END</tt>.\n Or must be a <tt>\\ref vx_enum</tt> returned from <tt>\\ref vxRegisterUserStruct</tt>.\n \\param [in] ptr The pointer to the initial value of the scalar or NULL. If NULL,\n             the initial value of the scalar, if any, is implementation dependent.\n \\ingroup group_scalar\n \\returns A scalar reference <tt>\\ref vx_scalar</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxCreateScalar(
        context: vx_context,
        data_type: vx_enum,
        ptr: *const ::std::os::raw::c_void,
    ) -> vx_scalar;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a scalar object. Also see \\ref sub_node_parameters.\n \\param [in] context The reference to the system context.\n \\param [in] data_type The type of data to hold. Must be greater than\n <tt>\\ref VX_TYPE_INVALID</tt> and less than or equal to <tt>\\ref VX_TYPE_VENDOR_STRUCT_END</tt>.\n Or must be a <tt>\\ref vx_enum</tt> returned from <tt>\\ref vxRegisterUserStruct</tt>.\n \\param [in] ptr The pointer to the initial value of the scalar.\n \\param [in] size Size of data at ptr in bytes.\n \\ingroup group_scalar\n \\returns A scalar reference <tt>\\ref vx_scalar</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxCreateScalarWithSize(
        context: vx_context,
        data_type: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_scalar;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a scalar object with no direct user access.\n \\param [in] graph The reference to the parent graph.\n \\param [in] data_type The type of data to hold. Must be greater than\n <tt>\\ref VX_TYPE_INVALID</tt> and less than or equal to <tt>\\ref VX_TYPE_VENDOR_STRUCT_END</tt>.\n Or must be a <tt>\\ref vx_enum</tt> returned from <tt>\\ref vxRegisterUserStruct</tt>.\n \\see <tt>\\ref vxCreateScalar</tt>\n \\ingroup group_scalar\n \\returns A scalar reference <tt>\\ref vx_scalar</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxCreateVirtualScalar(graph: vx_graph, data_type: vx_enum) -> vx_scalar;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a scalar object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] scalar The pointer to the scalar to release.\n \\ingroup group_scalar\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE scalar is not a valid <tt>\\ref vx_scalar</tt> reference."]
    pub fn vxReleaseScalar(scalar: *mut vx_scalar) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries attributes from a scalar.\n \\param [in] scalar The scalar object.\n \\param [in] attribute The enumeration to query. Use a <tt>\\ref vx_scalar_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE scalar is not a valid <tt>\\ref vx_scalar</tt> reference.\n \\ingroup group_scalar"]
    pub fn vxQueryScalar(
        scalar: vx_scalar,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy from/into a scalar object.\n \\param [in] scalar The reference to the scalar object that is the source or the\n destination of the copy.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the\n scalar object if the copy was requested in write mode. In the user memory, the scalar is\n a variable of the type corresponding to <tt>\\ref VX_SCALAR_TYPE</tt>.\n The accessible memory must be large enough to contain this variable.\n \\param [in] usage This declares the effect of the copy with regard to the scalar object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the scalar object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the scalar object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE scalar is not a valid <tt>\\ref vx_scalar</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_scalar"]
    pub fn vxCopyScalar(
        scalar: vx_scalar,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy from/into a scalar object with size.\n \\param [in] scalar The reference to the scalar object that is the source or the\n destination of the copy.\n \\param [in] size The size in bytes of the container to which \\a user_ptr points.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the\n scalar object if the copy was requested in write mode. In the user memory, the scalar is\n a variable of the type corresponding to <tt>\\ref VX_SCALAR_TYPE</tt>.\n The accessible memory must be large enough to contain this variable.\n \\param [in] usage This declares the effect of the copy with regard to the scalar object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the scalar object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the scalar object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_INVALID_REFERENCE The scalar reference is not actually a scalar reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_scalar"]
    pub fn vxCopyScalarWithSize(
        scalar: vx_scalar,
        size: vx_size,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries any reference type for some basic information like count or type.\n \\param [in] ref The reference to query.\n \\param [in] attribute The value for which to query. Use <tt>\\ref vx_reference_attribute_e</tt>.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE ref is not a valid <tt>\\ref vx_reference</tt> reference.\n \\ingroup group_reference"]
    pub fn vxQueryReference(
        ref_: vx_reference,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Releases a reference. The reference may potentially refer to multiple OpenVX objects of different types.\n This function can be used instead of calling a specific release function for each individual object type\n (e.g. vxRelease<object>). The object will not be destroyed until its total reference count is zero.\n \\note After returning from this function the reference is zeroed.\n \\param [in] ref_ptr The pointer to the reference of the object to release.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE ref_ptr is not a valid <tt>\\ref vx_reference</tt> reference.\n \\ingroup group_reference"]
    pub fn vxReleaseReference(ref_ptr: *mut vx_reference) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Increments the reference counter of an object\n This function is used to express the fact that the OpenVX object is referenced\n multiple times by an application. Each time this function is called for\n an object, the application will need to release the object one additional\n time before it can be destructed\n \\param [in] ref The reference to retain.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE ref is not a valid <tt>\\ref vx_reference</tt> reference.\n \\ingroup group_reference"]
    pub fn vxRetainReference(ref_: vx_reference) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Name a reference\n \\ingroup group_reference\n\n This function is used to associate a name to a referenced object. This name\n can be used by the OpenVX implementation in log messages and any\n other reporting mechanisms.\n\n The OpenVX implementation will not check if the name is unique in\n the reference scope (context or graph). Several references can then\n have the same name.\n\n \\param [in] ref The reference to the object to be named.\n \\param [in] name Pointer to the '\\0' terminated string that identifies\n             the referenced object.\n             The string is copied by the function so that it\n             stays the property of the caller.\n             NULL means that the reference is not named.\n             The length of the string shall be lower than VX_MAX_REFERENCE_NAME bytes.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE ref is not a valid <tt>\\ref vx_reference</tt> reference."]
    pub fn vxSetReferenceName(ref_: vx_reference, name: *const vx_char) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries a <tt>\\ref vx_delay</tt> object attribute.\n \\param [in] delay The reference to a delay object.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_delay_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE delay is not a valid <tt>\\ref vx_delay</tt> reference.\n \\ingroup group_delay"]
    pub fn vxQueryDelay(
        delay: vx_delay,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a delay object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] delay The pointer to the delay object reference to release.\n \\post After returning from this function the reference is zeroed.\n \\ingroup group_delay\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE delay is not a valid <tt>\\ref vx_delay</tt> reference."]
    pub fn vxReleaseDelay(delay: *mut vx_delay) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a Delay object.\n \\details This function creates a delay object with \\p num_slots slots. Each slot\n contains a clone of the exemplar. The clones only inherit the metadata of the\n exemplar. The data content of the exemplar is ignored and the clones have their\n data undefined at delay creation time.\n The function does not alter the exemplar. Also, it doesn't retain or release the\n reference to the exemplar.\n \\note For the definition of metadata attributes see \\ref vxSetMetaFormatAttribute.\n \\param [in] context The reference to the context.\n \\param [in] exemplar The exemplar object. Supported exemplar object types are:<br>\n \\arg \\ref VX_TYPE_ARRAY\n \\arg \\ref VX_TYPE_CONVOLUTION\n \\arg \\ref VX_TYPE_DISTRIBUTION\n \\arg \\ref VX_TYPE_IMAGE\n \\arg \\ref VX_TYPE_LUT\n \\arg \\ref VX_TYPE_MATRIX\n \\arg \\ref VX_TYPE_OBJECT_ARRAY\n \\arg \\ref VX_TYPE_PYRAMID\n \\arg \\ref VX_TYPE_REMAP\n \\arg \\ref VX_TYPE_SCALAR\n \\arg \\ref VX_TYPE_THRESHOLD\n \\arg \\ref VX_TYPE_TENSOR\n \\param [in] num_slots The number of objects in the delay. This value must be greater than zero.\n \\returns A delay reference <tt>\\ref vx_delay</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_delay"]
    pub fn vxCreateDelay(
        context: vx_context,
        exemplar: vx_reference,
        num_slots: vx_size,
    ) -> vx_delay;
}
extern "C" {
    #[doc = " \\brief Retrieves a reference to a delay slot object.\n \\param [in] delay The reference to the delay object.\n \\param [in] index The index of the delay slot from which to extract the object reference.\n \\return <tt>\\ref vx_reference</tt>. Any possible errors preventing a successful\n completion of the function should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note The delay index is in the range \\f$ [-count+1,0] \\f$. 0 is always the\n \\e current object.\n \\ingroup group_delay\n \\note A reference retrieved with this function must not be given to its associated\n release API (e.g. <tt>\\ref vxReleaseImage</tt>) unless <tt>\\ref vxRetainReference</tt> is used."]
    pub fn vxGetReferenceFromDelay(delay: vx_delay, index: vx_int32) -> vx_reference;
}
extern "C" {
    #[doc = " \\brief Shifts the internal delay ring by one.\n\n This function performs a shift of the internal delay ring by one. This means that,\n the data originally at index 0 move to index -1 and so forth until index\n \\f$ -count+1 \\f$. The data originally at index \\f$ -count+1 \\f$ move to index 0.\n Here \\f$ count \\f$ is the number of slots in delay ring.\n When a delay is aged, any graph making use of this delay (delay object itself or data\n objects in delay slots) gets its data automatically updated accordingly.\n \\param [in] delay\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Delay was aged; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE delay is not a valid <tt>\\ref vx_delay</tt> reference.\n \\ingroup group_delay"]
    pub fn vxAgeDelay(delay: vx_delay) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Register a delay for auto-aging.\n\n This function registers a delay object to be auto-aged by the graph.\n This delay object will be automatically aged after each successful completion of\n this graph. Aging of a delay object cannot be called during graph execution.\n A graph abandoned due to a node callback will trigger an auto-aging.\n\n If a delay is registered for auto-aging multiple times in a same graph,\n the delay will be only aged a single time at each graph completion.\n If a delay is registered for auto-aging in multiple graphs, this delay will\n aged automatically after each successful completion of any of these graphs.\n\n \\param [in] graph The graph to which the delay is registered for auto-aging.\n \\param [in] delay The delay to automatically age.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference, or\n delay is not a valid <tt>\\ref vx_delay</tt> reference.\n \\ingroup group_graph"]
    pub fn vxRegisterAutoAging(graph: vx_graph, delay: vx_delay) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Adds a line to the log.\n \\param [in] ref The reference to add the log entry against. Some valid value must be provided.\n \\param [in] status The status code. <tt>\\ref VX_SUCCESS</tt> status entries are ignored and not added.\n \\param [in] message The human readable message to add to the log.\n \\param [in] ... a list of variable arguments to the message.\n \\note Messages may not exceed <tt>\\ref VX_MAX_LOG_MESSAGE_LEN</tt> bytes and will be truncated in the log if they exceed this limit.\n \\ingroup group_log"]
    pub fn vxAddLogEntry(
        ref_: vx_reference,
        status: vx_status,
        message: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " \\brief Registers a callback facility to the OpenVX implementation to receive error logs.\n \\param [in] context The overall context to OpenVX.\n \\param [in] callback The callback function. If NULL, the previous callback is removed.\n \\param [in] reentrant If reentrancy flag is <tt>\\ref vx_true_e</tt>, then the callback may be entered from multiple\n simultaneous tasks or threads (if the host OS supports this).\n \\ingroup group_log"]
    pub fn vxRegisterLogCallback(
        context: vx_context,
        callback: vx_log_callback_f,
        reentrant: vx_bool,
    );
}
extern "C" {
    #[doc = " \\brief Creates LUT object of a given type. The value of <tt>\\ref VX_LUT_OFFSET</tt> is equal to 0\n for data_type = <tt>\\ref VX_TYPE_UINT8</tt>, and (vx_uint32)(count/2) for <tt>\\ref VX_TYPE_INT16</tt>.\n \\param [in] context The reference to the context.\n \\param [in] data_type The type of data stored in the LUT.\n \\param [in] count The number of entries desired.\n \\note data_type can only be \\ref VX_TYPE_UINT8 or \\ref VX_TYPE_INT16. If data_type\n is \\ref VX_TYPE_UINT8, count should be not greater than 256. If data_type is \\ref VX_TYPE_INT16,\n count should not be greater than 65536.\n \\returns An LUT reference <tt>\\ref vx_lut</tt>. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_lut"]
    pub fn vxCreateLUT(context: vx_context, data_type: vx_enum, count: vx_size) -> vx_lut;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a LUT object with no direct user access.\n \\param [in] graph The reference to the parent graph.\n \\param [in] data_type The type of data stored in the LUT.\n \\param [in] count The number of entries desired.\n \\see <tt>\\ref vxCreateLUT</tt>\n \\note data_type can only be \\ref VX_TYPE_UINT8 or \\ref VX_TYPE_INT16. If data_type\n is \\ref VX_TYPE_UINT8, count should be not greater than 256. If data_type is \\ref VX_TYPE_INT16,\n count should not be greater than 65536.\n \\returns An LUT reference <tt>\\ref vx_lut</tt>. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_lut"]
    pub fn vxCreateVirtualLUT(graph: vx_graph, data_type: vx_enum, count: vx_size) -> vx_lut;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a LUT object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] lut The pointer to the LUT to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE lut is not a valid <tt>\\ref vx_lut</tt> reference.\n \\ingroup group_lut"]
    pub fn vxReleaseLUT(lut: *mut vx_lut) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries attributes from a LUT.\n \\param [in] lut The LUT to query.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_lut_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE lut is not a valid <tt>\\ref vx_lut</tt> reference.\n \\ingroup group_lut"]
    pub fn vxQueryLUT(
        lut: vx_lut,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy from/into a LUT object.\n \\param [in] lut The reference to the LUT object that is the source or the\n destination of the copy.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the LUT\n object if the copy was requested in write mode. In the user memory, the LUT is\n represented as a array with elements of the type corresponding to\n <tt>\\ref VX_LUT_TYPE</tt>, and with a number of elements equal to the value\n returned via <tt>\\ref VX_LUT_COUNT</tt>. The accessible memory must be large enough\n to contain this array:\n accessible memory in bytes >= sizeof(data_element) * count.\n \\param [in] usage This declares the effect of the copy with regard to the LUT object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the LUT object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the LUT object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE lut is not a valid <tt>\\ref vx_lut</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_lut"]
    pub fn vxCopyLUT(
        lut: vx_lut,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to LUT object.\n \\param [in] lut The reference to the LUT object to map.\n \\param [out] map_id The address of a <tt>\\ref vx_map_id</tt> variable where the function\n returns a map identifier.\n \\arg (*map_id) must eventually be provided as the map_id parameter of a call to\n <tt>\\ref vxUnmapLUT</tt>.\n \\param [out] ptr The address of a pointer that the function sets to the\n address where the requested data can be accessed. In the mapped memory area,\n the LUT data are structured as an array with elements of the type corresponding\n to <tt>\\ref VX_LUT_TYPE</tt>, with a number of elements equal to\n the value returned via <tt>\\ref VX_LUT_COUNT</tt>. Accessing the\n memory out of the bound of this array is forbidden and has an undefined behavior.\n The returned (*ptr) address is only valid between the call to the function and\n the corresponding call to <tt>\\ref vxUnmapLUT</tt>.\n \\param [in] usage This declares the access mode for the LUT, using\n the <tt>\\ref vx_accessor_e</tt> enumeration.\n \\arg <tt>\\ref VX_READ_ONLY</tt>: after the function call, the content of the memory location\n pointed by (*ptr) contains the LUT data. Writing into this memory location\n is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_READ_AND_WRITE</tt>: after the function call, the content of the memory\n location pointed by (*ptr) contains the LUT data; writing into this memory\n is allowed only for the location of entries and will result in a modification\n of the affected entries in the LUT object once the LUT is unmapped.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt>: after the function call, the memory location pointed by(*ptr)\n contains undefined data; writing each entry of LUT is required prior to\n unmapping. Entries not written by the application before unmap will become\n undefined after unmap, even if they were well defined before map.\n \\param [in] mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory where the LUT is requested to be mapped.\n \\param [in] flags An integer that allows passing options to the map operation.\n Use 0 for this option.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE lut is not a valid <tt>\\ref vx_lut</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_lut\n \\post <tt>\\ref vxUnmapLUT </tt> with same (*map_id) value."]
    pub fn vxMapLUT(
        lut: vx_lut,
        map_id: *mut vx_map_id,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
        mem_type: vx_enum,
        flags: vx_bitfield,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to LUT object that was previously mapped.\n Unmapping a LUT invalidates the memory location from which the LUT data could\n be accessed by the application. Accessing this memory location after the unmap function\n completes has an undefined behavior.\n \\param [in] lut The reference to the LUT object to unmap.\n \\param [out] map_id The unique map identifier that was returned when calling\n <tt>\\ref vxMapLUT</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE lut is not a valid <tt>\\ref vx_lut</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_lut\n \\pre <tt>\\ref vxMapLUT</tt> returning the same map_id value"]
    pub fn vxUnmapLUT(lut: vx_lut, map_id: vx_map_id) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a 1D Distribution of a consecutive interval [offset, offset + range - 1]\n defined by a start offset and valid range, divided equally into numBins parts.\n \\param [in] context The reference to the overall context.\n \\param [in] numBins The number of bins in the distribution.\n \\param [in] offset The start offset into the range value that marks the begining of the 1D Distribution.\n \\param [in] range  The total number of the consecutive values of the distribution interval.\n \\returns A distribution reference <tt>\\ref vx_distribution</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_distribution"]
    pub fn vxCreateDistribution(
        context: vx_context,
        numBins: vx_size,
        offset: vx_int32,
        range: vx_uint32,
    ) -> vx_distribution;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a 1D Distribution object without direct user access.\n \\param [in] graph The reference to the parent graph.\n \\param [in] numBins The number of bins in the distribution.\n \\param [in] offset The start offset into the range value that marks the begining of the 1D Distribution.\n \\param [in] range  The total number of the consecutive values of the distribution interval.\n \\see <tt>\\ref vxCreateDistribution</tt>\n \\returns A distribution reference <tt>\\ref vx_distribution</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_distribution"]
    pub fn vxCreateVirtualDistribution(
        graph: vx_graph,
        numBins: vx_size,
        offset: vx_int32,
        range: vx_uint32,
    ) -> vx_distribution;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a distribution object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] distribution The reference to the distribution to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE distribution is not a valid <tt>\\ref vx_distribution</tt> reference.\n \\ingroup group_distribution"]
    pub fn vxReleaseDistribution(distribution: *mut vx_distribution) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries a Distribution object.\n \\param [in] distribution The reference to the distribution to query.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_distribution_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE distribution is not a valid <tt>\\ref vx_distribution</tt> reference.\n \\ingroup group_distribution"]
    pub fn vxQueryDistribution(
        distribution: vx_distribution,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy from/into a distribution object.\n \\param [in] distribution The reference to the distribution object that is the source or the\n destination of the copy.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the distribution\n object if the copy was requested in write mode. In the user memory, the distribution is\n represented as a <tt>\\ref vx_uint32</tt> array with a number of elements equal to the value returned via\n <tt>\\ref VX_DISTRIBUTION_BINS</tt>. The accessible memory must be large enough\n to contain this vx_uint32 array:\n accessible memory in bytes >= sizeof(vx_uint32) * num_bins.\n \\param [in] usage This declares the effect of the copy with regard to the distribution object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the distribution object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the distribution object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE distribution is not a valid <tt>\\ref vx_distribution</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_distribution"]
    pub fn vxCopyDistribution(
        distribution: vx_distribution,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to distribution object.\n \\param [in] distribution The reference to the distribution object to map.\n \\param [out] map_id The address of a <tt>\\ref vx_map_id</tt> variable where the function\n returns a map identifier.\n \\arg (*map_id) must eventually be provided as the map_id parameter of a call to\n <tt>\\ref vxUnmapDistribution</tt>.\n \\param [out] ptr The address of a pointer that the function sets to the\n address where the requested data can be accessed. In the mapped memory area,\n data are structured as a vx_uint32 array with a number of elements equal to\n the value returned via <tt>\\ref VX_DISTRIBUTION_BINS</tt>. Each\n element of this array corresponds to a bin of the distribution, with a range-major\n ordering. Accessing the memory out of the bound of this array\n is forbidden and has an undefined behavior. The returned (*ptr) address\n is only valid between the call to the function and the corresponding call to\n <tt>\\ref vxUnmapDistribution</tt>.\n \\param [in] usage This declares the access mode for the distribution, using\n the <tt>\\ref vx_accessor_e</tt> enumeration.\n \\arg <tt>\\ref VX_READ_ONLY</tt>: after the function call, the content of the memory location\n pointed by (*ptr) contains the distribution data. Writing into this memory location\n is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_READ_AND_WRITE</tt>: after the function call, the content of the memory\n location pointed by (*ptr) contains the distribution data; writing into this memory\n is allowed only for the location of bins and will result in a modification of the\n affected bins in the distribution object once the distribution is unmapped.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt>: after the function call, the memory location pointed by (*ptr)\n contains undefined data; writing each bin of distribution is required prior to\n unmapping. Bins not written by the application before unmap will become\n undefined after unmap, even if they were well defined before map.\n \\param [in] mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory where the distribution is requested to be mapped.\n \\param [in] flags An integer that allows passing options to the map operation.\n Use 0 for this option.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE distribution is not a valid <tt>\\ref vx_distribution</tt> reference.\n reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_distribution\n \\post <tt>\\ref vxUnmapDistribution </tt> with same (*map_id) value."]
    pub fn vxMapDistribution(
        distribution: vx_distribution,
        map_id: *mut vx_map_id,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
        mem_type: vx_enum,
        flags: vx_bitfield,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to distribution object that was previously mapped.\n Unmapping a distribution invalidates the memory location from which the distribution data\n could be accessed by the application. Accessing this memory location after the unmap\n function completes has an undefined behavior.\n \\param [in] distribution The reference to the distribution object to unmap.\n \\param [out] map_id The unique map identifier that was returned when calling\n <tt>\\ref vxMapDistribution</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE distribution is not a valid <tt>\\ref vx_distribution</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_distribution\n \\pre <tt>\\ref vxMapDistribution</tt> returning the same map_id value"]
    pub fn vxUnmapDistribution(distribution: vx_distribution, map_id: vx_map_id) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a threshold object and returns a reference to it.\n\n The threshold object defines the parameters of a thresholding operation\n to an input image, that generates an output image that can have a different\n format. The thresholding 'false' or 'true' output values are specified per\n pixel channels of the output format and can be modified with\n <tt>\\ref vxCopyThresholdOutput</tt>. The default 'false' output value of\n pixels channels should be 0, and the default 'true' value should be non-zero.\n For standard image formats, default output pixel values are defined as\n following:\n  \\arg \\ref VX_DF_IMAGE_RGB : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_RGBX : false={0, 0, 0, 0}, true={255,255,255,255}\n  \\arg \\ref VX_DF_IMAGE_NV12 : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_NV21 : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_UYVY : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_YUYV : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_IYUV : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_YUV4 : false={0, 0, 0}, true={255,255,255}\n  \\arg \\ref VX_DF_IMAGE_U8 : false=0, true=0xFF\n  \\arg \\ref VX_DF_IMAGE_S16 : false=0, true=-1\n  \\arg \\ref VX_DF_IMAGE_U16 : false=0, true=0xFFFF\n  \\arg \\ref VX_DF_IMAGE_S32 : false=0, true=-1\n  \\arg \\ref VX_DF_IMAGE_U32 : false=0, true=0xFFFFFFFF\n \\param [in] context The reference to the context in which the object is\n created.\n \\param [in] thresh_type The type of thresholding operation.\n \\param [in] input_format The format of images that will be used as input of\n the thresholding operation.\n \\param [in] output_format The format of images that will be generated by the\n thresholding operation.\n \\returns A threshold reference <tt>\\ref vx_threshold</tt>. Any possible\n errors preventing a successful creation should be checked using\n <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_threshold"]
    pub fn vxCreateThresholdForImage(
        context: vx_context,
        thresh_type: vx_enum,
        input_format: vx_df_image,
        output_format: vx_df_image,
    ) -> vx_threshold;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a threshold object without direct user access.\n\n \\param [in] graph The reference to the parent graph.\n \\param [in] thresh_type The type of thresholding operation.\n \\param [in] input_format The format of images that will be used as input of\n the thresholding operation.\n \\param [in] output_format The format of images that will be generated by the\n thresholding operation.\n \\see <tt>\\ref vxCreateThresholdForImage</tt>\n \\returns A threshold reference <tt>\\ref vx_threshold</tt>. Any possible\n errors preventing a successful creation should be checked using\n <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_threshold"]
    pub fn vxCreateVirtualThresholdForImage(
        graph: vx_graph,
        thresh_type: vx_enum,
        input_format: vx_df_image,
        output_format: vx_df_image,
    ) -> vx_threshold;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy the thresholding value from/into a\n threshold object with type <tt>\\ref VX_THRESHOLD_TYPE_BINARY</tt>.\n \\param [in] thresh The reference to the threshold object that is the source\n or the destination of the copy.\n \\param [in,out] value_ptr The address of the memory location where to store\n the thresholding value if the copy was requested in read mode, or from where\n to get the thresholding value to store into the threshold object if the copy\n was requested in write mode.\n \\param [in] usage This declares the effect of the copy with regard to the\n threshold object using the <tt>\\ref vx_accessor_e</tt> enumeration. Only\n <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt> are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that the thresholding value is copied\n from the threshold object into the user memory. After the copy, only the\n field of the (*value_ptr) union that corresponds to the input image format\n of the threshold object is meaningful.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means the field of the (*value_ptr) union\n corresponding  to the input format of the threshold object is copied into\n the threshold object.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory referenced by \\p value_ptr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_INVALID_REFERENCE The threshold reference is not actually a\n threshold reference.\n \\retval VX_ERROR_NOT_COMPATIBLE The threshold object doesn't have type\n <tt>\\ref VX_THRESHOLD_TYPE_BINARY</tt>\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_threshold"]
    pub fn vxCopyThresholdValue(
        thresh: vx_threshold,
        value_ptr: *mut vx_pixel_value_t,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy thresholding values from/into a\n threshold object with type <tt>\\ref VX_THRESHOLD_TYPE_RANGE</tt>.\n \\param [in] thresh The reference to the threshold object that is the source\n or the destination of the copy.\n \\param [in,out] lower_value_ptr The address of the memory location where to\n store the lower thresholding value if the copy was requested in read mode,\n or from where to get the lower thresholding value to store into the threshold\n object if the copy was requested in write mode.\n \\param [in,out] upper_value_ptr The address of the memory location where to\n store the upper thresholding value if the copy was requested in read mode, or\n from where to get the upper thresholding value to store into the threshold\n object if the copy was requested in write mode.\n \\param [in] usage This declares the effect of the copy with regard to the\n threshold object using the <tt>\\ref vx_accessor_e</tt> enumeration. Only\n <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt> are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that thresholding values are copied\n from the threshold object into the user memory. After the copy, only the\n field of (*lower_value_ptr) and (*upper_value_ptr) unions that corresponds\n to the input image format of the threshold object is meaningful.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means the field of the (*lower_value_ptr)\n and (*upper_value_ptr) unions corresponding to the input format of the\n threshold object is copied into the threshold object.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory referenced by \\p lower_value_ptr and\n \\p upper_value_ptr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_INVALID_REFERENCE The threshold reference is not actually\n a threshold reference.\n \\retval VX_ERROR_NOT_COMPATIBLE The threshold object doesn't have type\n <tt>\\ref VX_THRESHOLD_TYPE_RANGE</tt>\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_threshold"]
    pub fn vxCopyThresholdRange(
        thresh: vx_threshold,
        lower_value_ptr: *mut vx_pixel_value_t,
        upper_value_ptr: *mut vx_pixel_value_t,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy the true and false output values\n from/into a threshold object.\n \\param [in] thresh The reference to the threshold object that is the source\n or the destination of the copy.\n \\param [in,out] true_value_ptr The address of the memory location where to\n store the true output value if the copy was requested in read mode,\n or from where to get the true output value to store into the threshold\n object if the copy was requested in write mode.\n \\param [in,out] false_value_ptr The address of the memory location where to\n store the false output value if the copy was requested in read mode, or\n from where to get the false output value to store into the threshold\n object if the copy was requested in write mode.\n \\param [in] usage This declares the effect of the copy with regard to the\n threshold object using the <tt>\\ref vx_accessor_e</tt> enumeration. Only\n <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt> are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that true and false output values\n are copied from the threshold object into the user memory. After the copy,\n only the field of (*true_value_ptr) and (*false_value_ptr) unions that\n corresponds to the output image format of the threshold object is meaningful.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means the field of the (*true_value_ptr)\n and (*false_value_ptr) unions corresponding to the output format of the\n threshold object is copied into the threshold object.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory referenced by \\p true_value_ptr and\n \\p false_value_ptr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_INVALID_REFERENCE The threshold reference is not actually\n a threshold reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_threshold"]
    pub fn vxCopyThresholdOutput(
        thresh: vx_threshold,
        true_value_ptr: *mut vx_pixel_value_t,
        false_value_ptr: *mut vx_pixel_value_t,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a threshold object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] thresh The pointer to the threshold to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE thresh is not a valid <tt>\\ref vx_threshold</tt> reference.\n \\ingroup group_threshold"]
    pub fn vxReleaseThreshold(thresh: *mut vx_threshold) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets attributes on the threshold object.\n \\param [in] thresh The threshold object to set.\n \\param [in] attribute The attribute to modify. Use a <tt>\\ref vx_threshold_attribute_e</tt> enumeration.\n \\param [in] ptr The pointer to the value to which to set the attribute.\n \\param [in] size The size of the data pointed to by \\a ptr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE thresh is not a valid <tt>\\ref vx_threshold</tt> reference.\n \\ingroup group_threshold"]
    pub fn vxSetThresholdAttribute(
        thresh: vx_threshold,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries an attribute on the threshold object.\n \\param [in] thresh The threshold object to set.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_threshold_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE thresh is not a valid <tt>\\ref vx_threshold</tt> reference.\n \\ingroup group_threshold"]
    pub fn vxQueryThreshold(
        thresh: vx_threshold,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a matrix object.\n \\param [in] c The reference to the overall context.\n \\param [in] data_type The vx_type_e that represents the data type of the matrix data elements.\n \\param [in] columns The first dimensionality.\n \\param [in] rows The second dimensionality.\n \\returns An matrix reference <tt>\\ref vx_matrix</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_matrix"]
    pub fn vxCreateMatrix(
        c: vx_context,
        data_type: vx_enum,
        columns: vx_size,
        rows: vx_size,
    ) -> vx_matrix;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a matrix object without direct user access.\n \\param [in] graph The reference to the parent graph.\n \\param [in] data_type The vx_type_e that represents the data type of the matrix data elements.\n \\param [in] columns The first dimensionality.\n \\param [in] rows The second dimensionality.\n \\see <tt>\\ref vxCreateMatrix</tt>\n \\returns An matrix reference <tt>\\ref vx_matrix</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_matrix"]
    pub fn vxCreateVirtualMatrix(
        graph: vx_graph,
        data_type: vx_enum,
        columns: vx_size,
        rows: vx_size,
    ) -> vx_matrix;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a matrix object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] mat The matrix reference to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE mat is not a valid <tt>\\ref vx_matrix</tt> reference.\n \\ingroup group_matrix"]
    pub fn vxReleaseMatrix(mat: *mut vx_matrix) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries an attribute on the matrix object.\n \\param [in] mat The matrix object to set.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_matrix_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE mat is not a valid <tt>\\ref vx_matrix</tt> reference.\n \\ingroup group_matrix"]
    pub fn vxQueryMatrix(
        mat: vx_matrix,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy from/into a matrix object.\n \\param [in] matrix The reference to the matrix object that is the source or the\n destination of the copy.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the matrix\n object if the copy was requested in write mode. In the user memory, the matrix is\n structured as a row-major 2D array with elements of the type corresponding to\n <tt>\\ref VX_MATRIX_TYPE</tt>, with a number of rows corresponding to\n <tt>\\ref VX_MATRIX_ROWS</tt> and a number of columns corresponding to\n <tt>\\ref VX_MATRIX_COLUMNS</tt>. The accessible memory must be large\n enough to contain this 2D array:\n accessible memory in bytes >= sizeof(data_element) * rows * columns.\n \\param [in] usage This declares the effect of the copy with regard to the matrix object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the matrix object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the matrix object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE matrix is not a valid <tt>\\ref vx_matrix</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_matrix"]
    pub fn vxCopyMatrix(
        matrix: vx_matrix,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a matrix object from a boolean pattern.\n \\see <tt>\\ref vxCreateMatrixFromPatternAndOrigin</tt> for a description of the matrix patterns.\n \\param [in] context The reference to the overall context.\n \\param [in] pattern The pattern of the matrix. See <tt>\\ref VX_MATRIX_PATTERN</tt>.\n \\param [in] columns The first dimensionality.\n \\param [in] rows The second dimensionality.\n \\returns A matrix reference <tt>\\ref vx_matrix</tt> of type <tt>\\ref VX_TYPE_UINT8</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_matrix"]
    pub fn vxCreateMatrixFromPattern(
        context: vx_context,
        pattern: vx_enum,
        columns: vx_size,
        rows: vx_size,
    ) -> vx_matrix;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a matrix object from a boolean pattern, with a user-specified origin.\n\n The matrix created by this function is of type <tt>\\ref VX_TYPE_UINT8</tt>, with the value 0 representing False,\n and the value 255 representing True. It supports the patterns as described below:\n - VX_PATTERN_BOX is a matrix with dimensions equal to the given number of rows and columns, and all cells equal to 255.\n   Dimensions of 3x3 and 5x5 must be supported.\n - VX_PATTERN_CROSS is a matrix with dimensions equal to the given number of rows and columns, which both must be odd numbers.\n   All cells in the center row and center column are equal to 255, and the rest are equal to zero.\n   Dimensions of 3x3 and 5x5 must be supported.\n - VX_PATTERN_DISK is a matrix with dimensions equal to the given number of rows (R) and columns (C),\n   where R and C are odd and cell (c, r) is 255 if: \\n\n   (r-R/2 + 0.5)^2 / (R/2)^2 + (c-C/2 + 0.5)^2/(C/2)^2 is less than or equal to 1,\\n and 0 otherwise.\n\n A matrix created from pattern is read-only. The behavior when attempting to modify such a matrix is undefined.\n\n \\param [in] context The reference to the overall context.\n \\param [in] pattern The pattern of the matrix. See <tt>\\ref VX_MATRIX_PATTERN</tt>.\n \\param [in] columns The first dimensionality.\n \\param [in] rows The second dimensionality.\n \\param [in] origin_col The origin (first dimensionality).\n \\param [in] origin_row The origin (second dimensionality).\n \\returns A matrix reference <tt>\\ref vx_matrix</tt> of type <tt>\\ref VX_TYPE_UINT8</tt>. Any possible errors\n preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_matrix"]
    pub fn vxCreateMatrixFromPatternAndOrigin(
        context: vx_context,
        pattern: vx_enum,
        columns: vx_size,
        rows: vx_size,
        origin_col: vx_size,
        origin_row: vx_size,
    ) -> vx_matrix;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a convolution matrix object.\n \\param [in] context The reference to the overall context.\n \\param [in] columns The columns dimension of the convolution.\n Must be odd and greater than or equal to 3 and less than the value returned\n from <tt>\\ref VX_CONTEXT_CONVOLUTION_MAX_DIMENSION</tt>.\n \\param [in] rows The rows dimension of the convolution.\n Must be odd and greater than or equal to 3 and less than the value returned\n from <tt>\\ref VX_CONTEXT_CONVOLUTION_MAX_DIMENSION</tt>.\n \\returns A convolution reference <tt>\\ref vx_convolution</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_convolution"]
    pub fn vxCreateConvolution(
        context: vx_context,
        columns: vx_size,
        rows: vx_size,
    ) -> vx_convolution;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a convolution matrix object without direct user access.\n \\param [in] graph The reference to the parent graph.\n \\param [in] columns The columns dimension of the convolution.\n Must be odd and greater than or equal to 3 and less than the value returned\n from <tt>\\ref VX_CONTEXT_CONVOLUTION_MAX_DIMENSION</tt>.\n \\param [in] rows The rows dimension of the convolution.\n Must be odd and greater than or equal to 3 and less than the value returned\n from <tt>\\ref VX_CONTEXT_CONVOLUTION_MAX_DIMENSION</tt>.\n \\see <tt>\\ref vxCreateConvolution</tt>\n \\returns A convolution reference <tt>\\ref vx_convolution</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_convolution"]
    pub fn vxCreateVirtualConvolution(
        graph: vx_graph,
        columns: vx_size,
        rows: vx_size,
    ) -> vx_convolution;
}
extern "C" {
    #[doc = " \\brief Releases the reference to a convolution matrix.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] conv The pointer to the convolution matrix to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE conv is not a valid <tt>\\ref vx_convolution</tt> reference.\n \\ingroup group_convolution"]
    pub fn vxReleaseConvolution(conv: *mut vx_convolution) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries an attribute on the convolution matrix object.\n \\param [in] conv The convolution matrix object to set.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_convolution_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE conv is not a valid <tt>\\ref vx_convolution</tt> reference.\n \\ingroup group_convolution"]
    pub fn vxQueryConvolution(
        conv: vx_convolution,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Sets attributes on the convolution object.\n \\param [in] conv The coordinates object to set.\n \\param [in] attribute The attribute to modify. Use a <tt>\\ref vx_convolution_attribute_e</tt> enumeration.\n \\param [in] ptr The pointer to the value to which to set the attribute.\n \\param [in] size The size in bytes of the data pointed to by \\a ptr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE conv is not a valid <tt>\\ref vx_convolution</tt> reference.\n \\ingroup group_convolution"]
    pub fn vxSetConvolutionAttribute(
        conv: vx_convolution,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy coefficients from/into a convolution object.\n \\param [in] conv The reference to the convolution object that is the source or the destination of the copy.\n \\param [in] user_ptr The address of the memory location where to store the requested\n coefficient data if the copy was requested in read mode, or from where to get the\n coefficient data to store into the convolution object if the copy was requested in\n write mode. In the user memory, the convolution coefficient data is structured as a\n row-major 2D array with elements of the type corresponding\n to <tt>\\ref VX_TYPE_CONVOLUTION</tt>, with a number of rows corresponding to\n <tt>\\ref VX_CONVOLUTION_ROWS</tt> and a number of columns corresponding to\n <tt>\\ref VX_CONVOLUTION_COLUMNS</tt>. The accessible memory must be large\n enough to contain this 2D array:\n accessible memory in bytes >= sizeof(data_element) * rows * columns.\n \\param [in] usage This declares the effect of the copy with regard to the convolution object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the convolution object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the convolution object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE conv is not a valid <tt>\\ref vx_convolution</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_convolution"]
    pub fn vxCopyConvolutionCoefficients(
        conv: vx_convolution,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a pyramid object of the supplied number of levels.\n \\param [in] context The reference to the overall context.\n \\param [in] levels The number of levels desired. This is required to be a non-zero value.\n \\param [in] scale Used to indicate the scale between pyramid levels. This is required to be a non-zero positive value.\n <tt>\\ref VX_SCALE_PYRAMID_HALF</tt> and <tt>\\ref VX_SCALE_PYRAMID_ORB</tt> must be supported.\n \\param [in] width The width of the 0th level image in pixels.\n \\param [in] height The height of the 0th level image in pixels.\n \\param [in] format The format of all images in the pyramid. NV12, NV21, IYUV, UYVY and YUYV formats are not supported.\n \\returns A pyramid reference <tt>\\ref vx_pyramid</tt> containing the sub-images. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_pyramid"]
    pub fn vxCreatePyramid(
        context: vx_context,
        levels: vx_size,
        scale: vx_float32,
        width: vx_uint32,
        height: vx_uint32,
        format: vx_df_image,
    ) -> vx_pyramid;
}
extern "C" {
    #[doc = " \\brief Creates a reference to a virtual pyramid object of the supplied number of levels.\n \\details Virtual Pyramids can be used to connect Nodes together when the contents of the pyramids will\n not be accessed by the user of the API.\n All of the following constructions are valid:\n \\code\n vx_context context = vxCreateContext();\n vx_graph graph = vxCreateGraph(context);\n vx_pyramid virt[] = {\n     vxCreateVirtualPyramid(graph, 4, VX_SCALE_PYRAMID_HALF, 0, 0, VX_DF_IMAGE_VIRT), // no dimension and format specified for level 0\n     vxCreateVirtualPyramid(graph, 4, VX_SCALE_PYRAMID_HALF, 640, 480, VX_DF_IMAGE_VIRT), // no format specified.\n     vxCreateVirtualPyramid(graph, 4, VX_SCALE_PYRAMID_HALF, 640, 480, VX_DF_IMAGE_U8), // no access\n };\n \\endcode\n \\param [in] graph The reference to the parent graph.\n \\param [in] levels The number of levels desired. This is required to be a non-zero value.\n \\param [in] scale Used to indicate the scale between pyramid levels. This is required to be a non-zero positive value.\n <tt>\\ref VX_SCALE_PYRAMID_HALF</tt> and <tt>\\ref VX_SCALE_PYRAMID_ORB</tt> must be supported.\n \\param [in] width The width of the 0th level image in pixels. This may be set to zero to indicate to the interface that the value is unspecified.\n \\param [in] height The height of the 0th level image in pixels. This may be set to zero to indicate to the interface that the value is unspecified.\n \\param [in] format The format of all images in the pyramid. This may be set to <tt>\\ref VX_DF_IMAGE_VIRT</tt> to indicate that the format is unspecified.\n \\returns A pyramid reference <tt>\\ref vx_pyramid</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note Images extracted with <tt>\\ref vxGetPyramidLevel</tt> behave as Virtual Images and\n cause <tt>\\ref vxMapImagePatch</tt> to return errors.\n \\ingroup group_pyramid"]
    pub fn vxCreateVirtualPyramid(
        graph: vx_graph,
        levels: vx_size,
        scale: vx_float32,
        width: vx_uint32,
        height: vx_uint32,
        format: vx_df_image,
    ) -> vx_pyramid;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a pyramid object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] pyr The pointer to the pyramid to release.\n \\ingroup group_pyramid\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE pyr is not a valid <tt>\\ref vx_pyramid</tt> reference.\n \\post After returning from this function the reference is zeroed."]
    pub fn vxReleasePyramid(pyr: *mut vx_pyramid) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries an attribute from an image pyramid.\n \\param [in] pyr The pyramid to query.\n \\param [in] attribute The attribute for which to query. Use a <tt>\\ref vx_pyramid_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE pyr is not a valid <tt>\\ref vx_pyramid</tt> reference.\n \\ingroup group_pyramid"]
    pub fn vxQueryPyramid(
        pyr: vx_pyramid,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves a level of the pyramid as a <tt>\\ref vx_image</tt>, which can be used\n elsewhere in OpenVX. A call to vxReleaseImage is necessary to release an image for each\n call of vxGetPyramidLevel.\n \\param [in] pyr The pyramid object.\n \\param [in] index The index of the level, such that index is less than levels.\n \\return A <tt>\\ref vx_image</tt> reference. Any possible errors preventing a successful\n function completion should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_pyramid"]
    pub fn vxGetPyramidLevel(pyr: vx_pyramid, index: vx_uint32) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Creates a remap table object.\n \\param [in] context The reference to the overall context.\n \\param [in] src_width Width of the source image in pixel.\n \\param [in] src_height Height of the source image in pixels.\n \\param [in] dst_width Width of the destination image in pixels.\n \\param [in] dst_height Height of the destination image in pixels.\n \\ingroup group_remap\n \\returns A remap reference <tt>\\ref vx_remap</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxCreateRemap(
        context: vx_context,
        src_width: vx_uint32,
        src_height: vx_uint32,
        dst_width: vx_uint32,
        dst_height: vx_uint32,
    ) -> vx_remap;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a remap table object without direct user access.\n \\param [in] graph The reference to the parent graph.\n \\param [in] src_width Width of the source image in pixel.\n \\param [in] src_height Height of the source image in pixels.\n \\param [in] dst_width Width of the destination image in pixels.\n \\param [in] dst_height Height of the destination image in pixels.\n \\see <tt>\\ref vxCreateRemap</tt>\n \\ingroup group_remap\n \\returns A remap reference <tt>\\ref vx_remap</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxCreateVirtualRemap(
        graph: vx_graph,
        src_width: vx_uint32,
        src_height: vx_uint32,
        dst_width: vx_uint32,
        dst_height: vx_uint32,
    ) -> vx_remap;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a remap table object. The object may not be\n garbage collected until its total reference count is zero.\n \\param [in] table The pointer to the remap table to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE table is not a valid <tt>\\ref vx_remap</tt> reference.\n \\ingroup group_remap"]
    pub fn vxReleaseRemap(table: *mut vx_remap) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to a rectangular patch of a remap object.\n\n The patch is specified within the destination dimensions and its\n data provide the corresponding coordinate within the source dimensions.\n The patch is mapped as a 2D array of elements of the type associated\n with the \\p coordinate_type parameter (i.e., <tt>\\ref vx_coordinates2df_t</tt>\n for <tt>\\ref VX_TYPE_COORDINATES2DF</tt>).\n The memory layout of the mapped 2D array follows a row-major order where rows are\n compact (without any gap between elements), and where the potential\n padding after each lines is determined by (* \\p stride_y).\n\n \\param [in] remap The reference to the remap object that contains the\n patch to map.\n\n \\param [in] rect The coordinates of remap patch. The patch must be specified\n within the bounds of the remap destination dimensions\n (<tt>\\ref VX_REMAP_DESTINATION_WIDTH</tt> x <tt>\\ref VX_REMAP_DESTINATION_HEIGHT</tt>).\n (start_x, start_y) gives the coordinate of the topleft element inside the patch,\n while (end_x, end_y) gives the coordinate of the bottomright element out of the patch.\n\n \\param [out] map_id The address of a <tt>\\ref vx_map_id</tt> variable\n where the function returns a map identifier.\n \\arg (*map_id) must eventually be provided as the map_id parameter of a call\n to <tt>\\ref vxUnmapRemapPatch</tt>.\n\n \\param [out] stride_y The address of a vx_size variable where the function\n returns the difference between the address of the first element of two\n successive lines in the mapped remap patch. The stride value follows the\n following rule :\n (*stride_y) >= sizeof(<ELEMENT_TYPE>) * (rect->end_x - rect->start_x)\n\n \\param [out] ptr The address of a pointer where the function returns where\n remap patch data can be accessed. (*ptr) is the address of the the top-left\n element of the remap patch.\n The returned (*ptr) address is only valid between the call to this function\n and the corresponding call to <tt>\\ref vxUnmapRemapPatch</tt>.\n\n \\param [in] coordinate_type This declares the type of the source coordinate\n data that the application wants to access in the remap patch.\n It must be <tt>\\ref VX_TYPE_COORDINATES2DF</tt>.\n\n \\param [in] usage This declares the access mode for the remap patch, using\n the <tt>\\ref vx_accessor_e</tt> enumeration.\n \\arg <tt>\\ref VX_READ_ONLY</tt>: after the function call, the content of the\n memory location pointed by (*ptr) contains the remap patch data. Writing into\n this memory location is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_READ_AND_WRITE</tt>: after the function call, the content of\n the memory location pointed by (*ptr) contains the remap patch data; writing\n into this memory is allowed for the location of elements only and will\n result in a modification of the written elements in the remap object once the\n patch is unmapped. Writing into a gap between element lines\n (when (*stride_y) > sizeof(<ELEMENT_TYPE>) * (rect->end_x - rect->start_x))\n is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt>: after the function call, the memory location\n pointed by (*ptr) contains undefined data; writing each element of the patch is\n required prior to unmapping. Elements not written by the application before\n unmap will become undefined after unmap, even if they were well defined before\n map. Like for <tt>\\ref VX_READ_AND_WRITE</tt>, writing into a gap between\n element lines is forbidden and its behavior is undefined.\n\n \\param [in] mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory where the remap patch is requested to be mapped.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE remap is not a valid <tt>\\ref vx_remap</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n\n \\ingroup group_remap\n \\post <tt>\\ref vxUnmapRemapPatch </tt> with same (*map_id) value."]
    pub fn vxMapRemapPatch(
        remap: vx_remap,
        rect: *const vx_rectangle_t,
        map_id: *mut vx_map_id,
        stride_y: *mut vx_size,
        ptr: *mut *mut ::std::os::raw::c_void,
        coordinate_type: vx_enum,
        usage: vx_enum,
        mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to a remap object patch that was previously mapped.\n\n Unmapping a remap patch invalidates the memory location from which the patch could\n be accessed by the application. Accessing this memory location after the unmap function\n completes has an undefined behavior.\n \\param [in] remap The reference to the remap object to unmap.\n \\param [out] map_id The unique map identifier that was returned by <tt>\\ref vxMapRemapPatch</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE remap is not a valid <tt>\\ref vx_remap</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_remap\n \\pre <tt>\\ref vxMapRemapPatch</tt> with same map_id value"]
    pub fn vxUnmapRemapPatch(remap: vx_remap, map_id: vx_map_id) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy a rectangular patch from/into a remap object.\n\n The patch is specified within the destination dimensions and its\n data provide the corresponding coordinate within the source dimensions.\n The patch in user memory is a 2D array of elements of the type associated with the\n \\p coordinate_type parameter (i.e., <tt>\\ref vx_coordinates2df_t</tt> for\n <tt>\\ref VX_TYPE_COORDINATES2DF</tt>).\n The memory layout of this array follows a row-major order where rows are\n compact (without any gap between elements), and where the potential padding\n after each line is determined by the \\p user_stride_y parameter.\n\n \\param [in] remap The reference to the remap object that is the source or the\n destination of the patch copy.\n\n \\param [in] rect The coordinates of remap patch. The patch must be specified\n within the bounds of the remap destination dimensions\n (<tt>\\ref VX_REMAP_DESTINATION_WIDTH</tt> x <tt>\\ref VX_REMAP_DESTINATION_HEIGHT</tt>).\n (start_x, start_y) gives the coordinate of the topleft element inside the patch,\n while (end_x, end_y) gives the coordinate of the bottomright element out of the patch.\n\n \\param [in] user_stride_y The difference between the address of the first element\n of two successive lines of the remap patch in user memory (pointed by\n \\p user_ptr). The layout of the user memory must follow a row major order and user_stride_y\n must follow the following rule :\n  user_stride_y >= sizeof(<ELEMENT_TYPE>) * (rect->end_x - rect->start_x).\n\n \\param [in] user_ptr The address of the user memory location where to store the requested\n remap data if the copy was requested in read mode, or from where to get the remap data to\n store into the remap object if the copy was requested in write mode. \\p user_ptr is the\n address of the the top-left element of the remap patch.\n The accessible user memory must be large enough to contain the specified patch with\n the specified layout:\n accessible memory in bytes >= (rect->end_y - rect->start_y) * user_stride_y.\n\n \\param [in] user_coordinate_type This declares the type of the source coordinate remap\n data in the user memory. It must be <tt>\\ref VX_TYPE_COORDINATES2DF</tt>.\n\n \\param [in] usage This declares the effect of the copy with regard to the remap object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only VX_READ_ONLY and VX_WRITE_ONLY are\n supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data is copied from the remap object into the user\n memory pointer by \\p user_ptr. The potential padding after each line in user\n memory will stay unchanged.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data is copied into the remap object from\n the user memory.\n\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the type of the memory pointer by \\p user_ptr.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE remap is not a valid <tt>\\ref vx_remap</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n\n \\ingroup group_remap"]
    pub fn vxCopyRemapPatch(
        remap: vx_remap,
        rect: *const vx_rectangle_t,
        user_stride_y: vx_size,
        user_ptr: *mut ::std::os::raw::c_void,
        user_coordinate_type: vx_enum,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries attributes from a Remap table.\n \\param [in] table The remap to query.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_remap_attribute_e</tt> enumeration.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE table is not a valid <tt>\\ref vx_remap</tt> reference.\n \\ingroup group_remap"]
    pub fn vxQueryRemap(
        table: vx_remap,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to an Array object.\n\n User must specify the Array capacity (i.e., the maximal number of items that the array can hold).\n\n \\param [in] context      The reference to the overall Context.\n \\param [in] item_type The type of data to hold. Must be greater than\n <tt>\\ref VX_TYPE_INVALID</tt> and less than or equal to <tt>\\ref VX_TYPE_VENDOR_STRUCT_END</tt>.\n Or must be a <tt>\\ref vx_enum</tt> returned from <tt>\\ref vxRegisterUserStruct</tt>.\n \\param [in] capacity     The maximal number of items that the array can hold. This value must be greater than zero.\n\n \\returns An array reference <tt>\\ref vx_array</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n\n \\ingroup group_array"]
    pub fn vxCreateArray(context: vx_context, item_type: vx_enum, capacity: vx_size) -> vx_array;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a virtual Array with no direct user access.\n\n Virtual Arrays are useful when item type or capacity are unknown ahead of time\n and the Array is used as internal graph edge. Virtual arrays are scoped within the parent graph only.\n\n All of the following constructions are allowed.\n \\code\n vx_context context = vxCreateContext();\n vx_graph graph = vxCreateGraph(context);\n vx_array virt[] = {\n     vxCreateVirtualArray(graph, 0, 0), // totally unspecified\n     vxCreateVirtualArray(graph, VX_TYPE_KEYPOINT, 0), // unspecified capacity\n     vxCreateVirtualArray(graph, VX_TYPE_KEYPOINT, 1000), // no access\n };\n \\endcode\n\n \\param [in] graph        The reference to the parent graph.\n \\param [in] item_type The type of data to hold. Must be greater than\n <tt>\\ref VX_TYPE_INVALID</tt> and less than or equal to <tt>\\ref VX_TYPE_VENDOR_STRUCT_END</tt>.\n Or must be a <tt>\\ref vx_enum</tt> returned from <tt>\\ref vxRegisterUserStruct</tt>.\n                          This may to set to zero to indicate an unspecified item type.\n \\param [in] capacity     The maximal number of items that the array can hold.\n                          This may be to set to zero to indicate an unspecified capacity.\n \\see vxCreateArray for a type list.\n \\returns A array reference <tt>\\ref vx_array</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n\n \\ingroup group_array"]
    pub fn vxCreateVirtualArray(graph: vx_graph, item_type: vx_enum, capacity: vx_size)
        -> vx_array;
}
extern "C" {
    #[doc = " \\brief Releases a reference of an Array object.\n The object may not be garbage collected until its total reference count is zero.\n After returning from this function the reference is zeroed.\n \\param [in] arr          The pointer to the Array to release.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE arr is not a valid <tt>\\ref vx_array</tt> reference.\n \\ingroup group_array"]
    pub fn vxReleaseArray(arr: *mut vx_array) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries the Array for some specific information.\n\n \\param [in] arr          The reference to the Array.\n \\param [in] attribute    The attribute to query. Use a <tt>\\ref vx_array_attribute_e</tt>.\n \\param [out] ptr         The location at which to store the resulting value.\n \\param [in] size         The size in bytes of the container to which \\a ptr points.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS                   No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE   arr is not a valid <tt>\\ref vx_array</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED       If the \\a attribute is not a value supported on this implementation.\n \\retval VX_ERROR_INVALID_PARAMETERS  If any of the other parameters are incorrect.\n\n \\ingroup group_array"]
    pub fn vxQueryArray(
        arr: vx_array,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Adds items to the Array.\n\n This function increases the container size.\n\n By default, the function does not reallocate memory,\n so if the container is already full (number of elements is equal to capacity)\n or it doesn't have enough space,\n the function returns <tt>\\ref VX_FAILURE</tt> error code.\n\n \\param [in] arr          The reference to the Array.\n \\param [in] count        The total number of elements to insert.\n \\param [in] ptr          The location from which to read the input values.\n \\param [in] stride       The number of bytes between the beginning of two consecutive elements.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS                   No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE   arr is not a valid <tt>\\ref vx_array</tt> reference.\n \\retval VX_FAILURE                   If the Array is full.\n \\retval VX_ERROR_INVALID_PARAMETERS  If any of the other parameters are incorrect.\n\n \\ingroup group_array"]
    pub fn vxAddArrayItems(
        arr: vx_array,
        count: vx_size,
        ptr: *const ::std::os::raw::c_void,
        stride: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Truncates an Array (remove items from the end).\n\n \\param [in,out] arr          The reference to the Array.\n \\param [in] new_num_items    The new number of items for the Array.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS                   No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE   arr is not a valid <tt>\\ref vx_array</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS  The \\a new_size is greater than the current size.\n\n \\ingroup group_array"]
    pub fn vxTruncateArray(arr: vx_array, new_num_items: vx_size) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy a range from/into an array object.\n \\param [in] array The reference to the array object that is the source or the\n destination of the copy.\n \\param [in] range_start The index of the first item of the array object to copy.\n \\param [in] range_end The index of the item following the last item of the\n array object to copy. (range_end range_start) items are copied from index\n range_start included. The range must be within the bounds of the array:\n 0 <= range_start < range_end <= number of items in the array.\n \\param [in] user_stride The number of bytes between the beginning of two consecutive\n items in the user memory pointed by user_ptr. The layout of the user memory must\n follow an item major order:\n user_stride >= element size in bytes.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the array\n object if the copy was requested in write mode. The accessible memory must be large enough\n to contain the specified range with the specified stride:\n accessible memory in bytes >= (range_end range_start) * user_stride.\n \\param [in] usage This declares the effect of the copy with regard to the array object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt>\n are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data are copied from the array object into the user memory.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data are copied into the array object from the user memory.\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual array that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE array is not a valid <tt>\\ref vx_array</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_array"]
    pub fn vxCopyArrayRange(
        array: vx_array,
        range_start: vx_size,
        range_end: vx_size,
        user_stride: vx_size,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to a range of an array object.\n \\param [in] array The reference to the array object that contains the range to map.\n \\param [in] range_start The index of the first item of the array object to map.\n \\param [in] range_end The index of the item following the last item of the\n array object to map. (range_end range_start) items are mapped, starting from index\n range_start included. The range must be within the bounds of the array:\n Must be 0 <= range_start < range_end <= number of items.\n \\param [out] map_id The address of a <tt>\\ref vx_map_id</tt> variable where the function\n returns a map identifier.\n \\arg (*map_id) must eventually be provided as the map_id parameter of a call to\n <tt>\\ref vxUnmapArrayRange</tt>.\n \\param [out] stride The address of a vx_size variable where the function\n returns the memory layout of the mapped array range. The function sets (*stride)\n to the number of bytes between the beginning of two consecutive items.\n The application must consult (*stride) to access the array items starting from\n address (*ptr). The layout of the mapped array follows an item major order:\n (*stride) >= item size in bytes.\n \\param [out] ptr The address of a pointer that the function sets to the\n address where the requested data can be accessed. The returned (*ptr) address\n is only valid between the call to the function and the corresponding call to\n <tt>\\ref vxUnmapArrayRange</tt>.\n \\param [in] usage This declares the access mode for the array range, using\n the <tt>\\ref vx_accessor_e</tt> enumeration.\n \\arg <tt>\\ref VX_READ_ONLY</tt>: after the function call, the content of the memory location\n pointed by (*ptr) contains the array range data. Writing into this memory location\n is forbidden and its behavior is undefined.\n \\arg <tt>\\ref VX_READ_AND_WRITE</tt>: after the function call, the content of the memory\n location pointed by (*ptr) contains the array range data; writing into this memory\n is allowed only for the location of items and will result in a modification of the\n affected items in the array object once the range is unmapped. Writing into\n a gap between items (when (*stride) > item size in bytes) is forbidden and its\n behavior is undefined.\n \\arg <tt>\\ref VX_WRITE_ONLY</tt>: after the function call, the memory location pointed by (*ptr)\n contains undefined data; writing each item of the range is required prior to\n unmapping. Items not written by the application before unmap will become\n undefined after unmap, even if they were well defined before map. Like for\n VX_READ_AND_WRITE, writing into a gap between items is forbidden and its behavior\n is undefined.\n \\param [in] mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory where the array range is requested to be mapped.\n \\param [in] flags An integer that allows passing options to the map operation.\n Use the <tt>\\ref vx_map_flag_e</tt> enumeration.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual array that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE array is not a valid <tt>\\ref vx_array</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_array\n \\post <tt>\\ref vxUnmapArrayRange </tt> with same (*map_id) value."]
    pub fn vxMapArrayRange(
        array: vx_array,
        range_start: vx_size,
        range_end: vx_size,
        map_id: *mut vx_map_id,
        stride: *mut vx_size,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
        mem_type: vx_enum,
        flags: vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to an array object range that was previously mapped.\n Unmapping an array range invalidates the memory location from which the range could\n be accessed by the application. Accessing this memory location after the unmap function\n completes has an undefined behavior.\n \\param [in] array The reference to the array object to unmap.\n \\param [out] map_id The unique map identifier that was returned when calling\n <tt>\\ref vxMapArrayRange</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE array is not a valid <tt>\\ref vx_array</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_array\n \\pre <tt>\\ref vxMapArrayRange</tt> returning the same map_id value"]
    pub fn vxUnmapArrayRange(array: vx_array, map_id: vx_map_id) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a reference to an ObjectArray of count objects.\n\n It uses the metadata of the exemplar to determine the object attributes,\n ignoring the object data. It does not alter the exemplar or keep or release\n the reference to the exemplar. For the definition of supported attributes see\n <tt>\\ref vxSetMetaFormatAttribute</tt>. In case the exemplar is a virtual object\n it must be of immutable metadata, thus it is not allowed to be dimensionless or formatless.\n\n \\param [in] context      The reference to the overall Context.\n \\param [in] exemplar     The exemplar object that defines the metadata of the created objects in the ObjectArray.\n \\param [in] count        Number of Objects to create in the ObjectArray. This value must be greater than zero.\n\n \\returns An ObjectArray reference <tt>\\ref vx_object_array</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>. Data objects are not initialized by this function.\n\n \\ingroup group_object_array"]
    pub fn vxCreateObjectArray(
        context: vx_context,
        exemplar: vx_reference,
        count: vx_size,
    ) -> vx_object_array;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a virtual ObjectArray with no direct user access.\n\n This function creates an ObjectArray of count objects with similar behavior as\n <tt>\\ref vxCreateObjectArray</tt>. The only difference is that the objects that are\n created are virtual in the given graph.\n\n \\param [in] graph      Reference to the graph where to create the virtual ObjectArray.\n \\param [in] exemplar   The exemplar object that defines the type of object in the ObjectArray.\n                        Only exemplar type of <tt>\\ref vx_image</tt>, <tt>\\ref vx_array</tt> and\n                        <tt>\\ref vx_pyramid</tt> are allowed.\n \\param [in] count      Number of Objects to create in the ObjectArray.\n \\returns               A ObjectArray reference <tt>\\ref vx_object_array</tt>. Any possible errors preventing a\n                        successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_object_array"]
    pub fn vxCreateVirtualObjectArray(
        graph: vx_graph,
        exemplar: vx_reference,
        count: vx_size,
    ) -> vx_object_array;
}
extern "C" {
    #[doc = " \\brief                 Retrieves the reference to the OpenVX Object in location index of the ObjectArray.\n\n This is a vx_reference, which can be used elsewhere in OpenVX. A call to vxRelease<Object> or <tt>\\ref vxReleaseReference</tt>\n is necessary to release the Object for each call to this function.\n\n \\param [in] arr       The ObjectArray.\n \\param [in] index     The index of the object in the ObjectArray.\n \\return A reference to an OpenVX data object. Any possible errors preventing a successful\n completion of the function should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_object_array"]
    pub fn vxGetObjectArrayItem(arr: vx_object_array, index: vx_uint32) -> vx_reference;
}
extern "C" {
    #[doc = " \\brief Releases a reference of an ObjectArray object.\n\n The object may not be garbage collected until its total reference and its contained objects\n count is zero. After returning from this function the reference is zeroed/cleared.\n\n \\param [in] arr          The pointer to the ObjectArray to release.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE arr is not a valid <tt>\\ref vx_object_array</tt> reference.\n \\ingroup group_object_array"]
    pub fn vxReleaseObjectArray(arr: *mut vx_object_array) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries an atribute from the ObjectArray.\n\n \\param [in] arr          The reference to the ObjectArray.\n \\param [in] attribute    The attribute to query. Use a <tt>\\ref vx_object_array_attribute_e</tt>.\n \\param [out] ptr         The location at which to store the resulting value.\n \\param [in] size         The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS                   No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE   arr is not a valid <tt>\\ref vx_object_array</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED       If the \\a attribute is not a value supported on this implementation.\n \\retval VX_ERROR_INVALID_PARAMETERS  If any of the other parameters are incorrect.\n\n \\ingroup group_object_array"]
    pub fn vxQueryObjectArray(
        arr: vx_object_array,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief This function allows a user to set the attributes of a <tt>\\ref vx_meta_format</tt> object in a kernel output validator.\n\n The \\ref vx_meta_format object contains two types of information: data object meta data and\n some specific information that defines how the valid region of an image changes\n\n The meta data attributes that can be set are identified by this list:\n - \\ref vx_image : \\ref VX_IMAGE_FORMAT, \\ref VX_IMAGE_HEIGHT, \\ref VX_IMAGE_WIDTH\n - \\ref vx_array : \\ref VX_ARRAY_CAPACITY, \\ref VX_ARRAY_ITEMTYPE\n - \\ref vx_pyramid : \\ref VX_PYRAMID_FORMAT, \\ref VX_PYRAMID_HEIGHT, \\ref VX_PYRAMID_WIDTH, \\ref VX_PYRAMID_LEVELS, \\ref VX_PYRAMID_SCALE\n - \\ref vx_scalar : \\ref VX_SCALAR_TYPE\n - \\ref vx_matrix : \\ref VX_MATRIX_TYPE, \\ref VX_MATRIX_ROWS, \\ref VX_MATRIX_COLUMNS\n - \\ref vx_distribution : \\ref VX_DISTRIBUTION_BINS, \\ref VX_DISTRIBUTION_OFFSET, \\ref VX_DISTRIBUTION_RANGE\n - \\ref vx_remap : \\ref VX_REMAP_SOURCE_WIDTH, \\ref VX_REMAP_SOURCE_HEIGHT, \\ref VX_REMAP_DESTINATION_WIDTH, \\ref VX_REMAP_DESTINATION_HEIGHT\n - \\ref vx_lut : \\ref VX_LUT_TYPE, \\ref VX_LUT_COUNT\n - \\ref vx_threshold : \\ref VX_THRESHOLD_TYPE, \\ref VX_THRESHOLD_INPUT_FORMAT, \\ref VX_THRESHOLD_INPUT_FORMAT\n - \\ref vx_object_array : \\ref VX_OBJECT_ARRAY_NUMITEMS, \\ref VX_OBJECT_ARRAY_ITEMTYPE\n - \\ref vx_tensor : \\ref VX_TENSOR_NUMBER_OF_DIMS, \\ref VX_TENSOR_DIMS, \\ref VX_TENSOR_DATA_TYPE, \\ref VX_TENSOR_FIXED_POINT_POSITION\n - \\ref VX_VALID_RECT_CALLBACK\n \\note For vx_image, a specific attribute can be used to specify the valid region evolution. This information is not a meta data.\n\n \\param [in] meta The reference to the \\ref vx_meta_format struct to set\n \\param [in] attribute Use the subset of data object attributes that define the meta data of this object or attributes from <tt>\\ref vx_meta_format</tt>.\n \\param [in] ptr The input pointer of the value to set on the meta format object.\n \\param [in] size The size in bytes of the object to which \\a ptr points.\n \\ingroup group_user_kernels\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS The attribute was set; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE meta is not a valid <tt>\\ref vx_meta_format</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS size was not correct for the type needed.\n \\retval VX_ERROR_NOT_SUPPORTED the object attribute was not supported on the meta format object.\n \\retval VX_ERROR_INVALID_TYPE attribute type did not match known meta format type."]
    pub fn vxSetMetaFormatAttribute(
        meta: vx_meta_format,
        attribute: vx_enum,
        ptr: *const ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Set a meta format object from an exemplar data object reference\n\n This function sets a \\ref vx_meta_format object from the meta data of the exemplar\n\n \\param [in] meta The meta format object to set\n \\param [in] exemplar The exemplar data object.\n \\ingroup group_user_kernels\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS The meta format was correctly set; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE meta is not a valid <tt>\\ref vx_meta_format</tt> reference,\n or exemplar is not a valid <tt>\\ref vx_reference</tt> reference."]
    pub fn vxSetMetaFormatFromReference(meta: vx_meta_format, exemplar: vx_reference) -> vx_status;
}
extern "C" {
    #[doc = " \\brief This function allows a user to query the attributes of a <tt>\\ref vx_meta_format</tt> object in a kernel parameter.\n\n The \\ref vx_meta_format object contains two types of information: data object meta data and\n some specific information that defines how the valid region of an image changes\n\n The meta data attributes that can be queried are identified by this list:\n - \\ref vx_image : \\ref VX_IMAGE_FORMAT, \\ref VX_IMAGE_HEIGHT, \\ref VX_IMAGE_WIDTH\n - \\ref vx_array : \\ref VX_ARRAY_CAPACITY, \\ref VX_ARRAY_ITEMTYPE\n - \\ref vx_pyramid : \\ref VX_PYRAMID_FORMAT, \\ref VX_PYRAMID_HEIGHT, \\ref VX_PYRAMID_WIDTH, \\ref VX_PYRAMID_LEVELS, \\ref VX_PYRAMID_SCALE\n - \\ref vx_scalar : \\ref VX_SCALAR_TYPE\n - \\ref vx_matrix : \\ref VX_MATRIX_TYPE, \\ref VX_MATRIX_ROWS, \\ref VX_MATRIX_COLUMNS\n - \\ref vx_distribution : \\ref VX_DISTRIBUTION_BINS, \\ref VX_DISTRIBUTION_OFFSET, \\ref VX_DISTRIBUTION_RANGE\n - \\ref vx_remap : \\ref VX_REMAP_SOURCE_WIDTH, \\ref VX_REMAP_SOURCE_HEIGHT, \\ref VX_REMAP_DESTINATION_WIDTH, \\ref VX_REMAP_DESTINATION_HEIGHT\n - \\ref vx_lut : \\ref VX_LUT_TYPE, \\ref VX_LUT_COUNT\n - \\ref vx_threshold : \\ref VX_THRESHOLD_TYPE, \\ref VX_THRESHOLD_INPUT_FORMAT, \\ref VX_THRESHOLD_INPUT_FORMAT\n - \\ref vx_object_array : \\ref VX_OBJECT_ARRAY_NUMITEMS, \\ref VX_OBJECT_ARRAY_ITEMTYPE\n - \\ref vx_tensor : \\ref VX_TENSOR_NUMBER_OF_DIMS, \\ref VX_TENSOR_DIMS, \\ref VX_TENSOR_DATA_TYPE, \\ref VX_TENSOR_FIXED_POINT_POSITION\n - \\ref VX_VALID_RECT_CALLBACK\n \\note For vx_image, a specific attribute can be used to query the valid region evolution. This information is not a meta data.\n\n \\param [in] meta The reference to the \\ref vx_meta_format struct to query\n \\param [in] attribute Use the subset of data object attributes that define the meta data of this object or attributes from <tt>\\ref vx_meta_format</tt>.\n \\param [out] ptr The output pointer of the value to query on the meta format object.\n \\param [in] size The size in bytes of the object to which \\a ptr points.\n \\ingroup group_import_kernel\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS The attribute was returned; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE meta is not a valid <tt>\\ref vx_meta_format</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS size was not correct for the type needed.\n \\retval VX_ERROR_NOT_SUPPORTED the object attribute was not supported on the meta format object.\n \\retval VX_ERROR_INVALID_TYPE attribute type did not match known meta format type."]
    pub fn vxQueryMetaFormatAttribute(
        meta: vx_meta_format,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a tensor data buffer.\n \\details Not guaranteed to exist until the <tt>\\ref vx_graph</tt> containing it has been verified.\n Since functions using tensors, need to understand the context of each dimension. We describe a layout of the dimensions in each function using tensors.\n That layout is not mandatory. It is done specifically to explain the functions and not to mandate layout. Different implementation may have different layout.\n Therefore the layout description is logical and not physical. It refers to the order of dimensions given in this function.\n \\param [in] context The reference to the implementation context.\n \\param [in] number_of_dims The number of dimensions.\n \\param [in] dims Dimensions sizes in elements.\n \\param [in] data_type The <tt>\\ref vx_type_e</tt> that represents the data type of the tensor data elements.\n \\param [in] fixed_point_position Specifies the fixed point position when the input element type is integer. if 0, calculations are performed in integer math.\n \\return A tensor data reference. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_object_tensor"]
    pub fn vxCreateTensor(
        context: vx_context,
        number_of_dims: vx_size,
        dims: *const vx_size,
        data_type: vx_enum,
        fixed_point_position: vx_int8,
    ) -> vx_tensor;
}
extern "C" {
    #[doc = " \\brief Creates an array of images into the multi-dimension data, this can be adjacent 2D images or not depending on the stride value.\n The stride value is representing bytes in the third dimension.\n The OpenVX image object that points to a three dimension data and access it as an array of images.\n This has to be portion of the third lowest dimension, and the stride correspond to that third dimension.\n The returned Object array is an array of images. Where the image data is pointing to a specific memory in the input tensor.\n \\param [in] tensor The tensor data from which to extract the images. Has to be a 3d tensor.\n \\param [in] rect Image coordinates within tensor data.\n \\param [in] array_size Number of images to extract.\n \\param [in] jump Delta between two images in the array.\n \\param [in] image_format The requested image format. Should match the tensor data's data type.\n \\return An array of images pointing to the tensor data's data.\n \\ingroup group_object_tensor"]
    pub fn vxCreateImageObjectArrayFromTensor(
        tensor: vx_tensor,
        rect: *const vx_rectangle_t,
        array_size: vx_size,
        jump: vx_size,
        image_format: vx_df_image,
    ) -> vx_object_array;
}
extern "C" {
    #[doc = " \\brief Creates a tensor data from another tensor data given a view. This second\n reference refers to the data in the original tensor data. Updates to this tensor data\n updates the parent tensor data. The view must be defined within the dimensions\n of the parent tensor data.\n \\param [in] tensor The reference to the parent tensor data.\n \\param [in] number_of_dims Number of dimensions in the view. Error return if 0 or greater than number of\n tensor dimensions. If smaller than number of tensor dimensions, the lower dimensions are assumed.\n \\param [in] view_start View start coordinates\n \\param [in] view_end View end coordinates\n \\return The reference to the sub-tensor. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_object_tensor"]
    pub fn vxCreateTensorFromView(
        tensor: vx_tensor,
        number_of_dims: vx_size,
        view_start: *const vx_size,
        view_end: *const vx_size,
    ) -> vx_tensor;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a tensor data buffer with no direct\n user access. This function allows setting the tensor data dimensions or data format.\n \\details Virtual data objects allow users to connect various nodes within a\n graph via data references without access to that data, but they also permit the\n implementation to take maximum advantage of possible optimizations. Use this\n API to create a data reference to link two or more nodes together when the\n intermediate data are not required to be accessed by outside entities. This API\n in particular allows the user to define the tensor data format of the data without\n requiring the exact dimensions. Virtual objects are scoped within the graph\n they are declared a part of, and can't be shared outside of this scope.\n Since functions using tensors, need to understand the context of each dimension. We describe a layout of the dimensions in each function.\n That layout is not mandated. It is done specifically to explain the functions and not to mandate layout. Different implementation may have different layout.\n Therfore the layout description is logical and not physical. It refers to the order of dimensions given in <tt>\\ref vxCreateTensor</tt> and <tt>\\ref vxCreateVirtualTensor</tt>.\n \\param [in] graph The reference to the parent graph.\n \\param [in] number_of_dims The number of dimensions.\n \\param [in] dims Dimensions sizes in elements.\n \\param [in] data_type The <tt>\\ref vx_type_e</tt> that represents the data type of the tensor data elements.\n \\param [in] fixed_point_position Specifies the fixed point position when the input element type is integer. If 0, calculations are performed in integer math.\n \\return A tensor data reference.Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note Passing this reference to <tt>\\ref vxCopyTensorPatch</tt> will return an error.\n \\ingroup group_object_tensor"]
    pub fn vxCreateVirtualTensor(
        graph: vx_graph,
        number_of_dims: vx_size,
        dims: *const vx_size,
        data_type: vx_enum,
        fixed_point_position: vx_int8,
    ) -> vx_tensor;
}
extern "C" {
    #[doc = " \\brief Creates a reference to an tensor object that was externally allocated.\n \\param [in] context The reference to the implementation context.\n \\param [in] number_of_dims The number of dimensions.\n \\param [in] dims Dimensions sizes in elements.\n \\param [in] data_type The <tt>\\ref vx_type_e</tt> that represents the data type of the tensor data elements.\n \\param [in] fixed_point_position Specifies the fixed point position when the input element type is integer. if 0, calculations are performed in integer math.\n \\param [in] stride An array of stride in all dimensions in bytes. The stride value at index 0 must be size of the tensor data element type.\n \\param [in] ptr The platform-defined reference to tensor. See note below.\n \\param [in] memory_type <tt>\\ref vx_memory_type_e</tt>. When giving <tt>\\ref VX_MEMORY_TYPE_HOST</tt>\n the \\a ptr is assumed to be HOST accessible pointer to memory.\n \\return A tensor data reference. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\note The user must call vxMapTensorPatch prior to accessing the elements of a tensor, even if the\n tensor was created via <tt>\\ref vxCreateTensorFromHandle</tt>. Reads or writes to memory referenced\n by ptr after calling <tt>\\ref vxCreateTensorFromHandle</tt> without first calling\n <tt>\\ref vxMapTensorPatch</tt> will result in undefined behavior.\n The property of stride[] and ptr is kept by the caller (It means that the implementation will\n make an internal copy of the provided information. \\a stride and \\a ptr can then simply be application's\n local variables).\n\n In order to release the tensor back to the application we should use <tt>\\ref vxSwapTensorHandle</tt>.\n\n \\ingroup group_object_tensor"]
    pub fn vxCreateTensorFromHandle(
        context: vx_context,
        number_of_dims: vx_size,
        dims: *const vx_size,
        data_type: vx_enum,
        fixed_point_position: vx_int8,
        stride: *const vx_size,
        ptr: *mut ::std::os::raw::c_void,
        memory_type: vx_enum,
    ) -> vx_tensor;
}
extern "C" {
    #[doc = " \\brief Swaps the tensor handle of an tensor previously created from handle.\n\n This function sets the new tensor handle\n and returns the previous one.\n\n Once this function call has completed, the application gets back the\n ownership of the memory referenced by the previous handle. This memory\n contains up-to-date tensor data, and the application can safely reuse or\n release it.\n\n The memory referenced by the new handle must have been allocated\n consistently with the tensor properties since the import type,\n memory layout and dimensions are unchanged (see stride and\n memory_type in <tt>\\ref vxCreateTensorFromHandle</tt>).\n\n All tensors created from view with this tensor as parent or ancestor\n will automatically use the memory referenced by the new handle.\n\n The behavior of <tt>\\ref vxSwapTensorHandle</tt> when called from a user node is undefined.\n \\param [in] tensor The reference to an tensor created from handle.\n \\param [in] new_ptr new tensor handle\n  If new_ptr is NULL,\n  If the new_ptr is NULL, the previous tensor storage memory is reclaimed by the\n  caller, while no new handle is provided.\n \\param [out] prev_ptr pointer to return the previous tensor handle.\n If prev_ptr is NULL, the previous handle is not returned.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE tensor is not a valid <tt>\\ref vx_tensor</tt> reference.\n reference.\n \\retval VX_ERROR_INVALID_PARAMETERS The tensor was not created from handle or\n the content of new_ptr is not valid.\n \\retval VX_FAILURE The tensor was already being accessed.\n \\ingroup group_tensor"]
    pub fn vxSwapTensorHandle(
        tensor: vx_tensor,
        new_ptr: *mut ::std::os::raw::c_void,
        prev_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy a view patch from/into an tensor object .\n \\param [in] tensor The reference to the tensor object that is the source or the\n destination of the copy.\n \\param [in] number_of_dims Number of patch dimension. Error return if 0 or greater than number of\n tensor dimensions. If smaller than number of tensor dimensions, the lower dimensions are assumed.\n \\param [in] view_start Array of patch start points in each dimension\n \\param [in] view_end Array of patch end points in each dimension\n \\param [in] user_stride Array of user memory strides in each dimension\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the tensor\n object if the copy was requested in write mode. The accessible memory must be large enough\n to contain the specified patch with the specified layout:\\n\n accessible memory in bytes >= (end[last_dimension] - start[last_dimension]) * stride[last_dimension].\\n\n The layout of the user memory must follow a row major order.\n \\param [in] usage This declares the effect of the copy with regard to the tensor object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt> are supported:\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data is copied from the tensor object into the application memory\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data is copied into the tensor object from the application memory\n \\param [in] user_memory_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual tensor that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE The tensor reference is not actually an tensor reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_object_tensor"]
    pub fn vxCopyTensorPatch(
        tensor: vx_tensor,
        number_of_dims: vx_size,
        view_start: *const vx_size,
        view_end: *const vx_size,
        user_stride: *const vx_size,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_memory_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to a patch of tensor object.\n \\param [in] tensor The reference to the tensor object that is the source or the\n destination for direct access.\n \\param [in] number_of_dims The number of dimensions. Must be same as tensor number_of_dims.\n \\param [in] view_start Array of patch start points in each dimension. This is optional parameter and will be zero when NULL.\n \\param [in] view_end Array of patch end points in each dimension. This is optional parameter and will be dims[] of tensor when NULL.\n \\param [out] map_id The address of a vx_map_id variable where the function returns a map identifier.\n \\arg (*map_id) must eventually be provided as the map_id parameter of a call to <tt>\\ref vxUnmapTensorPatch</tt>.\n \\param [out] stride An array of stride in all dimensions in bytes. The stride value at index 0 must be size of the tensor data element type.\n \\param [out] ptr The address of a pointer that the function sets to the\n address where the requested data can be accessed. The returned (*ptr) address\n is only valid between the call to the function and the corresponding call to\n <tt>\\ref vxUnmapTensorPatch</tt>.\n \\param [in] usage This declares the access mode for the tensor patch, using\n the <tt>\\ref vx_accessor_e</tt> enumeration.\n \\arg VX_READ_ONLY: after the function call, the content of the memory location\n pointed by (*ptr) contains the tensor patch data. Writing into this memory location\n is forbidden and its behavior is undefined.\n \\arg VX_READ_AND_WRITE : after the function call, the content of the memory\n location pointed by (*ptr) contains the tensor patch data; writing into this memory\n is allowed only for the location of items and will result in a modification of the\n affected items in the tensor object once the range is unmapped. Writing into\n a gap between items (when (*stride) > item size in bytes) is forbidden and its\n behavior is undefined.\n \\arg VX_WRITE_ONLY: after the function call, the memory location pointed by (*ptr)\n contains undefined data; writing each item of the range is required prior to\n unmapping. Items not written by the application before unmap will become\n undefined after unmap, even if they were well defined before map. Like for\n VX_READ_AND_WRITE, writing into a gap between items is forbidden and its behavior\n is undefined.\n \\param [in] mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that\n specifies the type of the memory where the tensor patch is requested to be mapped.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual tensor that cannot be accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE The tensor reference is not actually an tensor reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\retval VX_ERROR_NO_MEMORY Internal memory allocation failed.\n \\ingroup group_tensor\n \\post <tt>\\ref vxUnmapTensorPatch </tt> with same (*map_id) value."]
    pub fn vxMapTensorPatch(
        tensor: vx_tensor,
        number_of_dims: vx_size,
        view_start: *const vx_size,
        view_end: *const vx_size,
        map_id: *mut vx_map_id,
        stride: *mut vx_size,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
        mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to a tensor object patch that was previously mapped.\n Unmapping a tensor patch invalidates the memory location from which the patch could\n be accessed by the application. Accessing this memory location after the unmap function\n completes has an undefined behavior.\n \\param [in] tensor The reference to the tensor object to unmap.\n \\param [in] map_id The unique map identifier that was returned when calling\n <tt>\\ref vxMapTensorPatch</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_INVALID_REFERENCE The tensor reference is not actually an tensor reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_tensor\n \\pre <tt>\\ref vxMapTensorPatch</tt> returning the same map_id value"]
    pub fn vxUnmapTensorPatch(tensor: vx_tensor, map_id: vx_map_id) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Retrieves various attributes of a tensor data.\n \\param [in] tensor The reference to the tensor data to query.\n \\param [in] attribute The attribute to query. Use a <tt>\\ref vx_tensor_attribute_e</tt>.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE If data is not a <tt>\\ref vx_tensor</tt>.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\ingroup group_object_tensor"]
    pub fn vxQueryTensor(
        tensor: vx_tensor,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Releases a reference to a tensor data object.\n The object may not be garbage collected until its total reference count is zero.\n \\param [in] tensor The pointer to the tensor data to release.\n \\post After returning from this function the reference is zeroed.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; all other values indicate failure\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_object_tensor"]
    pub fn vxReleaseTensor(tensor: *mut vx_tensor) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a color conversion node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image from which to convert.\n \\param [out] output The output image to which to convert, which must have the same dimensions as the input image.\n \\see <tt>VX_KERNEL_COLOR_CONVERT</tt>\n \\ingroup group_vision_function_colorconvert\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxColorConvertNode(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a channel extract node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image. Must be one of the defined \\ref vx_df_image_e multi-channel formats.\n \\param [in] channel The <tt>\\ref vx_channel_e</tt> channel to extract.\n \\param [out] output The output image. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>, and must have the same dimensions as the input image.\n <tt>\\see VX_KERNEL_CHANNEL_EXTRACT</tt>\n \\ingroup group_vision_function_channelextract\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxChannelExtractNode(
        graph: vx_graph,
        input: vx_image,
        channel: vx_enum,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a channel combine node.\n \\param [in] graph The graph reference.\n \\param [in] plane0 The plane that forms channel 0. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] plane1 The plane that forms channel 1. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] plane2 [optional] The plane that forms channel 2. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] plane3 [optional] The plane that forms channel 3. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [out] output The output image. The format of the image must be defined, even if the image is virtual. Must have the same dimensions as the input images\n \\see <tt>VX_KERNEL_CHANNEL_COMBINE</tt>\n \\ingroup group_vision_function_channelcombine\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxChannelCombineNode(
        graph: vx_graph,
        plane0: vx_image,
        plane1: vx_image,
        plane2: vx_image,
        plane3: vx_image,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Phase node.\n \\param [in] graph The reference to the graph.\n \\param [in] grad_x The input x image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] grad_y The input y image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] orientation The phase image. This is in <tt>\\ref VX_DF_IMAGE_U8</tt> format, and must have the same dimensions as the input images.\n \\see <tt>VX_KERNEL_PHASE</tt>\n \\ingroup group_vision_function_phase\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxPhaseNode(
        graph: vx_graph,
        grad_x: vx_image,
        grad_y: vx_image,
        orientation: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Sobel3x3 node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output_x [optional] The output gradient in the x direction in <tt>\\ref VX_DF_IMAGE_S16</tt>. Must have the same dimensions as the input image.\n \\param [out] output_y [optional] The output gradient in the y direction in <tt>\\ref VX_DF_IMAGE_S16</tt>. Must have the same dimensions as the input image.\n \\see <tt>VX_KERNEL_SOBEL_3x3</tt>\n \\ingroup group_vision_function_sobel3x3\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxSobel3x3Node(
        graph: vx_graph,
        input: vx_image,
        output_x: vx_image,
        output_y: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Create a Magnitude node.\n \\param [in] graph The reference to the graph.\n \\param [in] grad_x The input x image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] grad_y The input y image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] mag The magnitude image. This is in <tt>\\ref VX_DF_IMAGE_S16</tt> format. Must have the same dimensions as the input image.\n \\see <tt>VX_KERNEL_MAGNITUDE</tt>\n \\ingroup group_vision_function_magnitude\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMagnitudeNode(
        graph: vx_graph,
        grad_x: vx_image,
        grad_y: vx_image,
        mag: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Scale Image Node.\n \\param [in] graph The reference to the graph.\n \\param [in] src The source image of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt>.\n \\param [out] dst The destination image of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt>. The output type must be the same as that of the input image.\n \\param [in] type The interpolation type to use. \\see vx_interpolation_type_e.\n \\ingroup group_vision_function_scale_image\n \\note The destination image must have a defined size and format. The border modes\n  <tt>\\ref VX_NODE_BORDER</tt> value <tt>\\ref VX_BORDER_UNDEFINED</tt>,\n  <tt>\\ref VX_BORDER_REPLICATE</tt> and <tt>\\ref VX_BORDER_CONSTANT</tt> are supported.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxScaleImageNode(
        graph: vx_graph,
        src: vx_image,
        dst: vx_image,
        type_: vx_enum,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Table Lookup node. If a value from the input image is not present in the lookup table, the result is undefined.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] lut The LUT which is of type <tt>\\ref VX_TYPE_UINT8</tt> if input image is <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_TYPE_INT16</tt> if input image is <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] output The output image of the same size as the input image.\n \\ingroup group_vision_function_lut\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTableLookupNode(
        graph: vx_graph,
        input: vx_image,
        lut: vx_lut,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Histogram node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [out] distribution The output distribution.\n \\ingroup group_vision_function_histogram\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxHistogramNode(
        graph: vx_graph,
        input: vx_image,
        distribution: vx_distribution,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Histogram Equalization node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The grayscale input image in <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [out] output The grayscale output image of type <tt>\\ref VX_DF_IMAGE_U8</tt> with equalized brightness and contrast and same size as the input image.\n \\ingroup group_vision_function_equalize_hist\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxEqualizeHistNode(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an AbsDiff node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 An input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] in2 An input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] out The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format, which must have the same dimensions as the input image.\n \\ingroup group_vision_function_absdiff\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxAbsDiffNode(graph: vx_graph, in1: vx_image, in2: vx_image, out: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a mean value and optionally, a standard deviation node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image. <tt>\\ref VX_DF_IMAGE_U8</tt> and <tt>\\ref VX_DF_IMAGE_U1</tt> are supported.\n \\param [out] mean The <tt>\\ref VX_TYPE_FLOAT32</tt> average pixel value.\n \\param [out] stddev [optional] The <tt>\\ref VX_TYPE_FLOAT32</tt> standard deviation of the pixel values.\n \\ingroup group_vision_function_meanstddev\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMeanStdDevNode(
        graph: vx_graph,
        input: vx_image,
        mean: vx_scalar,
        stddev: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Threshold node and returns a reference to it.\n \\param [in] graph The reference to the graph in which the node is created.\n \\param [in] input The input image. Only images with format <tt>\\ref VX_DF_IMAGE_U8</tt>\n and <tt>\\ref VX_DF_IMAGE_S16</tt> are supported.\n \\param [in] thresh The thresholding object that defines the parameters of\n the operation. The <tt>\\ref VX_THRESHOLD_INPUT_FORMAT</tt> must be the same as the input image format and\n the <tt>\\ref VX_THRESHOLD_OUTPUT_FORMAT</tt> must be the same as the output image format.\n \\param [out] output The output image, that will contain as pixel value\n true and false values defined by \\p thresh. Images with format\n <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> are supported. The dimensions are the same as the input image.\n \\ingroup group_vision_function_threshold\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation\n should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxThresholdNode(
        graph: vx_graph,
        input: vx_image,
        thresh: vx_threshold,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Non-Maxima Suppression node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] mask [optional] Constrict suppression to a ROI. The mask image is of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> and must have the same dimensions as the input image.\n \\param [in] win_size The size of window over which to perform the localized non-maxima suppression. Must be odd, and less than or equal to the smallest dimension of the input image.\n \\param [out] output The output image, of the same type and size as the input, that has been non-maxima suppressed.\n \\ingroup group_vision_function_nms\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxNonMaxSuppressionNode(
        graph: vx_graph,
        input: vx_image,
        mask: vx_image,
        win_size: vx_int32,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an Integral Image Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U32</tt> format, which must have the same dimensions as the input image.\n \\ingroup group_vision_function_integral_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxIntegralImageNode(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an Erosion Image Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_erode_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxErode3x3Node(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Dilation Image Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_dilate_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxDilate3x3Node(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Median Image Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_median_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMedian3x3Node(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Box Filter Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> format, which must have the same dimensions as the input image.\n \\ingroup group_vision_function_box_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxBox3x3Node(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Gaussian Filter Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> format, which must have the same dimensions as the input image.\n \\ingroup group_vision_function_gaussian_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxGaussian3x3Node(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Non-linear Filter Node.\n \\param [in] graph The reference to the graph.\n \\param [in] function The non-linear filter function. See <tt>\\ref vx_non_linear_filter_e</tt>.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [in] mask The mask to be applied to the Non-linear function. <tt>\\ref VX_MATRIX_ORIGIN</tt> attribute is used\n  to place the mask appropriately when computing the resulting image. See <tt>\\ref vxCreateMatrixFromPattern</tt>.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which must have the same dimensions and type as the input image.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_nonlinear_filter"]
    pub fn vxNonLinearFilterNode(
        graph: vx_graph,
        function: vx_enum,
        input: vx_image,
        mask: vx_matrix,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a custom convolution node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [in] conv The <tt>\\ref vx_int16</tt> convolution matrix.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format, which must have the same dimensions as the input image.\n \\ingroup group_vision_function_custom_convolution\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxConvolveNode(
        graph: vx_graph,
        input: vx_image,
        conv: vx_convolution,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a node for a Gaussian Image Pyramid.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] gaussian The Gaussian pyramid with <tt>\\ref VX_DF_IMAGE_U8</tt> to construct.\n \\ingroup group_vision_function_gaussian_pyramid\n \\see group_pyramid\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxGaussianPyramidNode(graph: vx_graph, input: vx_image, gaussian: vx_pyramid)
        -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a node for a Laplacian Image Pyramid.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] laplacian The Laplacian pyramid with <tt>\\ref VX_DF_IMAGE_S16</tt> to construct.\n \\param [out] output The lowest resolution image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format necessary to reconstruct the input image from the pyramid. The output image format should be same as input image format.\n \\ingroup group_vision_function_laplacian_pyramid\n \\see group_pyramid\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxLaplacianPyramidNode(
        graph: vx_graph,
        input: vx_image,
        laplacian: vx_pyramid,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Reconstructs an image from a Laplacian Image pyramid.\n \\param [in] graph The reference to the graph.\n \\param [in] laplacian The Laplacian pyramid with <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] input The lowest resolution image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format for the Laplacian pyramid.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format with the highest possible resolution reconstructed from the Laplacian pyramid. The output image format should be same as input image format.\n \\ingroup group_vision_function_laplacian_reconstruct\n \\see group_pyramid\n \\return <tt>\\ref vx_node</tt>.\n \\retval 0 Node could not be created.\n \\retval * Node handle."]
    pub fn vxLaplacianReconstructNode(
        graph: vx_graph,
        laplacian: vx_pyramid,
        input: vx_image,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a image weighted average node.\n \\param [in] graph The reference to the graph.\n \\param [in] img1 The first input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] alpha The input <tt>\\ref VX_TYPE_FLOAT32</tt> scalar value with a value in the range of \\f$ 0.0 \\le \\alpha \\le 1.0 \\f$.\n \\param [in] img2 The second <tt>\\ref VX_DF_IMAGE_U8</tt> image, which must have the same dimensions as the img1.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image, which must have the same dimensions as the img1.\n \\ingroup group_vision_function_weighted_average\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxWeightedAverageNode(
        graph: vx_graph,
        img1: vx_image,
        alpha: vx_scalar,
        img2: vx_image,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a min,max,loc node.\n \\param [in] graph The reference to create the graph.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] minVal The minimum value in the image, which corresponds to the type of the input.\n \\param [out] maxVal The maximum value in the image, which corresponds to the type of the input.\n \\param [out] minLoc [optional] The minimum <tt>\\ref VX_TYPE_COORDINATES2D</tt> locations. If the input image has several minimums, the kernel will return up to the capacity of the array.\n \\param [out] maxLoc [optional] The maximum <tt>\\ref VX_TYPE_COORDINATES2D</tt> locations. If the input image has several maximums, the kernel will return up to the capacity of the array.\n \\param [out] minCount [optional] The total number of detected minimums in image. Use a <tt>\\ref VX_TYPE_SIZE</tt> scalar.\n \\param [out] maxCount [optional] The total number of detected maximums in image. Use a <tt>\\ref VX_TYPE_SIZE</tt> scalar.\n \\ingroup group_vision_function_minmaxloc\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMinMaxLocNode(
        graph: vx_graph,
        input: vx_image,
        minVal: vx_scalar,
        maxVal: vx_scalar,
        minLoc: vx_array,
        maxLoc: vx_array,
        minCount: vx_scalar,
        maxCount: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a pixel-wise minimum kernel.\n \\param [in] graph The reference to the graph where to create the node.\n \\param [in] in1 The first input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] in2 The second input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] out The output image which will hold the result of min and will have the same type and dimensions of the imput images.\n \\ingroup group_vision_function_min\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMinNode(graph: vx_graph, in1: vx_image, in2: vx_image, out: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a pixel-wise maximum kernel.\n \\param [in] graph The reference to the graph where to create the node.\n \\param [in] in1 The first input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] in2 The second input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] out The output image which will hold the result of max and will have the same type and dimensions of the imput images.\n \\ingroup group_vision_function_max\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMaxNode(graph: vx_graph, in1: vx_image, in2: vx_image, out: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a bitwise AND node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] out The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the same dimensions and type as the input images.\n \\ingroup group_vision_function_and\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxAndNode(graph: vx_graph, in1: vx_image, in2: vx_image, out: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a bitwise INCLUSIVE OR node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] out The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the same dimensions and type as the input images.\n \\ingroup group_vision_function_or\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxOrNode(graph: vx_graph, in1: vx_image, in2: vx_image, out: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a bitwise EXCLUSIVE OR node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] out The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the same dimensions and type as the input images.\n \\ingroup group_vision_function_xor\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxXorNode(graph: vx_graph, in1: vx_image, in2: vx_image, out: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a bitwise NOT node.\n \\param [in] graph The reference to the graph.\n \\param [in] input A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] output The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_not\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxNotNode(graph: vx_graph, input: vx_image, output: vx_image) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a scalar operation node.\n \\param [in] graph The reference to the graph.\n \\param [in] scalar_operation A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_scalar_operation_e</tt> enumeration.\n \\param [in] a First scalar operand.\n \\param [in] b Second scalar operand.\n \\param [out] output Result of the scalar operation.\n \\ingroup group_control_flow\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxScalarOperationNode(
        graph: vx_graph,
        scalar_operation: vx_enum,
        a: vx_scalar,
        b: vx_scalar,
        output: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Selects one of two data objects depending on the the value of a condition (boolean scalar), and copies its data into another data object.\n \\details This node supports predicated execution flow within a graph. All the data objects passed to this kernel shall\n have the same object type and meta data. It is important to note that an implementation may optimize away the select and copy when virtual data\n objects are used.\\n\n If there is a kernel node that contribute only into virtual data objects during the graph execution due to certain data path being eliminated by not\n taken argument of select node, then the OpenVX implementation guarantees that there will not be any side effects to graph execution and node state.\\n\n If the path to a select node contains non-virtual objects, user nodes, or  nodes with completion callbacks, then that path may not be \"optimized out\"\n because the callback must be executed and the non-virtual objects must be modified.\n \\param [in] graph The reference to the graph.\n \\param [in] condition <tt>\\ref VX_TYPE_BOOL</tt> predicate variable.\n \\param [in] true_value Data object for true.\n \\param [in] false_value Data object for false.\n \\param [out] output Output data object.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_control_flow"]
    pub fn vxSelectNode(
        graph: vx_graph,
        condition: vx_scalar,
        true_value: vx_reference,
        false_value: vx_reference,
        output: vx_reference,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an pixelwise-multiplication node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 An input image, <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] in2 An input image, <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] scale A non-negative <tt>\\ref VX_TYPE_FLOAT32</tt> multiplied to each product before overflow handling.\n \\param [in] overflow_policy A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] rounding_policy A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_round_policy_e</tt> enumeration.\n \\param [out] out The output image, a <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> image. Must have the same type and dimensions of the imput images.\n \\ingroup group_vision_function_mult\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxMultiplyNode(
        graph: vx_graph,
        in1: vx_image,
        in2: vx_image,
        scale: vx_scalar,
        overflow_policy: vx_enum,
        rounding_policy: vx_enum,
        out: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an arithmetic addition node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 An input image, <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] in2 An input image, <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] policy A <tt>\\ref VX_TYPE_ENUM</tt> of the \\ref vx_convert_policy_e enumeration.\n \\param [out] out The output image, a <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> image, which must have the same dimensions as the input images.\n \\ingroup group_vision_function_add\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxAddNode(
        graph: vx_graph,
        in1: vx_image,
        in2: vx_image,
        policy: vx_enum,
        out: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an arithmetic subtraction node.\n \\param [in] graph The reference to the graph.\n \\param [in] in1 An input image, <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>, the minuend.\n \\param [in] in2 An input image, <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>, the subtrahend.\n \\param [in] policy A <tt>\\ref VX_TYPE_ENUM</tt> of the \\ref vx_convert_policy_e enumeration.\n \\param [out] out The output image, a <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> image, which must have the same dimensions as the input images.\n \\ingroup group_vision_function_sub\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxSubtractNode(
        graph: vx_graph,
        in1: vx_image,
        in2: vx_image,
        policy: vx_enum,
        out: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a bit-depth conversion node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image.\n \\param [out] output The output image with the same dimensions of the input image.\n \\param [in] policy A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] shift A scalar containing a <tt>\\ref VX_TYPE_INT32</tt> of the shift value.\n \\ingroup group_vision_function_convertdepth\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxConvertDepthNode(
        graph: vx_graph,
        input: vx_image,
        output: vx_image,
        policy: vx_enum,
        shift: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Canny Edge Detection Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] hyst The double threshold for hysteresis. The <tt>\\ref VX_THRESHOLD_INPUT_FORMAT</tt> shall be either\n <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>. The <tt>\\ref VX_THRESHOLD_OUTPUT_FORMAT</tt> is ignored.\n \\param [in] gradient_size The size of the Sobel filter window, must support at least 3, 5, and 7.\n \\param [in] norm_type A flag indicating the norm used to compute the gradient, <tt>\\ref VX_NORM_L1</tt> or <tt>\\ref VX_NORM_L2</tt>.\n \\param [out] output The binary output image in <tt>\\ref VX_DF_IMAGE_U1</tt> or <tt>\\ref VX_DF_IMAGE_U8</tt> format\n with values either 0 and 1 (<tt>VX_DF_IMAGE_U1</tt>), or 0 and 255 (<tt>VX_DF_IMAGE_U8</tt>).\n \\ingroup group_vision_function_canny\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxCannyEdgeDetectorNode(
        graph: vx_graph,
        input: vx_image,
        hyst: vx_threshold,
        gradient_size: vx_int32,
        norm_type: vx_enum,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates an Affine Warp Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> image.\n \\param [in] matrix The affine matrix. Must be 2x3 of type \\ref VX_TYPE_FLOAT32.\n \\param [in] type The interpolation type from <tt>\\ref vx_interpolation_type_e</tt>.\n <tt>\\ref VX_INTERPOLATION_AREA</tt> is not supported.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> image with the same format as the input image.\n \\ingroup group_vision_function_warp_affine\n \\note The border modes <tt>\\ref VX_NODE_BORDER</tt> value <tt>\\ref VX_BORDER_UNDEFINED</tt> and\n <tt>\\ref VX_BORDER_CONSTANT</tt> are supported.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxWarpAffineNode(
        graph: vx_graph,
        input: vx_image,
        matrix: vx_matrix,
        type_: vx_enum,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Perspective Warp Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] matrix The perspective matrix. Must be 3x3 of type <tt>\\ref VX_TYPE_FLOAT32</tt>.\n \\param [in] type The interpolation type from <tt>\\ref vx_interpolation_type_e</tt>.\n <tt>\\ref VX_INTERPOLATION_AREA</tt> is not supported.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\ingroup group_vision_function_warp_perspective\n \\note The border modes <tt>\\ref VX_NODE_BORDER</tt> value <tt>\\ref VX_BORDER_UNDEFINED</tt> and\n <tt>\\ref VX_BORDER_CONSTANT</tt> are supported.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxWarpPerspectiveNode(
        graph: vx_graph,
        input: vx_image,
        matrix: vx_matrix,
        type_: vx_enum,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Harris Corners Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] strength_thresh The <tt>\\ref VX_TYPE_FLOAT32</tt> minimum threshold with which to eliminate Harris Corner scores (computed using the normalized Sobel kernel).\n \\param [in] min_distance The <tt>\\ref VX_TYPE_FLOAT32</tt> radial Euclidean distance for non-maximum suppression.\n \\param [in] sensitivity The <tt>\\ref VX_TYPE_FLOAT32</tt> scalar sensitivity threshold \\f$ k \\f$ from the Harris-Stephens equation.\n \\param [in] gradient_size The gradient window size to use on the input. The\n implementation must support at least 3, 5, and 7.\n \\param [in] block_size The block window size used to compute the Harris Corner score.\n The implementation must support at least 3, 5, and 7.\n \\param [out] corners The array of <tt>\\ref VX_TYPE_KEYPOINT</tt> objects. The order of the keypoints in this array is implementation dependent.\n \\param [out] num_corners [optional] The total number of detected corners in image. Use a \\ref VX_TYPE_SIZE scalar.\n \\ingroup group_vision_function_harris\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxHarrisCornersNode(
        graph: vx_graph,
        input: vx_image,
        strength_thresh: vx_scalar,
        min_distance: vx_scalar,
        sensitivity: vx_scalar,
        gradient_size: vx_int32,
        block_size: vx_int32,
        corners: vx_array,
        num_corners: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a FAST Corners Node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] strength_thresh Threshold on difference between intensity of the central pixel and pixels on Bresenham's circle\n of radius 3 (<tt>\\ref VX_TYPE_FLOAT32</tt> scalar), with a value in the range of 0.0 \\f$\\le\\f$ strength_thresh < 256.0.\n  Any fractional value will be truncated to an integer.\n \\param [in] nonmax_suppression If true, non-maximum suppression is applied to\n detected corners before being placed in the <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt> objects.\n \\param [out] corners Output corner <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt>. The order of the\n                      keypoints in this array is implementation dependent.\n \\param [out] num_corners [optional] The total number of detected corners in image. Use a \\ref VX_TYPE_SIZE scalar.\n \\ingroup group_vision_function_fast\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxFastCornersNode(
        graph: vx_graph,
        input: vx_image,
        strength_thresh: vx_scalar,
        nonmax_suppression: vx_bool,
        corners: vx_array,
        num_corners: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Lucas Kanade Tracking Node.\n \\param [in] graph The reference to the graph.\n \\param [in] old_images Input of first (old) image pyramid in <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] new_images Input of destination (new) image pyramid <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] old_points An array of key points in a <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt>; those key points are defined at\n  the \\a old_images high resolution pyramid.\n \\param [in] new_points_estimates An array of estimation on what is the output key points in a <tt>\\ref vx_array</tt> of\n  <tt>\\ref VX_TYPE_KEYPOINT</tt>; those keypoints are defined at the \\a new_images high resolution pyramid.\n \\param [out] new_points An output array of key points in a <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt>; those key points are\n  defined at the \\a new_images high resolution pyramid.\n \\param [in] termination The termination can be <tt>\\ref VX_TERM_CRITERIA_ITERATIONS</tt> or <tt>\\ref VX_TERM_CRITERIA_EPSILON</tt> or\n <tt>\\ref VX_TERM_CRITERIA_BOTH</tt>.\n \\param [in] epsilon The <tt>\\ref vx_float32</tt> error for terminating the algorithm.\n \\param [in] num_iterations The number of iterations. Use a <tt>\\ref VX_TYPE_UINT32</tt> scalar.\n \\param [in] use_initial_estimate Use a <tt>\\ref VX_TYPE_BOOL</tt> scalar.\n \\param [in] window_dimension The size of the window on which to perform the algorithm. See\n  <tt>\\ref VX_CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION</tt>\n \\ingroup group_vision_function_opticalflowpyrlk\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxOpticalFlowPyrLKNode(
        graph: vx_graph,
        old_images: vx_pyramid,
        new_images: vx_pyramid,
        old_points: vx_array,
        new_points_estimates: vx_array,
        new_points: vx_array,
        termination: vx_enum,
        epsilon: vx_scalar,
        num_iterations: vx_scalar,
        use_initial_estimate: vx_scalar,
        window_dimension: vx_size,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a Remap Node.\n \\param [in] graph The reference to the graph that will contain the node.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] table The remap table object.\n \\param [in] policy An interpolation type from <tt>\\ref vx_interpolation_type_e</tt>.\n <tt>\\ref VX_INTERPOLATION_AREA</tt> is not supported.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image with the same dimensions as the input image.\n \\note The border modes <tt>\\ref VX_NODE_BORDER</tt> value <tt>\\ref VX_BORDER_UNDEFINED</tt> and\n <tt>\\ref VX_BORDER_CONSTANT</tt> are supported.\n \\return A <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_remap"]
    pub fn vxRemapNode(
        graph: vx_graph,
        input: vx_image,
        table: vx_remap,
        policy: vx_enum,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs a Gaussian Blur on an image then half-scales it. The interpolation mode used is nearest-neighbor.\n \\details The output image size is determined by:\n \\f[\n W_{output} = \\frac{W_{input} + 1}{2} \\\\\n ,\n H_{output} = \\frac{H_{input} + 1}{2}\n \\f]\n \\param [in] graph The reference to the graph.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] kernel_size The input size of the Gaussian filter. Supported values are 1, 3 and 5.\n \\ingroup group_vision_function_scale_image\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxHalfScaleGaussianNode(
        graph: vx_graph,
        input: vx_image,
        output: vx_image,
        kernel_size: vx_int32,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph]  The Node Compares an image template against overlapped image regions.\n \\details The detailed equation to the matching can be found in <tt>\\ref vx_comp_metric_e</tt>.\n The output of the template matching node is a comparison map as described in <tt>\\ref vx_comp_metric_e</tt>.\n The Node have a limitation on the template image size (width*height). It should not be larger then 65535.\n If the valid region of the template image is smaller than the entire template image, the result in the destination image is implementation-dependent.\n \\param [in] graph The reference to the graph.\n \\param [in] src The input image of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] templateImage Searched template of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] matchingMethod attribute specifying the comparison method <tt>\\ref vx_comp_metric_e</tt>. This function support only <tt>\\ref VX_COMPARE_CCORR_NORM</tt> and <tt>\\ref VX_COMPARE_L2</tt>.\n \\param [out] output Map of comparison results. The output is an image of type VX_DF_IMAGE_S16\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_match_template"]
    pub fn vxMatchTemplateNode(
        graph: vx_graph,
        src: vx_image,
        templateImage: vx_image,
        matchingMethod: vx_enum,
        output: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a node that extracts LBP image from an input image\n \\param [in] graph\tThe reference to the graph.\n \\param [in] in\t\tAn input image in <tt>vx_image</tt>. Or \\f$ SrcImg\\f$ in the equations. the image is of type <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\param [in] format\tA variation of LBP like original LBP and mLBP. see <tt> \\ref vx_lbp_format_e </tt>\n \\param [in] kernel_size Kernel size. Only size of 3 and 5 are supported\n \\param [out] out\tAn output image in <tt>vx_image</tt>.Or \\f$ DstImg\\f$ in the equations. the image is of type <tt>\\ref VX_DF_IMAGE_U8</tt> with the same dimensions as the input image.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_lbp"]
    pub fn vxLBPNode(
        graph: vx_graph,
        in_: vx_image,
        format: vx_enum,
        kernel_size: vx_int8,
        out: vx_image,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs cell calculations for the average gradient magnitude and gradient orientation histograms.\n \\details Firstly, the gradient magnitude and gradient orientation are computed for each pixel in the input image.\n Two 1-D centred, point discrete derivative masks are applied to the input image in the horizontal and vertical directions.\n \\f[ M_h = [-1, 0, 1] \\f] and \\f[ M_v = [-1, 0, 1]^T \\f]\n \\f$G_v\\f$ is the result of applying mask \\f$M_v\\f$ to the input image, and \\f$G_h\\f$ is the result of applying mask \\f$M_h\\f$ to the input image.\n The border mode used for the gradient calculation is implementation dependent. Its behavior should be similar to <tt>\\ref VX_BORDER_UNDEFINED</tt>.\n The gradient magnitudes and gradient orientations for each pixel are then calculated in the following manner.\n \\f[ G(x,y) = \\sqrt{G_v(x,y)^2 + G_h(x,y)^2} \\f]\n \\f[ \\theta(x,y) = arctan(G_v(x,y), G_h(x,y)) \\f]\n where \\f$arctan(v, h)\\f$\n is \\f$ tan^{-1}(v/h)\\f$ when \\f$h!=0\\f$,\n\n \\f$ -pi/2 \\f$ if \\f$v<0\\f$ and \\f$h==0\\f$,\n\n \\f$  pi/2  \\f$ if \\f$v>0\\f$ and \\f$h==0\\f$\n\n and \\f$     0  \\f$ if \\f$v==0\\f$ and \\f$h==0\\f$\n\n Secondly, the gradient magnitudes and orientations are used to compute the bins output tensor and optional magnitudes output tensor.\n These tensors are computed on a cell level where the cells are rectangular in shape.\n The magnitudes tensor contains the average gradient magnitude for each cell.\n \\f[magnitudes(c) = \\frac{1}{(cell\\_width * cell\\_height)}\\sum\\limits_{w=0}^{cell\\_width} \\sum\\limits_{h=0}^{cell\\_height} G_c(w,h)\\f]\n where \\f$G_c\\f$ is the gradient magnitudes related to cell \\f$c\\f$.\n The bins tensor contains histograms of gradient orientations for each cell.\n The gradient orientations at each pixel range from 0 to 360 degrees.  These are quantised into a set of histogram bins based on the num_bins parameter.\n Each pixel votes for a specific cell histogram bin based on its gradient orientation.  The vote itself is the pixel's gradient magnitude.\n \\f[bins(c, n) = \\sum\\limits_{w=0}^{cell\\_width} \\sum\\limits_{h=0}^{cell\\_height} G_c(w,h) * 1[B_c(w, h, num\\_bins) == n]\\f]\n where \\f$B_c\\f$ produces the histogram bin number based on the gradient orientation of the pixel at location (\\f$w\\f$, \\f$h\\f$) in cell \\f$c\\f$ based on\n the \\f$num\\_bins\\f$ and \\f[1[B_c(w, h, num\\_bins) == n]\\f] is a delta-function with value 1 when \\f$B_c(w, h, num\\_bins) == n\\f$ or 0 otherwise.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] cell_width The histogram cell width of type <tt>\\ref VX_TYPE_INT32</tt>.\n \\param [in] cell_height The histogram cell height of type <tt>\\ref VX_TYPE_INT32</tt>.\n \\param [in] num_bins  The histogram size of type <tt>\\ref VX_TYPE_INT32</tt>.\n \\param [out] magnitudes (Optional) The output average gradient magnitudes per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt> of size \\f$ [floor(image_{width}/cell_{width}) ,floor(image_{height}/cell_{height}) ] \\f$.\n \\param [out] bins       The output gradient orientation histograms per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt> of size \\f$ [floor(image_{width}/cell_{width}) ,floor(image_{height}/cell_{height}), num_{bins}] \\f$.\n \\return <tt>\\ref vx_node</tt>.\n \\retval 0 Node could not be created.\n \\retval * Node handle.\n \\ingroup group_vision_function_hog"]
    pub fn vxHOGCellsNode(
        graph: vx_graph,
        input: vx_image,
        cell_width: vx_int32,
        cell_height: vx_int32,
        num_bins: vx_int32,
        magnitudes: vx_tensor,
        bins: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] The node produces HOG features for the W1xW2 window in a sliding window fashion over the whole input image. Each position produces a HOG feature vector.\n \\details Firstly if a magnitudes tensor is provided the cell histograms in the bins tensor are normalised by the average cell gradient magnitudes.\n\\f[bins(c,n) = \\frac{bins(c,n)}{magnitudes(c)}\\f]\n To account for changes in illumination and contrast the cell histograms must be locally normalized which requires grouping the cell histograms together into larger spatially connected blocks.\n Blocks are rectangular grids represented by three parameters: the number of cells per block, the number of pixels per cell, and the number of bins per cell histogram.\n These blocks typically overlap, meaning that each cell histogram contributes more than once to the final descriptor.\n To normalize a block its cell histograms \\f$h\\f$ are grouped together to form a vector \\f$v = [h_1, h_2, h_3, ... , h_n]\\f$.\n This vector is normalised using L2-Hys which means performing L2-norm on this vector; clipping the result (by limiting the maximum values of v to be threshold) and renormalizing again. If the threshold is equal to zero then L2-Hys normalization is not performed.\n \\f[L2norm(v) = \\frac{v}{\\sqrt{\\|v\\|_2^2 + \\epsilon^2}}\\f]\n where \\f$ \\|v\\|_k \\f$ be its k-norm for k=1, 2, and \\f$ \\epsilon \\f$ be a small constant.\n For a specific window its HOG descriptor is then the concatenated vector of the components of the normalized cell histograms from all of the block regions contained in the window.\n The W1xW2 window starting position is at coordinates 0x0.\n If the input image has dimensions that are not an integer multiple of W1xW2 blocks with the specified stride, then the last positions that contain only a partial W1xW2 window\n will be calculated with the remaining part of the W1xW2 window padded with zeroes.\n The Window W1xW2 must also have a size so that it contains an integer number of cells, otherwise the node is not well-defined.\n The final output tensor will contain HOG descriptors equal to the number of windows in the input image.\n The output features tensor has 3 dimensions, given by:\\n\n \\f[[ (floor((image_{width}-window_{width})/window_{stride}) + 1),\\f]\n \\f[ (floor((image_{height}-window_{height})/window_{stride}) + 1),\\f]\n \\f[ floor((window_{width} - block_{width})/block_{stride} + 1) * floor((window_{height} - block_{height})/block_{stride} + 1) *\\f]\n \\f[ (((block_{width} * block_{height}) / (cell_{width} * cell_{height})) * num_{bins})] \\f]\n See <tt>\\ref vxCreateTensor</tt> and <tt>\\ref vxCreateVirtualTensor</tt>.\n We recommend the output tensors always be *virtual* objects, with this node connected directly to the classifier.\n The output tensor will be very large, and using non-virtual tensors will result in a poorly optimized implementation.\n Merging of this node with a classifier node such as that described in the classifier extension will result in better performance.\n Notice that this node creation function has more parameters than the corresponding kernel. Numbering of kernel parameters (required if you create this node using the generic interface) is explicitly specified here.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input image of type <tt>\\ref VX_DF_IMAGE_U8</tt>. (Kernel parameter #0)\n \\param [in] magnitudes (Optional) The gradient magnitudes per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt>. It is the output of <tt>\\ref vxHOGCellsNode</tt>.  (Kernel parameter #1)\n \\param [in] bins       The gradient orientation histograms per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt>. It is the output of <tt>\\ref vxHOGCellsNode</tt>. (Kernel parameter #2)\n \\param [in] params The parameters of type <tt>\\ref vx_hog_t</tt>.  (Kernel parameter #3)\n \\param [in] hog_param_size Size of <tt>\\ref vx_hog_t</tt> in bytes. Note that this parameter is not counted as one of the kernel parameters.\n \\param [out] features The output HOG features of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt>.  (Kernel parameter #4)\n \\return <tt>\\ref vx_node</tt>.\n \\retval 0 Node could not be created.\n \\retval * Node handle.\n \\ingroup group_vision_function_hog"]
    pub fn vxHOGFeaturesNode(
        graph: vx_graph,
        input: vx_image,
        magnitudes: vx_tensor,
        bins: vx_tensor,
        params: *const vx_hog_t,
        hog_param_size: vx_size,
        features: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Finds the Probabilistic Hough Lines detected in the input binary image, each line is stored in the output array as a set of points (x1, y1, x2, y2) .\n \\details Some implementations of the algorithm may have a random or non-deterministic element. If the target application is in a safety-critical environment this\n should be borne in mind and steps taken in the implementation, the application or both to achieve the level of determinism required by the system design.\n \\param [in] graph graph handle\n \\param [in] input A single channel binary source image of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt>.\n \\param [in] params parameters of the struct <tt>\\ref vx_hough_lines_p_t</tt>\n \\param [out] lines_array lines_array contains array of lines, see <tt>\\ref vx_line2d_t</tt> The order of lines in implementation dependent\n \\param [out] num_lines [optional] The total number of detected lines in image. Use a VX_TYPE_SIZE scalar\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_hough_lines_p"]
    pub fn vxHoughLinesPNode(
        graph: vx_graph,
        input: vx_image,
        params: *const vx_hough_lines_p_t,
        lines_array: vx_array,
        num_lines: vx_scalar,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] The function applies bilateral filtering to the input tensor.\n \\param [in] graph The reference to the graph.\n \\param [in] src The input data a <tt>\\ref vx_tensor</tt>. maximum 3 dimension and minimum 2. The tensor is of type <tt>\\ref VX_TYPE_UINT8</tt> or <tt>\\ref VX_TYPE_INT16</tt>.\n dimensions are [radiometric ,width,height] or [width,height].See <tt>\\ref vxCreateTensor</tt> and <tt>\\ref vxCreateVirtualTensor</tt>.\n \\param [in] diameter of each pixel neighbourhood that is used during filtering. Values of diameter must be odd. Bigger then 3 and smaller then 10.\n \\param [in] sigmaValues Filter sigma in the radiometric space. Supported values are bigger then 0 and smaller or equal 20.\n \\param [in] sigmaSpace Filter sigma in the spatial space. Supported values are bigger then 0 and smaller or equal 20.\n \\param [out] dst The output data a <tt>\\ref vx_tensor</tt>,Of type <tt>\\ref VX_TYPE_UINT8</tt> or <tt>\\ref VX_TYPE_INT16</tt>. And must be the same type and size of the input.\n \\note The border modes\n  <tt>\\ref VX_NODE_BORDER</tt> value\n  <tt>\\ref VX_BORDER_REPLICATE</tt> and <tt>\\ref VX_BORDER_CONSTANT</tt> are supported.\n \\return <tt>vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>vxGetStatus</tt>\n \\ingroup group_vision_function_bilateral_filter"]
    pub fn vxBilateralFilterNode(
        graph: vx_graph,
        src: vx_tensor,
        diameter: vx_int32,
        sigmaSpace: vx_float32,
        sigmaValues: vx_float32,
        dst: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs element wise multiplications on element values in the input tensor data with a scale.\n \\param [in] graph The handle to the graph.\n \\param [in] input1 Input tensor data.  Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] input2 Input tensor data. The dimensions and sizes of input2 match those of input1, unless the vx_tensor of one or more dimensions in input2 is 1.\n In this case, those dimensions are treated as if this tensor was expanded to match the size of the corresponding dimension of input1,\n and data was duplicated on all terms in that dimension. After this expansion, the dimensions will be equal.\n The data type must match the data type of Input1.\n \\param [in] scale A non-negative <tt>\\ref VX_TYPE_FLOAT32</tt> multiplied to each product before overflow handling.\n \\param [in] overflow_policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] rounding_policy A <tt>\\ref vx_round_policy_e</tt> enumeration.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_multiply\n \\return <tt>\\ref vx_node</tt>.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTensorMultiplyNode(
        graph: vx_graph,
        input1: vx_tensor,
        input2: vx_tensor,
        scale: vx_scalar,
        overflow_policy: vx_enum,
        rounding_policy: vx_enum,
        output: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs arithmetic addition on element values in the input tensor data.\n \\param [in] graph The handle to the graph.\n \\param [in] input1 Input tensor data.  Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] input2 Input tensor data. The dimensions and sizes of input2 match those of input1, unless the vx_tensor of one or more dimensions in input2 is 1.\n In this case, those dimensions are treated as if this tensor was expanded to match the size of the corresponding dimension of input1,\n and data was duplicated on all terms in that dimension. After this expansion, the dimensions will be equal.\n The data type must match the data type of Input1.\n \\param [in] policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_add\n \\return <tt>\\ref vx_node</tt>.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTensorAddNode(
        graph: vx_graph,
        input1: vx_tensor,
        input2: vx_tensor,
        policy: vx_enum,
        output: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs arithmetic subtraction on element values in the input tensor data.\n \\param [in] graph The handle to the graph.\n \\param [in] input1 Input tensor data.  Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] input2 Input tensor data. The dimensions and sizes of input2 match those of input1, unless the vx_tensor of one or more dimensions in input2 is 1.\n In this case, those dimensions are treated as if this tensor was expanded to match the size of the corresponding dimension of input1,\n and data was duplicated on all terms in that dimension. After this expansion, the dimensions will be equal.\n The data type must match the data type of Input1.\n \\param [in] policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_subtract\n \\return <tt>\\ref vx_node</tt>.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTensorSubtractNode(
        graph: vx_graph,
        input1: vx_tensor,
        input2: vx_tensor,
        policy: vx_enum,
        output: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs LUT on element values in the input tensor data.\n \\param [in] graph The handle to the graph.\n \\param [in] input1 Input tensor data. Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt>, with fixed_point_position 0.\n \\param [in] lut The look-up table to use, of type <tt>\\ref vx_lut</tt>.\n The elements of input1 are treated as unsigned integers to determine an index into the look-up table.\n The data type of the items in the look-up table must match that of the output tensor.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_tablelookup\n \\return <tt>\\ref vx_node</tt>.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTensorTableLookupNode(
        graph: vx_graph,
        input1: vx_tensor,
        lut: vx_lut,
        output: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Performs transpose on the input tensor.\n The node transpose the tensor according to a specified 2 indexes in the tensor (0-based indexing)\n \\param [in] graph The handle to the graph.\n \\param [in] input Input tensor data, Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [out] output output tensor data,\n \\param [in] dimension1 Dimension index that is transposed with dim 2.\n \\param [in] dimension2 Dimension index that is transposed with dim 1.\n \\ingroup group_vision_function_tensor_transpose\n \\return <tt>\\ref vx_node</tt>.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTensorTransposeNode(
        graph: vx_graph,
        input: vx_tensor,
        output: vx_tensor,
        dimension1: vx_size,
        dimension2: vx_size,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a bit-depth conversion node.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input tensor. Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] policy A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] norm A scalar containing a <tt>\\ref VX_TYPE_FLOAT32</tt> of the normalization value.\n \\param [in] offset A scalar containing a <tt>\\ref VX_TYPE_FLOAT32</tt> of the offset value subtracted before normalization.\n \\param [out] output The output tensor. Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt>. with fixed_point_position 8.\n And <tt>\\ref VX_TYPE_UINT8</tt> with fixed_point_position 0.\n \\ingroup group_vision_function_tensor_convert_depth\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxTensorConvertDepthNode(
        graph: vx_graph,
        input: vx_tensor,
        policy: vx_enum,
        norm: vx_scalar,
        offset: vx_scalar,
        output: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Graph] Creates a generalized matrix multiplication node.\n \\param [in] graph The reference to the graph.\n \\param [in] input1 The first input 2D tensor of type <tt>\\ref  VX_TYPE_INT16</tt> with fixed_point_pos 8, or tensor data types <tt>\\ref VX_TYPE_UINT8</tt> or <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_pos 0.\n \\param [in] input2 The second 2D tensor. Must be in the same data type as input1.\n \\param [in] input3 The third 2D tensor. Must be in the same data type as input1. [optional].\n \\param [in] matrix_multiply_params Matrix multiply parameters, see <tt>\\ref vx_tensor_matrix_multiply_params_t </tt>.\n \\param [out] output The output 2D tensor. Must be in the same data type as input1. Output dimension must agree the formula in the description.\n \\ingroup group_vision_function_tensor_matrix_multiply\n \\return <tt>\\ref vx_node</tt>.\n \\returns A node reference <tt>\\ref vx_node</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>."]
    pub fn vxTensorMatrixMultiplyNode(
        graph: vx_graph,
        input1: vx_tensor,
        input2: vx_tensor,
        input3: vx_tensor,
        matrix_multiply_params: *const vx_tensor_matrix_multiply_params_t,
        output: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief Copy data from one object to another.\n \\note An implementation may optimize away the copy when virtual data objects are used.\n \\param [in] graph The reference to the graph.\n \\param [in] input The input data object.\n \\param [out] output The output data object with meta-data identical to the input data object.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation\n should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_copy"]
    pub fn vxCopyNode(graph: vx_graph, input: vx_reference, output: vx_reference) -> vx_node;
}
pub type vx_kernel_input_validate_f =
    ::std::option::Option<unsafe extern "C" fn(node: vx_node, index: vx_uint32) -> vx_status>;
pub type vx_kernel_output_validate_f = ::std::option::Option<
    unsafe extern "C" fn(node: vx_node, index: vx_uint32, meta: vx_meta_format) -> vx_status,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_delta_rectangle_t {
    #[doc = "< \\brief The change in the start x."]
    pub delta_start_x: vx_int32,
    #[doc = "< \\brief The change in the start y."]
    pub delta_start_y: vx_int32,
    #[doc = "< \\brief The change in the end x."]
    pub delta_end_x: vx_int32,
    #[doc = "< \\brief The change in the end y."]
    pub delta_end_y: vx_int32,
}
#[test]
fn bindgen_test_layout__vx_delta_rectangle_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_delta_rectangle_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_delta_rectangle_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_delta_rectangle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_delta_rectangle_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_delta_rectangle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_start_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_delta_rectangle_t),
            "::",
            stringify!(delta_start_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_start_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_delta_rectangle_t),
            "::",
            stringify!(delta_start_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_end_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_delta_rectangle_t),
            "::",
            stringify!(delta_end_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_end_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_delta_rectangle_t),
            "::",
            stringify!(delta_end_y)
        )
    );
}
pub type vx_delta_rectangle_t = _vx_delta_rectangle_t;
extern "C" {
    pub fn vxAddKernel(
        context: vx_context,
        name: *const vx_char,
        enumeration: vx_enum,
        func_ptr: vx_kernel_f,
        numParams: vx_uint32,
        input: vx_kernel_input_validate_f,
        output: vx_kernel_output_validate_f,
        init: vx_kernel_initialize_f,
        deinit: vx_kernel_deinitialize_f,
    ) -> vx_kernel;
}
extern "C" {
    pub fn vxComputeImagePatchSize(
        image: vx_image,
        rect: *const vx_rectangle_t,
        plane_index: vx_uint32,
    ) -> vx_size;
}
extern "C" {
    pub fn vxAccessImagePatch(
        image: vx_image,
        rect: *const vx_rectangle_t,
        plane_index: vx_uint32,
        addr: *mut vx_imagepatch_addressing_t,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
    ) -> vx_status;
}
extern "C" {
    pub fn vxCommitImagePatch(
        image: vx_image,
        rect: *const vx_rectangle_t,
        plane_index: vx_uint32,
        addr: *const vx_imagepatch_addressing_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> vx_status;
}
extern "C" {
    pub fn vxAccessArrayRange(
        arr: vx_array,
        start: vx_size,
        end: vx_size,
        stride: *mut vx_size,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
    ) -> vx_status;
}
extern "C" {
    pub fn vxCommitArrayRange(
        arr: vx_array,
        start: vx_size,
        end: vx_size,
        ptr: *const ::std::os::raw::c_void,
    ) -> vx_status;
}
extern "C" {
    pub fn vxAccessDistribution(
        distribution: vx_distribution,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
    ) -> vx_status;
}
extern "C" {
    pub fn vxCommitDistribution(
        distribution: vx_distribution,
        ptr: *const ::std::os::raw::c_void,
    ) -> vx_status;
}
extern "C" {
    pub fn vxAccessLUT(
        lut: vx_lut,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
    ) -> vx_status;
}
extern "C" {
    pub fn vxCommitLUT(lut: vx_lut, ptr: *const ::std::os::raw::c_void) -> vx_status;
}
extern "C" {
    pub fn vxReadMatrix(mat: vx_matrix, array: *mut ::std::os::raw::c_void) -> vx_status;
}
extern "C" {
    pub fn vxWriteMatrix(mat: vx_matrix, array: *const ::std::os::raw::c_void) -> vx_status;
}
extern "C" {
    pub fn vxReadConvolutionCoefficients(conv: vx_convolution, array: *mut vx_int16) -> vx_status;
}
extern "C" {
    pub fn vxWriteConvolutionCoefficients(
        conv: vx_convolution,
        array: *const vx_int16,
    ) -> vx_status;
}
extern "C" {
    pub fn vxReadScalarValue(ref_: vx_scalar, ptr: *mut ::std::os::raw::c_void) -> vx_status;
}
extern "C" {
    pub fn vxWriteScalarValue(ref_: vx_scalar, ptr: *const ::std::os::raw::c_void) -> vx_status;
}
extern "C" {
    pub fn vxSetRemapPoint(
        table: vx_remap,
        dst_x: vx_uint32,
        dst_y: vx_uint32,
        src_x: vx_float32,
        src_y: vx_float32,
    ) -> vx_status;
}
extern "C" {
    pub fn vxGetRemapPoint(
        table: vx_remap,
        dst_x: vx_uint32,
        dst_y: vx_uint32,
        src_x: *mut vx_float32,
        src_y: *mut vx_float32,
    ) -> vx_status;
}
extern "C" {
    pub fn vxCreateThreshold(
        c: vx_context,
        thresh_type: vx_enum,
        data_type: vx_enum,
    ) -> vx_threshold;
}
extern "C" {
    pub fn vxAccumulateImageNode(graph: vx_graph, input: vx_image, accum: vx_image) -> vx_node;
}
extern "C" {
    pub fn vxAccumulateWeightedImageNode(
        graph: vx_graph,
        input: vx_image,
        alpha: vx_scalar,
        accum: vx_image,
    ) -> vx_node;
}
extern "C" {
    pub fn vxAccumulateSquareImageNode(
        graph: vx_graph,
        input: vx_image,
        shift: vx_scalar,
        accum: vx_image,
    ) -> vx_node;
}
extern "C" {
    pub fn vxuAccumulateImage(context: vx_context, input: vx_image, accum: vx_image) -> vx_status;
}
extern "C" {
    pub fn vxuAccumulateWeightedImage(
        context: vx_context,
        input: vx_image,
        alpha: vx_scalar,
        accum: vx_image,
    ) -> vx_status;
}
extern "C" {
    pub fn vxuAccumulateSquareImage(
        context: vx_context,
        input: vx_image,
        shift: vx_scalar,
        accum: vx_image,
    ) -> vx_status;
}
extern "C" {
    pub fn vxNormalizationLayer(
        graph: vx_graph,
        inputs: vx_tensor,
        type_: vx_enum,
        normalization_size: vx_size,
        alpha: vx_float32,
        beta: vx_float32,
        outputs: vx_tensor,
    ) -> vx_node;
}
extern "C" {
    #[doc = " \\brief [Immediate] Invokes an immediate Color Conversion.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image.\n \\param [out] output The output image.\n \\ingroup group_vision_function_colorconvert\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuColorConvert(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Invokes an immediate Channel Extract.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image. Must be one of the defined <tt>\\ref vx_df_image_e</tt> multi-channel formats.\n \\param [in] channel The <tt>\\ref vx_channel_e</tt> enumeration to extract.\n \\param [out] output The output image. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\ingroup group_vision_function_channelextract\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuChannelExtract(
        context: vx_context,
        input: vx_image,
        channel: vx_enum,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Invokes an immediate Channel Combine.\n \\param [in] context The reference to the overall context.\n \\param [in] plane0 The plane that forms channel 0. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] plane1 The plane that forms channel 1. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] plane2 [optional] The plane that forms channel 2. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] plane3 [optional] The plane that forms channel 3. Must be <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [out] output The output image.\n \\ingroup group_vision_function_channelcombine\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuChannelCombine(
        context: vx_context,
        plane0: vx_image,
        plane1: vx_image,
        plane2: vx_image,
        plane3: vx_image,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Invokes an immediate Sobel 3x3.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output_x [optional] The output gradient in the x direction in <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] output_y [optional] The output gradient in the y direction in <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\ingroup group_vision_function_sobel3x3\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuSobel3x3(
        context: vx_context,
        input: vx_image,
        output_x: vx_image,
        output_y: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Invokes an immediate Magnitude.\n \\param [in] context The reference to the overall context.\n \\param [in] grad_x The input x image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] grad_y The input y image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] mag The magnitude image. This will be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\ingroup group_vision_function_magnitude\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMagnitude(
        context: vx_context,
        grad_x: vx_image,
        grad_y: vx_image,
        mag: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Invokes an immediate Phase.\n \\param [in] context The reference to the overall context.\n \\param [in] grad_x The input x image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] grad_y The input y image. This must be in <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] orientation The phase image. This will be in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\ingroup group_vision_function_phase\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuPhase(
        context: vx_context,
        grad_x: vx_image,
        grad_y: vx_image,
        orientation: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Scales an input image to an output image.\n \\param [in] context The reference to the overall context.\n \\param [in] src The source image of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt>.\n \\param [out] dst The destination image of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt>.\n Must be of the same format as the input image.\n \\param [in] type The interpolation type. \\see vx_interpolation_type_e.\n \\ingroup group_vision_function_scale_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuScaleImage(
        context: vx_context,
        src: vx_image,
        dst: vx_image,
        type_: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Processes the image through the LUT.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] lut The LUT which is of type <tt>\\ref VX_TYPE_UINT8</tt> if input image is <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_TYPE_INT16</tt> if input image is <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] output The output image of the same size as the input image.\n \\ingroup group_vision_function_lut\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTableLookup(
        context: vx_context,
        input: vx_image,
        lut: vx_lut,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Generates a distribution from an image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\param [out] distribution The output distribution.\n \\ingroup group_vision_function_histogram\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuHistogram(
        context: vx_context,
        input: vx_image,
        distribution: vx_distribution,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Equalizes the Histogram of a grayscale image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The grayscale input image in <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\param [out] output The grayscale output image of type <tt>\\ref VX_DF_IMAGE_U8</tt> with equalized brightness and contrast.\n \\ingroup group_vision_function_equalize_hist\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuEqualizeHist(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the absolute difference between two images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 An input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] in2 An input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] out The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\ingroup group_vision_function_absdiff\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuAbsDiff(
        context: vx_context,
        in1: vx_image,
        in2: vx_image,
        out: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the mean value and optionally the standard deviation.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image. <tt>\\ref VX_DF_IMAGE_U8</tt> and <tt>\\ref VX_DF_IMAGE_U1</tt> are supported.\n \\param [out] mean The average pixel value.\n \\param [out] stddev [optional] The standard deviation of the pixel values.\n \\ingroup group_vision_function_meanstddev\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMeanStdDev(
        context: vx_context,
        input: vx_image,
        mean: *mut vx_float32,
        stddev: *mut vx_float32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Threshold's an input image and produces a <tt>\\ref VX_DF_IMAGE_U8</tt> boolean image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image. Only images with format <tt>\\ref VX_DF_IMAGE_U8</tt>\n and <tt>\\ref VX_DF_IMAGE_S16</tt> are supported.\n \\param [in] thresh The thresholding object that defines the parameters of\n the operation. The <tt>\\ref VX_THRESHOLD_INPUT_FORMAT</tt> must be the same as the input image format and\n the <tt>\\ref VX_THRESHOLD_OUTPUT_FORMAT</tt> must be the same as the output image format.\n \\param [out] output The output image, that will contain as pixel values true and false values defined by \\p thresh.\n Only images with format <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> are supported.\n Must be of the same size as the input image.\n \\ingroup group_vision_function_threshold\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuThreshold(
        context: vx_context,
        input: vx_image,
        thresh: vx_threshold,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs Non-Maxima Suppression on an image, producing an image of the same type.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] mask [optional] Constrict suppression to a ROI. The mask image is of type <tt>\\ref VX_DF_IMAGE_U8</tt>\n or <tt>\\ref VX_DF_IMAGE_U1</tt> and must be the same dimensions as the input image.\n \\param [in] win_size The size of window over which to perform the localized non-maxima suppression.  Must be odd,\n and less than or equal to the smallest dimension of the input image.\n \\param [out] output The output image, of the same type as the input, that has been non-maxima suppressed.\n \\ingroup group_vision_function_nms\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuNonMaxSuppression(
        context: vx_context,
        input: vx_image,
        mask: vx_image,
        win_size: vx_int32,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the integral image of the input.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U32</tt> format.\n \\ingroup group_vision_function_integral_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuIntegralImage(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Erodes an image by a 3x3 window.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which\n must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_erode_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuErode3x3(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Dilates an image by a 3x3 window.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which\n must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_dilate_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuDilate3x3(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a median filter on the image by a 3x3 window.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which\n must have the same dimensions and type as the input image.\n \\ingroup group_vision_function_median_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMedian3x3(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a box filter on the image by a 3x3 window.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\ingroup group_vision_function_box_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuBox3x3(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a gaussian filter on the image by a 3x3 window.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\ingroup group_vision_function_gaussian_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuGaussian3x3(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs Non-linear Filtering.\n \\param [in] context The reference to the overall context.\n \\param [in] function The non-linear filter function. See <tt>\\ref vx_non_linear_filter_e</tt>.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format.\n \\param [in] mask The mask to be applied to the Non-linear function. <tt>\\ref VX_MATRIX_ORIGIN</tt> attribute is used\n to place the mask appropriately when computing the resulting image. See <tt>\\ref vxCreateMatrixFromPattern</tt> and <tt>\\ref vxCreateMatrixFromPatternAndOrigin</tt>.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> format, which\n must have the same dimensions and type as the input image.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_nonlinear_filter"]
    pub fn vxuNonLinearFilter(
        context: vx_context,
        function: vx_enum,
        input: vx_image,
        mask: vx_matrix,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a convolution on the input image with the supplied\n matrix.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> format.\n \\param [in] conv The <tt>\\ref vx_int16</tt> convolution matrix.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\ingroup group_vision_function_custom_convolution\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuConvolve(
        context: vx_context,
        input: vx_image,
        conv: vx_convolution,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a Gaussian pyramid from an input image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\param [out] gaussian The Gaussian pyramid with <tt>\\ref VX_DF_IMAGE_U8</tt> to construct.\n \\ingroup group_vision_function_gaussian_pyramid\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuGaussianPyramid(
        context: vx_context,
        input: vx_image,
        gaussian: vx_pyramid,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a Laplacian pyramid from an input image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] laplacian The Laplacian pyramid with <tt>\\ref VX_DF_IMAGE_S16</tt> to construct.\n \\param [out] output The lowest resolution image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format necessary to reconstruct the input image from the pyramid. The output image format should be same as input image format.\n \\ingroup group_vision_function_laplacian_pyramid\n \\see group_pyramid\n \\return A <tt>\\ref vx_status</tt> enumeration.\n \\retval VX_SUCCESS Success.\n \\retval * An error occured. See <tt>\\ref vx_status_e</tt>"]
    pub fn vxuLaplacianPyramid(
        context: vx_context,
        input: vx_image,
        laplacian: vx_pyramid,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Reconstructs an image from a Laplacian Image pyramid.\n \\param [in] context The reference to the overall context.\n \\param [in] laplacian The Laplacian pyramid with <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [in] input The lowest resolution image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format for the Laplacian pyramid.\n \\param [out] output The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format with the highest possible resolution reconstructed from the Laplacian pyramid. The output image format should be same as input image format.\n \\ingroup group_vision_function_laplacian_reconstruct\n \\see group_pyramid\n \\return A <tt>\\ref vx_status</tt> enumeration.\n \\retval VX_SUCCESS Success.\n \\retval * An error occured. See <tt>\\ref vx_status_e</tt>"]
    pub fn vxuLaplacianReconstruct(
        context: vx_context,
        laplacian: vx_pyramid,
        input: vx_image,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes a weighted average image.\n \\param [in] context The reference to the overall context.\n \\param [in] img1 The first <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] alpha A <tt>\\ref VX_TYPE_FLOAT32</tt> type, the input value with the range \\f$ 0.0 \\le \\alpha \\le 1.0 \\f$.\n \\param [in] img2 The second <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\ingroup group_vision_function_weighted_average\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuWeightedAverage(
        context: vx_context,
        img1: vx_image,
        alpha: vx_scalar,
        img2: vx_image,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the minimum and maximum values of the image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\param [out] minVal The minimum value in the image, which corresponds to the type of the input.\n \\param [out] maxVal The maximum value in the image, which corresponds to the type of the input.\n \\param [out] minLoc [optional] The minimum <tt>\\ref VX_TYPE_COORDINATES2D</tt> locations. If the input image has several minimums, the kernel will return up to the capacity of the array.\n \\param [out] maxLoc [optional] The maximum <tt>\\ref VX_TYPE_COORDINATES2D</tt> locations. If the input image has several maximums, the kernel will return up to the capacity of the array.\n \\param [out] minCount [optional] The total number of detected minimums in image. Use a <tt>\\ref VX_TYPE_SIZE</tt> scalar.\n \\param [out] maxCount [optional] The total number of detected maximums in image. Use a <tt>\\ref VX_TYPE_SIZE</tt> scalar.\n \\ingroup group_vision_function_minmaxloc\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMinMaxLoc(
        context: vx_context,
        input: vx_image,
        minVal: vx_scalar,
        maxVal: vx_scalar,
        minLoc: vx_array,
        maxLoc: vx_array,
        minCount: vx_scalar,
        maxCount: vx_scalar,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes pixel-wise minimum values between two images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 The first input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] in2 The second input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] out The output image which will hold the result of min.\n \\ingroup group_vision_function_min\n \\return  A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMin(context: vx_context, in1: vx_image, in2: vx_image, out: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes pixel-wise maximum values between two images.\n \\param [in]  context The reference to the overall context.\n \\param [in] in1 The first input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [in] in2 The second input image. Must be of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>.\n \\param [out] out The output image which will hold the result of max.\n \\ingroup group_vision_function_max\n \\return  A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMax(context: vx_context, in1: vx_image, in2: vx_image, out: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Converts the input images bit-depth into the output image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image.\n \\param [out] output The output image.\n \\param [in] policy A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] shift A scalar containing a <tt>\\ref VX_TYPE_INT32</tt> of the shift value.\n \\ingroup group_vision_function_convertdepth\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.."]
    pub fn vxuConvertDepth(
        context: vx_context,
        input: vx_image,
        output: vx_image,
        policy: vx_enum,
        shift: vx_int32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes Canny Edges on the input image into the output image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] hyst The double threshold for hysteresis. The <tt>\\ref VX_THRESHOLD_INPUT_FORMAT</tt> shall be either\n <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt>. The <tt>\\ref VX_THRESHOLD_OUTPUT_FORMAT</tt> is ignored.\n \\param [in] gradient_size The size of the Sobel filter window, must support at least 3, 5 and 7.\n \\param [in] norm_type A flag indicating the norm used to compute the gradient, <tt>\\ref VX_NORM_L1</tt> or <tt>\\ref VX_NORM_L2</tt>.\n \\param [out] output The binary output image in <tt>\\ref VX_DF_IMAGE_U1</tt> or <tt>\\ref VX_DF_IMAGE_U8</tt> format\n with values either 0 and 1 (<tt>VX_DF_IMAGE_U1</tt>), or 0 and 255 (<tt>VX_DF_IMAGE_U8</tt>).\n \\ingroup group_vision_function_canny\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuCannyEdgeDetector(
        context: vx_context,
        input: vx_image,
        hyst: vx_threshold,
        gradient_size: vx_int32,
        norm_type: vx_enum,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs a Gaussian Blur on an image then half-scales it. The interpolation mode used is nearest-neighbor.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] kernel_size The input size of the Gaussian filter. Supported values are 1, 3 and 5.\n \\ingroup group_vision_function_scale_image\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuHalfScaleGaussian(
        context: vx_context,
        input: vx_image,
        output: vx_image,
        kernel_size: vx_int32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the bitwise and between two images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] out The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the\n same dimensions and type as the input images.\n \\ingroup group_vision_function_and\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuAnd(context: vx_context, in1: vx_image, in2: vx_image, out: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the bitwise inclusive-or between two images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] out The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the\n same dimensions and type as the input images.\n \\ingroup group_vision_function_or\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuOr(context: vx_context, in1: vx_image, in2: vx_image, out: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the bitwise exclusive-or between two images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] out The <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have the\n same dimensions and type as the input images.\n \\ingroup group_vision_function_xor\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuXor(context: vx_context, in1: vx_image, in2: vx_image, out: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the bitwise not of an image.\n \\param [in] context The reference to the overall context.\n \\param [in] input A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt> input image.\n \\param [out] output The <tt>\\ref VX_DF_IMAGE_U8</tt>  or <tt>\\ref VX_DF_IMAGE_U1</tt> output image, which must have\n the same dimensions and type as the input image.\n \\ingroup group_vision_function_not\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuNot(context: vx_context, input: vx_image, output: vx_image) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs elementwise multiplications on pixel values in the input images and a scale.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> input image.\n \\param [in] scale A non-negative <tt>\\ref VX_TYPE_FLOAT32</tt> multiplied to each product before overflow handling.\n \\param [in] overflow_policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] rounding_policy A <tt>\\ref vx_round_policy_e</tt> enumeration.\n \\param [out] out The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\ingroup group_vision_function_mult\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuMultiply(
        context: vx_context,
        in1: vx_image,
        in2: vx_image,
        scale: vx_float32,
        overflow_policy: vx_enum,
        rounding_policy: vx_enum,
        out: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs arithmetic addition on pixel values in the input images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> input image.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> input image.\n \\param [in] policy A \\ref vx_convert_policy_e enumeration.\n \\param [out] out The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\ingroup group_vision_function_add\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuAdd(
        context: vx_context,
        in1: vx_image,
        in2: vx_image,
        policy: vx_enum,
        out: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs arithmetic subtraction on pixel values in the input images.\n \\param [in] context The reference to the overall context.\n \\param [in] in1 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> input image, the minuend.\n \\param [in] in2 A <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> input image, the subtrahend.\n \\param [in] policy A \\ref vx_convert_policy_e enumeration.\n \\param [out] out The output image in <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_S16</tt> format.\n \\ingroup group_vision_function_sub\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuSubtract(
        context: vx_context,
        in1: vx_image,
        in2: vx_image,
        policy: vx_enum,
        out: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs an Affine warp on an image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U1</tt> or <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] matrix The affine matrix. Must be 2x3 of type \\ref VX_TYPE_FLOAT32.\n \\param [in] type The interpolation type from \\ref vx_interpolation_type_e.\n \\ref VX_INTERPOLATION_AREA is not supported.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U1</tt> or <tt>\\ref VX_DF_IMAGE_U8</tt> image of the same\n format as the input image.\n \\ingroup group_vision_function_warp_affine\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuWarpAffine(
        context: vx_context,
        input: vx_image,
        matrix: vx_matrix,
        type_: vx_enum,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs an Perspective warp on an image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] matrix The perspective matrix. Must be 3x3 of type \\ref VX_TYPE_FLOAT32.\n \\param [in] type The interpolation type from \\ref vx_interpolation_type_e.\n \\ref VX_INTERPOLATION_AREA is not supported.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\ingroup group_vision_function_warp_perspective\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuWarpPerspective(
        context: vx_context,
        input: vx_image,
        matrix: vx_matrix,
        type_: vx_enum,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes the Harris Corners over an image and produces the array of scored points.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] strength_thresh The <tt>\\ref VX_TYPE_FLOAT32</tt> minimum threshold which to eliminate Harris Corner scores (computed using the normalized Sobel kernel).\n \\param [in] min_distance The <tt>\\ref VX_TYPE_FLOAT32</tt> radial Euclidean distance for non-maximum suppression.\n \\param [in] sensitivity The <tt>\\ref VX_TYPE_FLOAT32</tt> scalar sensitivity threshold \\f$ k \\f$ from the Harris-Stephens equation.\n \\param [in] gradient_size The gradient window size to use on the input. The\n implementation must support at least 3, 5, and 7.\n \\param [in] block_size The block window size used to compute the harris corner score.\n The implementation must support at least 3, 5, and 7.\n \\param [out] corners The array of <tt>\\ref VX_TYPE_KEYPOINT</tt> structs. The order of the keypoints in this array is implementation dependent.\n \\param [out] num_corners [optional] The total number of detected corners in image. Use a \\ref VX_TYPE_SIZE scalar\n \\ingroup group_vision_function_harris\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuHarrisCorners(
        context: vx_context,
        input: vx_image,
        strength_thresh: vx_scalar,
        min_distance: vx_scalar,
        sensitivity: vx_scalar,
        gradient_size: vx_int32,
        block_size: vx_int32,
        corners: vx_array,
        num_corners: vx_scalar,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes corners on an image using FAST algorithm and produces the array of feature points.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] strength_thresh Threshold on difference between intensity of the central pixel and pixels on Bresenham's circle\n of radius 3 (<tt>\\ref VX_TYPE_FLOAT32</tt> scalar), with a value in the range of 0.0 \\f$\\le\\f$ strength_thresh < 256.0.\n  Any fractional value will be truncated to an integer.\n \\param [in] nonmax_suppression If true, non-maximum suppression is applied to\n detected corners before being places in the <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt> structs.\n \\param [out] corners Output corner <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt>. The order of the keypoints in this array is implementation dependent.\n \\param [out] num_corners [optional] The total number of detected corners in image. Use a \\ref VX_TYPE_SIZE scalar.\n \\ingroup group_vision_function_fast\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval *          An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuFastCorners(
        context: vx_context,
        input: vx_image,
        strength_thresh: vx_scalar,
        nonmax_suppression: vx_bool,
        corners: vx_array,
        num_corners: vx_scalar,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Computes an optical flow on two images.\n \\param [in] context The reference to the overall context.\n \\param [in] old_images Input of first (old) image pyramid in <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] new_images Input of destination (new) image pyramid in <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\param [in] old_points an array of key points in a vx_array of <tt>\\ref VX_TYPE_KEYPOINT</tt> those key points are defined at\n  the old_images high resolution pyramid\n \\param [in] new_points_estimates an array of estimation on what is the output key points in a <tt>\\ref vx_array</tt> of\n <tt>\\ref VX_TYPE_KEYPOINT</tt> those keypoints are defined at the new_images high resolution pyramid\n \\param [out] new_points an output array of key points in a <tt>\\ref vx_array</tt> of <tt>\\ref VX_TYPE_KEYPOINT</tt> those key points are\n  defined at the new_images high resolution pyramid\n \\param [in] termination termination can be <tt>\\ref VX_TERM_CRITERIA_ITERATIONS</tt> or <tt>\\ref VX_TERM_CRITERIA_EPSILON</tt> or\n <tt>\\ref VX_TERM_CRITERIA_BOTH</tt>\n \\param [in] epsilon is the <tt>\\ref vx_float32</tt> error for terminating the algorithm\n \\param [in] num_iterations is the number of iterations. Use a <tt>\\ref VX_TYPE_UINT32</tt> scalar.\n \\param [in] use_initial_estimate Can be set to either <tt>\\ref vx_false_e</tt> or <tt>\\ref vx_true_e</tt>.\n \\param [in] window_dimension The size of the window on which to perform the algorithm. See\n  <tt>\\ref VX_CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION</tt>\n\n \\ingroup group_vision_function_opticalflowpyrlk\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuOpticalFlowPyrLK(
        context: vx_context,
        old_images: vx_pyramid,
        new_images: vx_pyramid,
        old_points: vx_array,
        new_points_estimates: vx_array,
        new_points: vx_array,
        termination: vx_enum,
        epsilon: vx_scalar,
        num_iterations: vx_scalar,
        use_initial_estimate: vx_scalar,
        window_dimension: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate]  The function compares an image template against overlapped image regions.\n \\details The detailed equation to the matching can be found in <tt>\\ref vx_comp_metric_e</tt>.\n The output of the template matching node is a comparison map as described in <tt>\\ref vx_comp_metric_e</tt>.\n The Node have a limitation on the template image size (width*height). It should not be larger then 65535.\n If the valid region of the template image is smaller than the entire template image, the result in the destination image is implementation-dependent.\n \\param [in] context The reference to the overall context.\n \\param [in] src The input image of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] templateImage Searched template of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] matchingMethod attribute specifying the comparison method <tt>\\ref vx_comp_metric_e</tt>. This function support only <tt>\\ref VX_COMPARE_CCORR_NORM</tt> and <tt>\\ref VX_COMPARE_L2</tt>.\n \\param [out] output Map of comparison results. The output is an image of type <tt>\\ref VX_DF_IMAGE_S16</tt>\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_match_template"]
    pub fn vxuMatchTemplate(
        context: vx_context,
        src: vx_image,
        templateImage: vx_image,
        matchingMethod: vx_enum,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] The function extracts LBP image from an input image\n \\param [in] context The reference to the overall context.\n \\param [in] in\t\tAn input image in <tt>vx_image</tt>. Or \\f$ SrcImg\\f$ in the equations. the image is of type <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\param [in] format\tA variation of LBP like original LBP and mLBP. see <tt> \\ref vx_lbp_format_e </tt>\n \\param [in] kernel_size Kernel size. Only size of 3 and 5 are supported\n \\param [out] out\tAn output image in <tt>vx_image</tt>.Or \\f$ DstImg\\f$ in the equations. the image is of type <tt>\\ref VX_DF_IMAGE_U8</tt>\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_lbp"]
    pub fn vxuLBP(
        context: vx_context,
        in_: vx_image,
        format: vx_enum,
        kernel_size: vx_int8,
        out: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs cell calculations for the average gradient magnitude and gradient orientation histograms.\n \\details Firstly, the gradient magnitude and gradient orientation are computed for each pixel in the input image.\n Two 1-D centred, point discrete derivative masks are applied to the input image in the horizontal and vertical directions.\n \\f[ M_h = [-1, 0, 1] \\f] and \\f[ M_v = [-1, 0, 1]^T \\f]\n \\f$G_v\\f$ is the result of applying mask \\f$M_v\\f$ to the input image, and \\f$G_h\\f$ is the result of applying mask \\f$M_h\\f$ to the input image.\n The border mode used for the gradient calculation is implementation dependent. Its behavior should be similar to <tt>\\ref VX_BORDER_UNDEFINED</tt>.\n The gradient magnitudes and gradient orientations for each pixel are then calculated in the following manner.\n \\f[ G(x,y) = \\sqrt{G_v(x,y)^2 + G_h(x,y)^2} \\f]\n \\f[ \\theta(x,y) = arctan(G_v(x,y), G_h(x,y)) \\f]\n where \\f$arctan(v, h)\\f$\n is \\f$ tan^{-1}(v/h)\\f$ when \\f$h!=0\\f$,\n\n \\f$ -pi/2 \\f$ if \\f$v<0\\f$ and \\f$h==0\\f$,\n\n \\f$  pi/2  \\f$ if \\f$v>0\\f$ and \\f$h==0\\f$\n\n and \\f$     0  \\f$ if \\f$v==0\\f$ and \\f$h==0\\f$\n\n Secondly, the gradient magnitudes and orientations are used to compute the bins output tensor and optional magnitudes output tensor.\n These tensors are computed on a cell level where the cells are rectangular in shape.\n The magnitudes tensor contains the average gradient magnitude for each cell.\n \\f[magnitudes(c) = \\frac{1}{(cell\\_width * cell\\_height)}\\sum\\limits_{w=0}^{cell\\_width} \\sum\\limits_{h=0}^{cell\\_height} G_c(w,h)\\f]\n where \\f$G_c\\f$ is the gradient magnitudes related to cell \\f$c\\f$.\n The bins tensor contains histograms of gradient orientations for each cell.\n The gradient orientations at each pixel range from 0 to 360 degrees.  These are quantised into a set of histogram bins based on the num_bins parameter.\n Each pixel votes for a specific cell histogram bin based on its gradient orientation.  The vote itself is the pixel's gradient magnitude.\n \\f[bins(c, n) = \\sum\\limits_{w=0}^{cell\\_width} \\sum\\limits_{h=0}^{cell\\_height} G_c(w,h) * 1[B_c(w, h, num\\_bins) == n]\\f]\n where \\f$B_c\\f$ produces the histogram bin number based on the gradient orientation of the pixel at location (\\f$w\\f$, \\f$h\\f$) in cell \\f$c\\f$ based on\n the \\f$num\\_bins\\f$ and \\f[1[B_c(w, h, num\\_bins) == n]\\f] is a delta-function with value 1 when \\f$B_c(w, h, num\\_bins) == n\\f$ or 0 otherwise.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] cell_width The histogram cell width of type <tt>\\ref VX_TYPE_INT32</tt>.\n \\param [in] cell_height The histogram cell height of type <tt>\\ref VX_TYPE_INT32</tt>.\n \\param [in] num_bins  The histogram size of type <tt>\\ref VX_TYPE_INT32</tt>.\n \\param [out] magnitudes The output average gradient magnitudes per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt> of size \\f$ [floor(image_{width}/cell_{width}) ,floor(image_{height}/cell_{height}) ] \\f$.\n \\param [out] bins       The output gradient orientation histograms per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt> of size \\f$ [floor(image_{width}/cell_{width}) ,floor(image_{height}/cell_{height}), num_{bins}] \\f$.\n\n \\ingroup group_vision_function_hog\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuHOGCells(
        context: vx_context,
        input: vx_image,
        cell_width: vx_int32,
        cell_height: vx_int32,
        num_bins: vx_int32,
        magnitudes: vx_tensor,
        bins: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate]  Computes Histogram of Oriented Gradients features for the W1xW2 window in a sliding window fashion over the whole input image.\n \\details Firstly if a magnitudes tensor is provided the cell histograms in the bins tensor are normalised by the average cell gradient magnitudes.\n\\f[bins(c,n) = \\frac{bins(c,n)}{magnitudes(c)}\\f]\n To account for changes in illumination and contrast the cell histograms must be locally normalized which requires grouping the cell histograms together into larger spatially connected blocks.\n Blocks are rectangular grids represented by three parameters: the number of cells per block, the number of pixels per cell, and the number of bins per cell histogram.\n These blocks typically overlap, meaning that each cell histogram contributes more than once to the final descriptor.\n To normalize a block its cell histograms \\f$h\\f$ are grouped together to form a vector \\f$v = [h_1, h_2, h_3, ... , h_n]\\f$.\n This vector is normalised using L2-Hys which means performing L2-norm on this vector; clipping the result (by limiting the maximum values of v to be threshold) and renormalizing again. If the threshold is equal to zero then L2-Hys normalization is not performed.\n \\f[L2norm(v) = \\frac{v}{\\sqrt{\\|v\\|_2^2 + \\epsilon^2}}\\f]\n where \\f$ \\|v\\|_k \\f$ be its k-norm for k=1, 2, and \\f$ \\epsilon \\f$ be a small constant.\n For a specific window its HOG descriptor is then the concatenated vector of the components of the normalized cell histograms from all of the block regions contained in the window.\n The W1xW2 window starting position is at coordinates 0x0.\n If the input image has dimensions that are not an integer multiple of W1xW2 blocks with the specified stride, then the last positions that contain only a partial W1xW2 window\n will be calculated with the remaining part of the W1xW2 window padded with zeroes.\n The Window W1xW2 must also have a size so that it contains an integer number of cells, otherwise the node is not well-defined.\n The final output tensor will contain HOG descriptors equal to the number of windows in the input image.\n The output features tensor has 3 dimensions, given by:\\n\n \\f[[ (floor((image_{width}-window_{width})/window_{stride}) + 1),\\f]\n \\f[ (floor((image_{height}-window_{height})/window_{stride}) + 1),\\f]\n \\f[ floor((window_{width} - block_{width})/block_{stride} + 1) * floor((window_{height} - block_{height})/block_{stride} + 1) *\\f]\n  \\f[ (((block_{width} * block_{height}) / (cell_{width} * cell_{height})) * num_{bins})] \\f]\n See <tt>\\ref vxCreateTensor</tt> and <tt>\\ref vxCreateVirtualTensor</tt>.\n The output tensor from this function may be very large.  For this reason, is it not recommended that this \"immediate mode\" version of the function be used.\n The preferred method to perform this function is as graph node with a virtual tensor as the output.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input image of type <tt>\\ref VX_DF_IMAGE_U8</tt>.\n \\param [in] magnitudes The averge gradient magnitudes per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt>. It is the output of <tt>\\ref vxuHOGCells</tt>.\n \\param [in] bins       The gradient orientation histogram per cell of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt>. It is the output of <tt>\\ref vxuHOGCells</tt>.\n \\param [in] params The parameters of type <tt>\\ref vx_hog_t</tt>.\n \\param [in] hog_param_size Size of <tt>\\ref vx_hog_t</tt> in bytes.\n \\param [out] features The output HOG features of <tt>\\ref vx_tensor</tt> of type <tt>\\ref VX_TYPE_INT16</tt>.\n\n \\ingroup group_vision_function_hog\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuHOGFeatures(
        context: vx_context,
        input: vx_image,
        magnitudes: vx_tensor,
        bins: vx_tensor,
        params: *const vx_hog_t,
        hog_param_size: vx_size,
        features: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Finds the Probabilistic Hough Lines detected in the input binary image, each line is stored in the output array as a set of points (x1, y1, x2, y2) .\n \\details Some implementations of the algorithm may have a random or non-deterministic element. If the target application is in a safety-critical environment this\n should be borne in mind and steps taken in the implementation, the application or both to achieve the level of determinism required by the system design.\n \\param [in] context The reference to the overall context.\n \\param [in] input A single channel binary source image of type <tt>\\ref VX_DF_IMAGE_U8</tt> or <tt>\\ref VX_DF_IMAGE_U1</tt>.\n \\param [in] params parameters of the struct <tt>\\ref vx_hough_lines_p_t</tt>\n \\param [out] lines_array lines_array contains array of lines, see <tt>\\ref vx_line2d_t</tt> The order of lines in implementation dependent\n \\param [out] num_lines [optional] The total number of detected lines in image. Use a VX_TYPE_SIZE scalar\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_hough_lines_p"]
    pub fn vxuHoughLinesP(
        context: vx_context,
        input: vx_image,
        params: *const vx_hough_lines_p_t,
        lines_array: vx_array,
        num_lines: vx_scalar,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Remaps an output image from an input image.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\param [in] table The remap table object.\n \\param [in] policy The interpolation policy from \\ref vx_interpolation_type_e.\n \\ref VX_INTERPOLATION_AREA is not supported.\n \\param [out] output The output <tt>\\ref VX_DF_IMAGE_U8</tt> image.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\ingroup group_vision_function_remap"]
    pub fn vxuRemap(
        context: vx_context,
        input: vx_image,
        table: vx_remap,
        policy: vx_enum,
        output: vx_image,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] The function applies bilateral filtering to the input tensor.\n \\param [in] context The reference to the overall context.\n \\param [in] src The input data a <tt>\\ref vx_tensor</tt>. maximum 3 dimension and minimum 2. The tensor is of type <tt>\\ref VX_TYPE_UINT8</tt> or <tt>\\ref VX_TYPE_INT16</tt>.\n dimensions are [radiometric ,width,height] or [width,height]\n \\param [in] diameter of each pixel neighbourhood that is used during filtering. Values of diameter must be odd. Bigger then 3 and smaller then 10.\n \\param [in] sigmaValues Filter sigma in the radiometric space. Supported values are bigger then 0 and smaller or equal 20.\n \\param [in] sigmaSpace Filter sigma in the spatial space. Supported values are bigger then 0 and smaller or equal 20.\n \\param [out] dst The output data a <tt>\\ref vx_tensor</tt>,Of type <tt>\\ref VX_TYPE_UINT8</tt> or <tt>\\ref VX_TYPE_INT16</tt>. And must be the same type and size of the input.\n \\note The border modes\n  <tt>\\ref VX_NODE_BORDER</tt> value\n  <tt>\\ref VX_BORDER_REPLICATE</tt> and <tt>\\ref VX_BORDER_CONSTANT</tt> are supported.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_bilateral_filter"]
    pub fn vxuBilateralFilter(
        context: vx_context,
        src: vx_tensor,
        diameter: vx_int32,
        sigmaSpace: vx_float32,
        sigmaValues: vx_float32,
        dst: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs element wise multiplications on element values in the input tensor data with a scale.\n \\param [in] context The reference to the overall context.\n \\param [in] input1 Input tensor data.  Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] input2 Input tensor data. The dimensions and sizes of input2 match those of input1, unless the vx_tensor of one or more dimensions in input2 is 1.\n In this case, those dimensions are treated as if this tensor was expanded to match the size of the corresponding dimension of input1,\n and data was duplicated on all terms in that dimension. After this expansion, the dimensions will be equal.\n The data type must match the data type of Input1.\n \\param [in] scale A non-negative <tt>\\ref VX_TYPE_FLOAT32</tt> multiplied to each product before overflow handling.\n \\param [in] overflow_policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] rounding_policy A <tt>\\ref vx_round_policy_e</tt> enumeration.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_multiply\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorMultiply(
        context: vx_context,
        input1: vx_tensor,
        input2: vx_tensor,
        scale: vx_scalar,
        overflow_policy: vx_enum,
        rounding_policy: vx_enum,
        output: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs arithmetic addition on element values in the input tensor data.\n \\param [in] context The reference to the overall context.\n \\param [in] input1 Input tensor data.  Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] input2 Input tensor data. The dimensions and sizes of input2 match those of input1, unless the vx_tensor of one or more dimensions in input2 is 1.\n In this case, those dimensions are treated as if this tensor was expanded to match the size of the corresponding dimension of input1,\n and data was duplicated on all terms in that dimension. After this expansion, the dimensions will be equal.\n The data type must match the data type of Input1.\n \\param [in] policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_add\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorAdd(
        context: vx_context,
        input1: vx_tensor,
        input2: vx_tensor,
        policy: vx_enum,
        output: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs arithmetic subtraction on element values in the input tensor data.\n \\param [in] context The reference to the overall context.\n \\param [in] input1 Input tensor data.  Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] input2 Input tensor data. The dimensions and sizes of input2 match those of input1, unless the vx_tensor of one or more dimensions in input2 is 1.\n In this case, those dimensions are treated as if this tensor was expanded to match the size of the corresponding dimension of input1,\n and data was duplicated on all terms in that dimension. After this expansion, the dimensions will be equal.\n The data type must match the data type of Input1.\n \\param [in] policy A <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_subtract\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorSubtract(
        context: vx_context,
        input1: vx_tensor,
        input2: vx_tensor,
        policy: vx_enum,
        output: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs LUT on element values in the input tensor data.\n \\param [in] context The reference to the overall context.\n \\param [in] input1 Input tensor data. Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt>, with fixed_point_position 0.\n \\param [in] lut The look-up table to use, of type <tt>\\ref vx_lut</tt>.\n The elements of input1 are treated as unsigned integers to determine an index into the look-up table.\n The data type of the items in the look-up table must match that of the output tensor.\n \\param [out] output The output tensor data with the same dimensions as the input tensor data.\n \\ingroup group_vision_function_tensor_tablelookup\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorTableLookup(
        context: vx_context,
        input1: vx_tensor,
        lut: vx_lut,
        output: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs transpose on the input tensor.\n The tensor is transposed according to a specified 2 indexes in the tensor (0-based indexing)\n \\param [in] context The reference to the overall context.\n \\param [in] input Input tensor data, Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [out] output output tensor data,\n \\param [in] dimension1 Dimension index that is transposed with dim 2.\n \\param [in] dimension2 Dimension index that is transposed with dim 1.\n \\ingroup group_vision_function_tensor_transpose\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorTranspose(
        context: vx_context,
        input: vx_tensor,
        output: vx_tensor,
        dimension1: vx_size,
        dimension2: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs a bit-depth conversion.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input tensor. Implementations must support input tensor data type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_position 8,\n and tensor data types <tt>\\ref VX_TYPE_UINT8</tt> and <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_position 0.\n \\param [in] policy A <tt>\\ref VX_TYPE_ENUM</tt> of the <tt>\\ref vx_convert_policy_e</tt> enumeration.\n \\param [in] norm A scalar containing a <tt>\\ref VX_TYPE_FLOAT32</tt> of the normalization value.\n \\param [in] offset A scalar containing a <tt>\\ref VX_TYPE_FLOAT32</tt> of the offset value subtracted before normalization.\n \\param [out] output The output tensor. Implementations must support input tensor data type <tt>VX_TYPE_INT16</tt>. with fixed_point_position 8.\n And <tt>VX_TYPE_UINT8</tt> with fixed_point_position 0.\n \\ingroup group_vision_function_tensor_convert_depth\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorConvertDepth(
        context: vx_context,
        input: vx_tensor,
        policy: vx_enum,
        norm: vx_scalar,
        offset: vx_scalar,
        output: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Performs a generalized matrix multiplication.\n \\param [in] context The reference to the overall context.\n \\param [in] input1 The first input 2D tensor of type <tt>\\ref VX_TYPE_INT16</tt> with fixed_point_pos 8, or tensor data types <tt>\\ref VX_TYPE_UINT8</tt> or <tt>\\ref VX_TYPE_INT8</tt>, with fixed_point_pos 0.\n \\param [in] input2 The second 2D tensor. Must be in the same data type as input1.\n \\param [in] input3 The third 2D tensor. Must be in the same data type as input1. [optional].\n \\param [in] matrix_multiply_params Matrix multiply parameters, see <tt>\\ref vx_tensor_matrix_multiply_params_t </tt>.\n \\param [out] output The output 2D tensor. Must be in the same data type as input1. Output dimension must agree the formula in the description.\n \\ingroup group_vision_function_tensor_matrix_multiply\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>."]
    pub fn vxuTensorMatrixMultiply(
        context: vx_context,
        input1: vx_tensor,
        input2: vx_tensor,
        input3: vx_tensor,
        matrix_multiply_params: *const vx_tensor_matrix_multiply_params_t,
        output: vx_tensor,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Immediate] Copy data from one object to another.\n \\param [in] context The reference to the overall context.\n \\param [in] input The input data object.\n \\param [out] output The output data object.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_copy"]
    pub fn vxuCopy(context: vx_context, input: vx_reference, output: vx_reference) -> vx_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_import {
    _unused: [u8; 0],
}
#[doc = " \\brief The Import Object. Import is a container of OpenVX objects, which may be retreived\n by name\n \\ingroup group_import"]
pub type vx_import = *mut _vx_import;
extern "C" {
    #[doc = " \\brief Imports objects into a context from a vendor-specific format in memory.\\n\n\n \\details This function imports objects from a memory blob previously created using <tt>\\ref vxExportObjectsToMemory</tt>[*REQ*].\\n\n A pointer to memory is given where a list of references is stored, together with the list\n of uses which describes how the references are used. The number of references given and the\n list of uses must match that given upon export, or this function will not be sucessful[*REQ*].\\n\n The *uses* array specifies how the objects in the corresponding *refs* array will be imported:\n - <tt>\\ref VX_IX_USE_APPLICATION_CREATE</tt>\\n\n The application must create the object and supply the reference; the\n  meta-data of the object must match exactly the meta-data of the object when it was exported,\n  except that the name need not match[*REQ*].\\n\n  If the supplied reference has a different name to that stored, the supplied name is used[*REQ*].\n - <tt>\\ref VX_IX_USE_EXPORT_VALUES</tt>\\n\n The implementation will create the object and set the data in it[*REQ*].\\n\n Any data not defined at the time of export of the object will be set to a default value (zero in the\n absence of any other definition) upon import[*REQ*].\n - <tt>\\ref VX_IX_USE_NO_EXPORT_VALUES</tt>\\n\n The implementation will create the object and the importing application will set values as applicable[*REQ*].\n\n References are obtained from the import API for those objects whose references were listed at the time of export.\n These are not the same objects; they are equivalent objects created by the framework at import time.\n The implementation guarantees that references will be available and valid for all objects listed at the time\n of export, or the import will fail[*REQ*].\\n\n The import operation will fail if more than one object whose reference is listed at *refs*\n has been given the same non-zero length name (via <tt>\\ref vxSetReferenceName</tt>)[*REQ*].\\n\n The import will be unsuccessful if any of the parameters supplied is NULL[*REQ*].\\n\n After completion of the function the memory at *ptr* may be deallocated by the application as it will\n not be used by any of the created objects[*REQ*].\\n\n Any delays imported with graphs for which they are registered for auto-aging remain registered\n for auto-aging[*REQ*].\\n\n After import, a graph must execute with exactly the same effect with respect to its visible parameters\n as before export[*REQ*].\n \\note The *refs* array must be the correct length to hold all references of the import; this will be the same length\n that was supplied at the time of export. Only references for objects created by the application, where the\n corresponding *uses* entry is <tt>\\ref VX_IX_USE_APPLICATION_CREATE</tt> should be filled in by the application;\n all other entries will be supplied by the framework and may be initialised by the application to NULL. The *uses* array\n must have the identical length and content as given at the time of export, and the value of *numrefs* must also match;\n these measures increase confidence that the import contains the correct data.\n \\note Graph parameters may be changed after import by using the <tt>\\ref vxSetGraphParameterByIndex</tt> API, and\n images may also be changed by using the <tt>\\ref vxSwapImageHandle</tt> API.\n When <tt>\\ref vxSetGraphParameterByIndex</tt> is used, the framework will check that the new parameter is of the\n correct type to run with the graph, which cannot be re-verified. If the reference supplied is not suitable, an error\n will be returned, but there may be circumstances where changing graph parameters for unsuitable ones is not detected\n and could lead to implementation-dependent behaviour; one such circumstance is when the new parameters are images\n corresponding to overlapping regions of interest. The user should avoid these circumstances.\n In other words,\n  - The meta data of the new graph parameter must match the meta data of the graph parameter it replaces [*REQ*].\n  - A graph parameter must not be NULL [*REQ*].\n \\param [in] context context into which to import objects, must be valid [*REQ*].\n \\param [in] numrefs number of references to import, must match export[*REQ*].\n \\param [in,out] refs references imported or application-created data which must match\n meta-data of the export[*REQ*]\n \\param [in] uses how to import the references, must match export values[*REQ*]\n \\param [in] ptr pointer to binary buffer containing a valid binary export[*REQ*]\n \\param [in] length number of bytes at \\*ptr, i.e. the length of the export[*REQ*]\n \\return A <tt>\\ref vx_import</tt>[*REQ*].\n Calling <tt>\\ref vxGetStatus</tt> with the vx_import as a parameter will return VX_SUCCESS if the\n function was successful[*REQ*].\\n\n Another value is given to indicate that there was an error[*REQ*].\\n\n An implementation may provide several different error codes to give useful diagnostic information\n in the event of failure to import objects, but these are not required to indicate\n possibly recovery mechanisms, and for safety critical use assume errors are not recoverable.\n \\post <tt>\\ref vxReleaseImport</tt> is used to release the import object.\n \\post Use <tt>\\ref vxReleaseReference</tt> or an appropriate specific release function to release\n the references in the array refs when they are no longer required.\n \\ingroup group_import"]
    pub fn vxImportObjectsFromMemory(
        context: vx_context,
        numrefs: vx_size,
        refs: *mut vx_reference,
        uses: *const vx_enum,
        ptr: *const vx_uint8,
        length: vx_size,
    ) -> vx_import;
}
extern "C" {
    #[doc = " \\brief Releases an import object when no longer required.\\n\n \\details This function releases the reference to the import object [*REQ*].\\n\n Other objects including those imported at the time of creation of the import object are unaffected[*REQ*].\\n\n \\param [in,out] import The pointer to the reference to the import object[*REQ*].\n \\post After returning sucessfully from this function the reference is zeroed[*REQ*].\n \\return A <tt>\\ref vx_status</tt> value.\n \\retval VX_SUCCESS If no errors occurred and the import was sucessfully released[*REQ*].\\n\n An error is indicated when the return value is not VX_SUCCESS[*REQ*].\\n\n An implementation may provide several different return values to give useful diagnostic\n information in the event of failure to export, but these are not required to indicate\n possibly recovery mechanisms, and for safety critical use assume errors are not recoverable.\n \\pre <tt>\\ref vxImportObjectsFromMemory</tt> is used to create an import object.\n \\ingroup group_import"]
    pub fn vxReleaseImport(import: *mut vx_import) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Get a reference from the import object by name.\\n\n\n \\details All accessible references of the import object created using <tt>\\ref vxImportObjectsFromMemory</tt> are\n in the array *refs*, which is populated partly by the application before import, and partly by the\n framework. However, it may be more convenient to access the references in the import object without\n referring to this array, for example if the import object is passed as a parameter to another function.\n In this case, references may be retreived by name, assuming that <tt>\\ref vxSetReferenceName</tt>\n was called to assign a name to the reference.\n This function searches the given import for the given name and returns the associated reference[*REQ*].\\n\n The reference may have been named either before export or after import[*REQ*].\\n\n If more than one reference exists in the import with the given name, this is an error[*REQ*].\\n\n Only references in the array *refs* after calling <tt>\\ref vxImportObjectsFromMemory</tt> may be retrieved\n using this function[*REQ*].\\n\n A reference to a named object may be obtained from a valid import object using this API even if all other\n references to the object have been released[*REQ*].\n \\param [in] import The import object in which to find the name; the function will fail if this parameter\n is not valid[*REQ*].\n \\param [in] name The name to find, points to a string of at least one and less than VX_MAX_REFERENCE_NAME bytes\n followed by a zero byte; the function will fail if this is not valid[*REQ*].\n \\return A <tt>\\ref vx_reference</tt>[*REQ*].\\n\n Calling <tt>\\ref vxGetStatus</tt> with the reference as a parameter will return VX_SUCCESS if the function\n was successful[*REQ*].\\n\n Another value is given to indicate that there was an error[*REQ*].\\n\n On success, the reference count of the object in question is incremented[*REQ*].\\n\n An implementation may provide several different error codes to give useful diagnostic information\n in the event of failure to retrieve a reference, but these are not required to indicate\n possibly recovery mechanisms, and for safety critical use assume errors are not recoverable.\n \\pre <tt>\\ref vxSetReferenceName</tt> was used to name the reference.\n \\post use <tt>ref vxReleaseReference</tt> or appropriate specific release function to release a reference\n obtained by this method.\n \\ingroup group_import"]
    pub fn vxGetImportReferenceByName(import: vx_import, name: *const vx_char) -> vx_reference;
}
#[doc = "< \\brief Buffer aliasing type enumeration."]
pub const vx_buffer_aliasing_enum_e_VX_ENUM_BUFFER_ALIASING_TYPE: vx_buffer_aliasing_enum_e = 31;
#[doc = " \\brief Extra enums.\n\n \\ingroup group_buffer_aliasing"]
pub type vx_buffer_aliasing_enum_e = ::std::os::raw::c_uint;
#[doc = " \\brief Dense processing on the buffer that can be aliased"]
pub const vx_buffer_aliasing_processing_type_e_VX_BUFFER_ALIASING_PROCESSING_TYPE_DENSE:
    vx_buffer_aliasing_processing_type_e = 126976;
#[doc = " \\brief Sparse processing on the buffer that can be aliased"]
pub const vx_buffer_aliasing_processing_type_e_VX_BUFFER_ALIASING_PROCESSING_TYPE_SPARSE:
    vx_buffer_aliasing_processing_type_e = 126977;
#[doc = " \\brief Type of processing the kernel will perform on the buffer\n\n Indicates what type of processing the kernel will perform on the buffer. The framework may use this information to\n arbitrate between requests.  For example, if there are two or three conflicting requests for buffer aliasing,\n then the framework may choose to prioritize a request which gives a performance improvement as compared with one\n that only saves memory but otherwise doesn't give a performance improvement.  For example, a kernel which performs\n sparse processing may need to first do a buffer copy before processing if the buffers are not aliased. However a kernel\n which performs dense processing will not need to do this.  So priority of the alias request may be given to the\n kernel which performs sparse processing.\n\n \\ingroup group_buffer_aliasing"]
pub type vx_buffer_aliasing_processing_type_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Notifies framework that the kernel supports buffer aliasing of specified parameters\n\n This is intended to be called from within the vx_publish_kernels_f callback, for applicable\n kernels in between the call to the <tt>\\ref vxAddUserKernel</tt> function and the <tt>\\ref vxFinalizeKernel(kernel)</tt>\n function for the corresponding kernel.\n\n If a kernel can not support buffer aliasing of its parameters (for in-place processing),\n then it should not call this function.  However, if a kernel can support buffer aliasing of\n a pair of its parameters, then it may call this function with the appropriate parameter indices and\n priority value.\n\n Note that calling this function does not guarantee that the buffers will ultimatly be aliased by\n the framework. The framework may consider this hint as part of performance or memory optimization\n logic along with other factors such as graph topology, other competing hints, and if the parameters\n are virtual objects or not.\n\n \\param [in] kernel Kernel reference\n \\param [in] parameter_index_a Index of a kernel parameter to request for aliasing\n \\param [in] parameter_index_b Index of another kernel paramter to request to alias with parameter_index_a\n \\param [in] processing_type Indicate the type of processing on this buffer from the kernel\n              (See <tt>\\ref vx_buffer_aliasing_processing_type_e</tt>)\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE kernel is not a valid reference\n \\retval VX_ERROR_INVALID_PARAMETERS parameter_index_a or parameter_index_b is NOT a valid kernel parameter index\n \\retval VX_FAILURE priority is not a supported enumeration value.\n\n \\ingroup group_buffer_aliasing"]
    pub fn vxAliasParameterIndexHint(
        kernel: vx_kernel,
        parameter_index_a: vx_uint32,
        parameter_index_b: vx_uint32,
        processing_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Query framework if the specified parameters are aliased\n\n This is intended to be called from the vx_kernel_initialize_f or vx_kernel_f callback functions.\n\n If a kernel has called the vxAliasParameterIndexHint function during the vx_publish_kernels_f callback,\n then vxIsParameterAliased is the function that can be called in the init or processing function to\n query if the framework was able to alias the buffers specified.  Based on this information, the kernel\n may execute the kernel differently.\n\n \\param [in] node Node reference\n \\param [in] parameter_index_a Index of a kernel parameter to query for aliasing\n \\param [in] parameter_index_b Index of another kernel paramter to query to alias with parameter_index_a\n\n \\return A <tt>\\ref vx_bool</tt> value.\n \\retval vx_true_e The parameters are aliased.\n \\retval vx_false_e The parameters are not aliased.\n\n \\ingroup group_buffer_aliasing"]
    pub fn vxIsParameterAliased(
        node: vx_node,
        parameter_index_a: vx_uint32,
        parameter_index_b: vx_uint32,
    ) -> vx_bool;
}
#[doc = " \\brief The Classifier Extension scan kernel.\n \\see group_classifier"]
pub const vx_kernel_nn_ext_e_VX_KERNEL_SCAN_CLASSIFIER: vx_kernel_nn_ext_e = 8192;
#[doc = " \\brief The list of Classifier Extension Kernels.\n \\ingroup group_classifier"]
pub type vx_kernel_nn_ext_e = ::std::os::raw::c_uint;
#[doc = "< \\brief Classifier model"]
pub const vx_class_enum_e_VX_ENUM_CLASSIFIER_MODEL: vx_class_enum_e = 30;
#[doc = " \\brief Classifier Extension type enums.\n \\ingroup group_classifier"]
pub type vx_class_enum_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_classifier_model {
    _unused: [u8; 0],
}
#[doc = " \\brief classification model to be used in <tt>\\ref vxScanClassifierNode</tt>.\n The classification models are loadable by undefined binary format see <tt>\\ref vxImportClassifierModel</tt>.\n Extensions will be added to the specification, to support a defined binary format.\n \\ingroup group_object_classifier_model"]
pub type vx_classifier_model = *mut _vx_classifier_model;
#[doc = " \\brief Undefined binary format.\n Using this enumeration will result in an implementation defined behaviour."]
pub const vx_classifier_model_format_e_VX_CLASSIFIER_MODEL_UNDEFINED: vx_classifier_model_format_e =
    122880;
#[doc = " \\brief Classifier model format enums.\n In the main specification only undefined binary format is supported. Extensions to the specification will be added in order to support specific binary format.\n \\ingroup group_object_classifier_model"]
pub type vx_classifier_model_format_e = ::std::os::raw::c_uint;
#[doc = "< \\brief A <tt>\\ref vx_classifier_model</tt>. type"]
pub const vx_classifier_type_e_VX_TYPE_CLASSIFER_MODEL: vx_classifier_type_e = 44;
#[doc = " \\brief The type enumeration lists all classifier extension types.\n \\ingroup group_object_classifier_model"]
pub type vx_classifier_type_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Creates an opaque reference classifier model\n This function creates a classifier model to be used in <tt>\\ref vxScanClassifierNode</tt>. The object classifier object is a read-only constant object. It cannot be changed during graph execution.\n \\param [in] context Reference to the context where to create the ClassifierModel.\n \\param [in] format The binary format which contain the classifier model. See <tt>\\ref vx_classifier_model_format_e</tt>. Currently only undefined binary format is supported.\n Extensions will be added to the specification, to support a classification model defined binary format.\n \\param [in] ptr A memory pointer to the binary format.\n \\param [in] length size in bytes of binary format data.\n \\returns A ClassifierModel reference <tt>\\ref vx_classifier_model</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_object_classifier_model"]
    pub fn vxImportClassifierModel(
        context: vx_context,
        format: vx_enum,
        ptr: *const vx_uint8,
        length: vx_size,
    ) -> vx_classifier_model;
}
extern "C" {
    #[doc = " \\brief Releases a reference of an ClassifierModel object.\n The object may not be garbage collected until its total reference and its contained objects\n count is zero. After returning from this function the reference is zeroed/cleared.\n \\param [in] model The pointer to the ClassifierModel to release.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval <tt>\\ref VX_SUCCESS</tt> No errors; all other values indicate failure\n \\retval * An error occurred. See <tt\\ref >vx_status_e</tt>.\n \\ingroup group_object_classifier_model"]
    pub fn vxReleaseClassifierModel(model: *mut vx_classifier_model) -> vx_status;
}
extern "C" {
    #[doc = " \\brief [Graph] Scans a feature-map (input_feature_map) and detect the classification for each scan-window.\n \\param [in] graph The reference to the graph\n \\param [in] input_feature_map The Feature-map, example is the output of <tt>\\ref vxHOGFeaturesNode</tt>.\n \\param [in] model The pre-trained model loaded. Loaded using <tt>\\ref vxImportClassifierModel</tt>\n \\param [in] scan_window_width Width of the scan window\n \\param [in] scan_window_height Height of the scan window\n \\param [in] step_x Horizontal step-size (along x-axis)\n \\param [in] step_y Vertical step-size (along y-axis)\n \\param [out] object_confidences [Optional] An array of confidences measure, the measure is of type <tt>\\ref VX_TYPE_UINT16</tt>. The confidence measure is defined by the extensions which define classification model with defined binary format.\n This output can be used as class index as well. In case we detect several different classes in single execution. The output will be an array of indexes of the classes.\n \\param [out] object_rectangles An array of object positions, in <tt>\\ref VX_TYPE_RECTANGLE</tt>\n \\param [out] num_objects [optional] The number of object detected in a <tt>\\ref VX_SIZE</tt> scalar\n \\note The border mode <tt>\\ref VX_NODE_BORDER</tt> value <tt>\\ref VX_BORDER_UNDEFINED</tt> is supported.\n \\ingroup group_vision_function_classifier\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>"]
    pub fn vxScanClassifierNode(
        graph: vx_graph,
        input_feature_map: vx_tensor,
        model: vx_classifier_model,
        scanwindow_width: vx_int32,
        scanwindow_height: vx_int32,
        step_x: vx_int32,
        step_y: vx_int32,
        object_confidences: vx_array,
        object_rectangles: vx_array,
        num_objects: vx_scalar,
    ) -> vx_node;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_platform {
    _unused: [u8; 0],
}
#[doc = " \\brief Platform handle of an implementation.\n  \\ingroup group_icd"]
pub type vx_platform = *mut _vx_platform;
extern "C" {
    #[doc = " \\brief Queries list of available platforms.\n \\param [in] capacity Maximum number of items that platform[] can hold.\n \\param [out] platform[] List of platform handles.\n \\param [out] pNumItems Number of platform handles returned.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_FAILURE If no platforms are found.\n \\ingroup group_icd"]
    pub fn vxIcdGetPlatforms(
        capacity: vx_size,
        platform: *mut vx_platform,
        pNumItems: *mut vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries the platform for some specific information.\n \\param [in] platform The platform handle.\n \\param [in] attribute The attribute to query. Use one of the following:\n               <tt>\\ref VX_CONTEXT_VENDOR_ID</tt>,\n               <tt>\\ref VX_CONTEXT_VERSION</tt>,\n               <tt>\\ref VX_CONTEXT_EXTENSIONS_SIZE</tt>,\n               <tt>\\ref VX_CONTEXT_EXTENSIONS</tt>.\n \\param [out] ptr The location at which to store the resulting value.\n \\param [in] size The size in bytes of the container to which \\a ptr points.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE If the platform is not a <tt>\\ref vx_platform</tt>.\n \\retval VX_ERROR_INVALID_PARAMETERS If any of the other parameters are incorrect.\n \\retval VX_ERROR_NOT_SUPPORTED If the attribute is not supported on this implementation.\n \\ingroup group_icd"]
    pub fn vxQueryPlatform(
        platform: vx_platform,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Creates a <tt>\\ref vx_context</tt> from a <tt>\\ref vx_platform</tt>.\n \\details This creates a top-level object context for OpenVX from a platform handle.\n \\returns The reference to the implementation context <tt>\\ref vx_context</tt>. Any possible errors\n preventing a successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n \\ingroup group_icd"]
    pub fn vxCreateContextFromPlatform(platform: vx_platform) -> vx_context;
}
extern "C" {
    #[doc = " \\brief Import a kernel from binary specified by URL.\n\n The name of kernel parameters can be queried using the vxQueryReference API\n with vx_parameter as ref and VX_REFERENCE_NAME as attribute.\n\n \\param context [in] The OpenVX context\n \\param type [in] Vendor-specific identifier that indicates to the implementation\n   how to interpret the url. For example, if an implementation can interpret the url\n   as a file, a folder a symbolic label, or a pointer, then a vendor may choose\n   to use \"vx_<vendor>_file\", \"vx_<vendor>_folder\", \"vx_<vendor>_label\", and\n   \"vx_<vendor>_pointer\", respectively for this field. Container types starting\n   with \"vx_khr_\" are reserved. Refer to vendor documentation for list of\n   container types supported\n \\param url [in] URL to binary container.\n\n \\retval On success, a valid vx_kernel object. Calling vxGetStatus with the return value\n   as a parameter will return VX_SUCCESS if the function was successful.\n\n \\ingroup group_import_kernel"]
    pub fn vxImportKernelFromURL(
        context: vx_context,
        type_: *const vx_char,
        url: *const vx_char,
    ) -> vx_kernel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_context {
    _unused: [u8; 0],
}
pub type cl_context = *mut _cl_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_command_queue {
    _unused: [u8; 0],
}
pub type cl_command_queue = *mut _cl_command_queue;
extern "C" {
    #[doc = " \\brief Create an OpenVX context with specified OpenCL context and global coordination command queue.\n\n This function creates a top-level object context for OpenVX and uses the OpenCL context and\n global coordination command queue created by the application for the interop.\n\n This OpenCL context and global coordination command queue can be queried using\n the VX_CONTEXT_CL_CONTEXT and VX_CONTEXT_CL_COMMAND_QUEUE attributes of vx_context.\n\n If the OpenVX context is created using vxCreateContext or vxCreateContextFromCL with\n opencl_context as NULL, the OpenCL context used by OpenVX is implementation dependent.\n If the opencl_command_queue is NULL, the global coordination command queue used by\n OpenVX is implementation dependent.\n\n The global coordination command queue must be created using the OpenCL context used by OpenVX.\n\n \\param opencl_context [in] The OpenCL context\n \\param opencl_command_queue [in] The global coordination command queue\n\n \\retval On success, a valid vx_context object. Calling vxGetStatus with the return value\n         as a parameter will return VX_SUCCESS if the function was successful.\n\n \\ingroup group_opencl_interop"]
    pub fn vxCreateContextFromCL(
        opencl_context: cl_context,
        opencl_command_queue: cl_command_queue,
    ) -> vx_context;
}
#[doc = "< \\brief Graph schedule mode type enumeration."]
pub const vx_graph_schedule_mode_enum_e_VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE:
    vx_graph_schedule_mode_enum_e = 33;
#[doc = " \\brief Extra enums.\n\n \\ingroup group_pipelining"]
pub type vx_graph_schedule_mode_enum_e = ::std::os::raw::c_uint;
#[doc = " \\brief Schedule graph in non-queueing mode"]
pub const vx_graph_schedule_mode_type_e_VX_GRAPH_SCHEDULE_MODE_NORMAL:
    vx_graph_schedule_mode_type_e = 135168;
#[doc = " \\brief Schedule graph in queueing mode with auto scheduling"]
pub const vx_graph_schedule_mode_type_e_VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO:
    vx_graph_schedule_mode_type_e = 135169;
#[doc = " \\brief Schedule graph in queueing mode with manual scheduling"]
pub const vx_graph_schedule_mode_type_e_VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL:
    vx_graph_schedule_mode_type_e = 135170;
#[doc = " \\brief Type of graph scheduling mode\n\n See <tt>\\ref vxSetGraphScheduleConfig</tt> and <tt>\\ref vxGraphParameterEnqueueReadyRef</tt> for details about each mode.\n\n \\ingroup group_pipelining"]
pub type vx_graph_schedule_mode_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Returns the schedule mode of a graph. Read-only. Use a <tt>\\ref vx_enum</tt> parameter.\n See <tt>\\ref vx_graph_schedule_mode_type_e </tt> enum."]
pub const vx_graph_attribute_pipelining_e_VX_GRAPH_SCHEDULE_MODE: vx_graph_attribute_pipelining_e =
    524805;
#[doc = " \\brief The graph attributes added by this extension.\n \\ingroup group_pipelining"]
pub type vx_graph_attribute_pipelining_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queueing parameters for a specific graph parameter\n\n See <tt>\\ref vxSetGraphScheduleConfig</tt> for additional details.\n\n  \\ingroup group_pipelining"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vx_graph_parameter_queue_params_t {
    pub graph_parameter_index: u32,
    pub refs_list_size: vx_uint32,
    pub refs_list: *mut vx_reference,
}
#[test]
fn bindgen_test_layout_vx_graph_parameter_queue_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<vx_graph_parameter_queue_params_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vx_graph_parameter_queue_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(vx_graph_parameter_queue_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vx_graph_parameter_queue_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vx_graph_parameter_queue_params_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_parameter_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_graph_parameter_queue_params_t),
            "::",
            stringify!(graph_parameter_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs_list_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_graph_parameter_queue_params_t),
            "::",
            stringify!(refs_list_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vx_graph_parameter_queue_params_t),
            "::",
            stringify!(refs_list)
        )
    );
}
extern "C" {
    #[doc = " \\brief Sets the graph scheduler config\n\n This API is used to set the graph scheduler config to\n allow user to schedule multiple instances of a graph for execution.\n\n For legacy applications that don't need graph pipelining or batch processing,\n this API need not be used.\n\n Using this API, the application specifies the graph schedule mode, as well as\n queueing parameters for all graph parameters that need to allow enqueueing of references.\n A single monolithic API is provided instead of discrete APIs, since this allows\n the implementation to get all information related to scheduling in one shot and\n then optimize the subsequent graph scheduling based on this information.\n <b> This API MUST be called before graph verify </b> since\n in this case it allows implementations the opportunity to optimize resources based on\n information provided by the application.\n\n 'graph_schedule_mode' selects how input and output references are provided to a graph and\n how the next graph schedule is triggered by an implementation.\n\n Below scheduling modes are supported:\n\n When graph schedule mode is <tt>\\ref VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</tt>:\n - Application needs to explicitly call <tt>\\ref vxVerifyGraph</tt> before enqueing data references\n - Application should not call <tt>\\ref vxScheduleGraph</tt> or <tt>\\ref vxProcessGraph</tt>\n - When enough references are enqueued at various graph parameters, the implementation\n   could trigger the next graph schedule.\n - Here, not all graph parameters need to have enqueued references for a graph schedule to begin.\n   An implementation is expected to execute the graph as much as possible until a enqueued reference\n   is not available at which time it will stall the graph until the reference becomes available.\n   This allows application to schedule a graph even when all parameters references are\n   not yet available, i.e do a 'late' enqueue. However, exact behaviour is implementation specific.\n\n When graph schedule mode is <tt>\\ref VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</tt>:\n - Application needs to explicitly call <tt>\\ref vxScheduleGraph</tt>\n - Application should not call <tt>\\ref vxProcessGraph</tt>\n - References for all graph parameters of the graph needs to enqueued before <tt>\\ref vxScheduleGraph</tt>\n   is called on the graph else an error is returned by <tt>\\ref vxScheduleGraph</tt>\n - Application can enqueue multiple references at the same graph parameter.\n   When <tt>\\ref vxScheduleGraph</tt> is called, all enqueued references get processed in a 'batch'.\n - User can use <tt>\\ref vxWaitGraph</tt> to wait for the previous <tt>\\ref vxScheduleGraph</tt>\n   to complete.\n\n When graph schedule mode is <tt>\\ref VX_GRAPH_SCHEDULE_MODE_NORMAL</tt>:\n - 'graph_parameters_list_size' MUST be 0 and\n - 'graph_parameters_queue_params_list' MUST be NULL\n - This mode is equivalent to non-queueing scheduling mode as defined by OpenVX v1.2 and earlier.\n\n By default all graphs are in VX_GRAPH_SCHEDULE_MODE_NORMAL mode until this API is called.\n\n 'graph_parameters_queue_params_list' allows to specify below information:\n - For the graph parameter index that is specified, it enables queueing mode of operation\n - Further it allows the application to specify the list of references that it could later\n   enqueue at this graph parameter.\n\n For graph parameters listed in 'graph_parameters_queue_params_list',\n application MUST use <tt>\\ref vxGraphParameterEnqueueReadyRef</tt> to\n set references at the graph parameter.  Using other data access API's on\n these parameters or corresponding data objects will return an error.\n For graph parameters not listed in 'graph_parameters_queue_params_list'\n application MUST use the <tt>\\ref vxSetGraphParameterByIndex</tt> to set the reference\n at the graph parameter.  Using other data access API's on these parameters or\n corresponding data objects will return an error.\n\n This API also allows application to provide a list of references which could be later\n enqueued at the graph parameter. This allows implementation to do meta-data checking\n up front rather than during each reference enqueue.\n\n When this API is called before <tt>\\ref vxVerifyGraph</tt>, the 'refs_list' field\n can be NULL, if the reference handles are not available yet at the application.\n However 'refs_list_size' MUST always be specified by the application.\n Application can call <tt>\\ref vxSetGraphScheduleConfig</tt> again after verify graph\n with all parameters remaining the same except with 'refs_list' field providing\n the list of references that can be enqueued at the graph parameter.\n\n \\param [in] graph Graph reference\n \\param [in] graph_schedule_mode Graph schedule mode. See <tt>\\ref vx_graph_schedule_mode_type_e</tt>\n \\param [in] graph_parameters_list_size Number of elements in graph_parameters_queue_params_list\n \\param [in] graph_parameters_queue_params_list Array containing queuing properties at graph parameters that need to support queueing.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid reference\n \\retval VX_ERROR_INVALID_PARAMETERS Invalid graph parameter queueing parameters\n \\retval VX_FAILURE Any other failure.\n\n \\ingroup group_pipelining"]
    pub fn vxSetGraphScheduleConfig(
        graph: vx_graph,
        graph_schedule_mode: vx_enum,
        graph_parameters_list_size: vx_uint32,
        graph_parameters_queue_params_list: *const vx_graph_parameter_queue_params_t,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Enqueues new references into a graph parameter for processing\n\n This new reference will take effect on the next graph schedule.\n\n In case of a graph parameter which is input to a graph, this function provides\n a data reference with new input data to the graph.\n In case of a graph parameter which is not input to a graph, this function provides\n a 'empty' reference into which a graph execution can write new data into.\n\n This function essentially transfers ownership of the reference from the application to the graph.\n\n User MUST use <tt>vxGraphParameterDequeueDoneRef</tt> to get back the\n processed or consumed references.\n\n The references that are enqueued MUST be the references listed during\n <tt>\\ref vxSetGraphScheduleConfig</tt>. If a reference outside this list is provided then\n behaviour is undefined.\n\n \\param [in] graph Graph reference\n \\param [in] graph_parameter_index Graph parameter index\n \\param [in] refs The array of references to enqueue into the graph parameter\n \\param [in] num_refs Number of references to enqueue\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid reference OR reference is not a valid reference\n \\retval VX_ERROR_INVALID_PARAMETERS graph_parameter_index is NOT a valid graph parameter index\n \\retval VX_FAILURE Reference could not be enqueued.\n\n \\ingroup group_pipelining"]
    pub fn vxGraphParameterEnqueueReadyRef(
        graph: vx_graph,
        graph_parameter_index: vx_uint32,
        refs: *mut vx_reference,
        num_refs: vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Dequeues 'consumed' references from a graph parameter\n\n This function dequeues references from a graph parameter of a graph.\n The reference that is dequeued is a reference that had been previously enqueued into a graph,\n and after subsequent graph execution is considered as processed or consumed by the graph.\n This function essentially transfers ownership of the reference from the graph to the application.\n\n <b> IMPORTANT </b> : This API will block until at least one reference is dequeued.\n\n In case of a graph parameter which is input to a graph, this function provides\n a 'consumed' buffer to the application so that new input data can filled\n and later enqueued to the graph.\n In case of a graph parameter which is not input to a graph, this function provides\n a reference filled with new data based on graph execution. User can then use this\n newly generated data with their application. Typically when this new data is\n consumed by the application the 'empty' reference is again enqueued to the graph.\n\n This API returns an array of references up to a maximum of 'max_refs'. Application MUST ensure\n the array pointer ('refs') passed as input can hold 'max_refs'.\n 'num_refs' is actual number of references returned and will be <= 'max_refs'.\n\n\n \\param [in] graph Graph reference\n \\param [in] graph_parameter_index Graph parameter index\n \\param [out] refs Dequeued references filled in the array\n \\param [in] max_refs Max number of references to dequeue\n \\param [out] num_refs Actual number of references dequeued.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid reference\n \\retval VX_ERROR_INVALID_PARAMETERS graph_parameter_index is NOT a valid graph parameter index\n \\retval VX_FAILURE Reference could not be dequeued.\n\n \\ingroup group_pipelining"]
    pub fn vxGraphParameterDequeueDoneRef(
        graph: vx_graph,
        graph_parameter_index: vx_uint32,
        refs: *mut vx_reference,
        max_refs: vx_uint32,
        num_refs: *mut vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Checks and returns the number of references that are ready for dequeue\n\n This function checks the number of references that can be dequeued and\n returns the value to the application.\n\n See also <tt>\\ref vxGraphParameterDequeueDoneRef</tt>.\n\n \\param [in] graph Graph reference\n \\param [in] graph_parameter_index Graph parameter index\n \\param [out] num_refs Number of references that can be dequeued using <tt>\\ref vxGraphParameterDequeueDoneRef</tt>\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid reference\n \\retval VX_ERROR_INVALID_PARAMETERS graph_parameter_index is NOT a valid graph parameter index\n \\retval VX_FAILURE Any other failure.\n\n \\ingroup group_pipelining"]
    pub fn vxGraphParameterCheckDoneRef(
        graph: vx_graph,
        graph_parameter_index: vx_uint32,
        num_refs: *mut vx_uint32,
    ) -> vx_status;
}
#[doc = "< \\brief Event Type enumeration."]
pub const vx_event_enum_e_VX_ENUM_EVENT_TYPE: vx_event_enum_e = 34;
#[doc = " \\brief Extra enums.\n\n \\ingroup group_event"]
pub type vx_event_enum_e = ::std::os::raw::c_uint;
#[doc = " \\brief Graph parameter consumed event\n\n This event is generated when a data reference at a graph parameter\n is consumed during a graph execution.\n It is used to indicate that a given data reference is no longer used by the graph and can be\n dequeued and accessed by the application.\n\n \\note Graph execution could still be \"in progress\" for rest of the graph that does not use\n this data reference."]
pub const vx_event_type_e_VX_EVENT_GRAPH_PARAMETER_CONSUMED: vx_event_type_e = 139264;
#[doc = " \\brief Graph completion event\n\n This event is generated every time a graph execution completes.\n Graph completion event is generated for both successful execution of a graph\n or abandoned execution of a graph."]
pub const vx_event_type_e_VX_EVENT_GRAPH_COMPLETED: vx_event_type_e = 139265;
#[doc = " \\brief Node completion event\n\n This event is generated every time a node within a graph completes execution."]
pub const vx_event_type_e_VX_EVENT_NODE_COMPLETED: vx_event_type_e = 139266;
#[doc = " \\brief Node error event\n\n This event is generated every time a node returns error within a graph."]
pub const vx_event_type_e_VX_EVENT_NODE_ERROR: vx_event_type_e = 139267;
#[doc = " \\brief User defined event\n\n This event is generated by user application outside of OpenVX framework using the \\ref vxSendUserEvent API.\n User events allow application to have single centralized 'wait-for' loop to handle\n both framework generated events as well as user generated events.\n\n \\note Since the application initiates user events and not the framework, the application\n does NOT register user events using \\ref vxRegisterEvent."]
pub const vx_event_type_e_VX_EVENT_USER: vx_event_type_e = 139268;
#[doc = " \\brief Type of event that can be generated during system execution\n\n \\ingroup group_event"]
pub type vx_event_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_GRAPH_PARAMETER_CONSUMED\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_event_graph_parameter_consumed {
    pub graph: vx_graph,
    pub graph_parameter_index: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_event_graph_parameter_consumed() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event_graph_parameter_consumed> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event_graph_parameter_consumed>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_event_graph_parameter_consumed))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event_graph_parameter_consumed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_vx_event_graph_parameter_consumed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_graph_parameter_consumed),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_parameter_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_graph_parameter_consumed),
            "::",
            stringify!(graph_parameter_index)
        )
    );
}
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_GRAPH_PARAMETER_CONSUMED\n\n \\ingroup group_event"]
pub type vx_event_graph_parameter_consumed = _vx_event_graph_parameter_consumed;
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_GRAPH_COMPLETED\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_event_graph_completed {
    pub graph: vx_graph,
}
#[test]
fn bindgen_test_layout__vx_event_graph_completed() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event_graph_completed> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event_graph_completed>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_event_graph_completed))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event_graph_completed>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_event_graph_completed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_graph_completed),
            "::",
            stringify!(graph)
        )
    );
}
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_GRAPH_COMPLETED\n\n \\ingroup group_event"]
pub type vx_event_graph_completed = _vx_event_graph_completed;
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_NODE_COMPLETED\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_event_node_completed {
    pub graph: vx_graph,
    pub node: vx_node,
}
#[test]
fn bindgen_test_layout__vx_event_node_completed() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event_node_completed> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event_node_completed>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_event_node_completed))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event_node_completed>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_event_node_completed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_node_completed),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_node_completed),
            "::",
            stringify!(node)
        )
    );
}
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_NODE_COMPLETED\n\n \\ingroup group_event"]
pub type vx_event_node_completed = _vx_event_node_completed;
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_NODE_ERROR\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_event_node_error {
    pub graph: vx_graph,
    pub node: vx_node,
    pub status: vx_status,
}
#[test]
fn bindgen_test_layout__vx_event_node_error() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event_node_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event_node_error>(),
        24usize,
        concat!("Size of: ", stringify!(_vx_event_node_error))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event_node_error>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_event_node_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_node_error),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_node_error),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_node_error),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_NODE_ERROR\n\n \\ingroup group_event"]
pub type vx_event_node_error = _vx_event_node_error;
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_USER_EVENT\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_event_user_event {
    pub user_event_parameter: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__vx_event_user_event() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event_user_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event_user_event>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_event_user_event))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event_user_event>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_event_user_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_event_parameter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_user_event),
            "::",
            stringify!(user_event_parameter)
        )
    );
}
#[doc = " \\brief Parameter structure returned with event of type VX_EVENT_USER_EVENT\n\n \\ingroup group_event"]
pub type vx_event_user_event = _vx_event_user_event;
#[doc = " \\brief Parameter structure associated with an event. Depends on type of the event.\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _vx_event_info_t {
    pub graph_parameter_consumed: vx_event_graph_parameter_consumed,
    pub graph_completed: vx_event_graph_completed,
    pub node_completed: vx_event_node_completed,
    pub node_error: vx_event_node_error,
    pub user_event: vx_event_user_event,
}
#[test]
fn bindgen_test_layout__vx_event_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(_vx_event_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_event_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_parameter_consumed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_info_t),
            "::",
            stringify!(graph_parameter_consumed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_completed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_info_t),
            "::",
            stringify!(graph_completed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_completed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_info_t),
            "::",
            stringify!(node_completed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_info_t),
            "::",
            stringify!(node_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event_info_t),
            "::",
            stringify!(user_event)
        )
    );
}
#[doc = " \\brief Parameter structure associated with an event. Depends on type of the event.\n\n \\ingroup group_event"]
pub type vx_event_info_t = _vx_event_info_t;
#[doc = " \\brief Data structure which holds event information\n\n \\ingroup group_event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _vx_event {
    pub type_: vx_enum,
    pub timestamp: vx_uint64,
    pub app_value: vx_uint32,
    pub event_info: vx_event_info_t,
}
#[test]
fn bindgen_test_layout__vx_event() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_event>(),
        48usize,
        concat!("Size of: ", stringify!(_vx_event))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_event>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event),
            "::",
            stringify!(app_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_event),
            "::",
            stringify!(event_info)
        )
    );
}
#[doc = " \\brief Data structure which holds event information\n\n \\ingroup group_event"]
pub type vx_event_t = _vx_event;
extern "C" {
    #[doc = " \\brief Wait for a single event\n\n After <tt> \\ref vxDisableEvents </tt> is called, if <tt> \\ref vxWaitEvent(.. ,.. , vx_false_e) </tt> is called,\n <tt> \\ref vxWaitEvent </tt> will remain blocked until events are re-enabled using <tt> \\ref vxEnableEvents </tt>\n and a new event is received.\n\n If <tt> \\ref vxReleaseContext </tt> is called while an application is blocked on <tt> \\ref vxWaitEvent </tt>, the\n behavior is not defined by OpenVX.\n\n If <tt> \\ref vxWaitEvent </tt> is called simultaneously from multiple thread/task contexts\n then its behaviour is not defined by OpenVX.\n\n \\param context [in] OpenVX context\n \\param event [out] Data structure which holds information about a received event\n \\param do_not_block [in] When value is vx_true_e API does not block and only checks for the condition\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Event received and event information available in 'event'\n \\retval VX_FAILURE No event is received\n\n \\ingroup group_event"]
    pub fn vxWaitEvent(
        context: vx_context,
        event: *mut vx_event_t,
        do_not_block: vx_bool,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Enable event generation\n\n Depending on the implementation, events may be either enabled or disabled by default.\n\n \\param context [in] OpenVX context\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n\n \\ingroup group_event"]
    pub fn vxEnableEvents(context: vx_context) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Disable event generation\n\n When events are disabled, any event generated before this API is\n called will still be returned via \\ref vxWaitEvent API.\n However no additional events would be returned via \\ref vxWaitEvent API\n until events are enabled again.\n\n \\param context [in] OpenVX context\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n\n \\ingroup group_event"]
    pub fn vxDisableEvents(context: vx_context) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Generate user defined event\n\n \\param context [in] OpenVX context\n \\param app_value [in] Application-specified value that will be returned to user as part of vx_event_t.app_value\n                       NOT used by implementation.\n \\param parameter [in] User defined event parameter. NOT used by implementation.\n                       Returned to user as part vx_event_t.event_info.user_event.user_event_parameter field\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n\n \\ingroup group_event"]
    pub fn vxSendUserEvent(
        context: vx_context,
        app_value: vx_uint32,
        parameter: *mut ::std::os::raw::c_void,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Register an event to be generated\n\n Generation of event may need additional resources and overheads for an implementation.\n Hence events should be registered for references only when really required by an application.\n\n This API can be called on graph, node or graph parameter.\n This API MUST be called before doing \\ref vxVerifyGraph for that graph.\n\n \\param ref [in] Reference which will generate the event\n \\param type [in] Type or condition on which the event is generated\n \\param param [in] Specifies the graph parameter index when type is VX_EVENT_GRAPH_PARAMETER_CONSUMED\n \\param app_value [in] Application-specified value that will be returned to user as part of \\ref vx_event_t.app_value.\n                       NOT used by implementation.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE ref is not a valid <tt>\\ref vx_reference</tt> reference.\n \\retval VX_ERROR_NOT_SUPPORTED type is not valid for the provided reference.\n\n \\ingroup group_event"]
    pub fn vxRegisterEvent(
        ref_: vx_reference,
        type_: vx_event_type_e,
        param: vx_uint32,
        app_value: vx_uint32,
    ) -> vx_status;
}
#[doc = "< \\brief Node state type enumeration."]
pub const vx_node_state_enum_e_VX_ENUM_NODE_STATE_TYPE: vx_node_state_enum_e = 35;
#[doc = " \\brief Extra enums.\n\n \\ingroup group_streaming"]
pub type vx_node_state_enum_e = ::std::os::raw::c_uint;
#[doc = " \\brief Node is in steady state (output expected for each invocation)"]
pub const vx_node_state_e_VX_NODE_STATE_STEADY: vx_node_state_e = 143360;
#[doc = " \\brief Node is in pipeup state (output not expected for each invocation)"]
pub const vx_node_state_e_VX_NODE_STATE_PIPEUP: vx_node_state_e = 143361;
#[doc = " \\brief Node state\n\n \\ingroup group_streaming"]
pub type vx_node_state_e = ::std::os::raw::c_uint;
#[doc = " \\brief Queries the state of the node. Read-only. See <tt>\\ref vx_graph_state_e</tt> enum."]
pub const vx_node_attribute_streaming_e_VX_NODE_STATE: vx_node_attribute_streaming_e = 525065;
#[doc = " \\brief The node attributes added by this extension.\n \\ingroup group_streaming"]
pub type vx_node_attribute_streaming_e = ::std::os::raw::c_uint;
#[doc = " \\brief The pipeup output depth required by the kernel.\n This is called by kernels that need to be primed with multiple output buffers before it can\n begin to return them.  A typical use case for this is a source node which needs to provide and\n retain multiple empty buffers to a camera driver to fill.  The first time the graph is executed\n after vxVerifyGraph is called, the framework calls the node associated with this kernel\n (pipeup_output_depth - 1) times before 'expecting' a valid output and calling downstream nodes.\n During this PIPEUP state, the framework provides the same set of input parameters for each\n call, but provides different set of output parameters for each call.  During the STEADY state,\n the kernel may return a different set of output parameters than was given during the execution callback.\n Read-write. Can be written only before user-kernel finalization.\n Use a <tt>\\ref vx_uint32</tt> parameter.\n \\note If not set, it will default to 1.\n \\note Setting a value less than 1 shall return VX_ERROR_INVALID_PARAMETERS"]
pub const vx_kernel_attribute_streaming_e_VX_KERNEL_PIPEUP_OUTPUT_DEPTH:
    vx_kernel_attribute_streaming_e = 525316;
#[doc = " \\brief The pipeup input depth required by the kernel.\n This is called by kernels that need to retain one or more input buffers before it can\n begin to return them.  A typical use case for this is a sink node which needs to provide and\n retain one or more filled buffers to a display driver to display.  The first (pipeup_input_depth - 1)\n times the graph is executed after vxVerifyGraph is called, the framework calls the node associated with this kernel\n without 'expecting' an input to have been consumed and returned by the node.\n During this PIPEUP state, the framework does not reuse any of the input bufers it had given to this node.\n During the STEADY state, the kernel may return a different set of input parameters than was given during\n the execution callback.\n Read-write. Can be written only before user-kernel finalization.\n Use a <tt>\\ref vx_uint32</tt> parameter.\n \\note If not set, it will default to 1.\n \\note Setting a value less than 1 shall return VX_ERROR_INVALID_PARAMETERS"]
pub const vx_kernel_attribute_streaming_e_VX_KERNEL_PIPEUP_INPUT_DEPTH:
    vx_kernel_attribute_streaming_e = 525317;
#[doc = " \\brief The kernel attributes added by this extension.\n \\ingroup group_streaming"]
pub type vx_kernel_attribute_streaming_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Enable streaming mode of graph execution\n\n This API enables streaming mode of graph execution on the given graph. The node given on the API is set as the\n trigger node. A trigger node is defined as the node whose completion causes a new execution of the graph to be\n triggered.\n\n \\param graph [in] Reference to the graph to enable streaming mode of execution.\n \\param trigger_node  [in][optional] Reference to the node to be used for trigger node of the graph.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference\n\n \\ingroup group_streaming"]
    pub fn vxEnableGraphStreaming(graph: vx_graph, trigger_node: vx_node) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Start streaming mode of graph execution\n\n In streaming mode of graph execution, once an application starts graph execution\n further intervention of the application is not needed to re-schedule a graph;\n i.e. a graph re-schedules itself and executes continuously until streaming mode of execution is stopped.\n\n When this API is called, the framework schedules the graph via <tt>\\ref vxScheduleGraph</tt> and\n returns.\n This graph gets re-scheduled continuously until <tt>\\ref vxStopGraphStreaming</tt> is called by the user\n or any of the graph nodes return error during execution.\n\n The graph MUST be verified via \\ref vxVerifyGraph before calling this API.\n Also user application MUST ensure no previous executions of the graph are scheduled before calling this API.\n\n After streaming mode of a graph has been started, a <tt>\\ref vxScheduleGraph</tt> should **not** be used on that\n graph by an application.\n\n <tt>\\ref vxWaitGraph</tt> can be used as before to wait for all pending graph executions\n to complete.\n\n \\param graph [in] Reference to the graph to start streaming mode of execution.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid <tt>\\ref vx_graph</tt> reference.\n\n \\ingroup group_streaming"]
    pub fn vxStartGraphStreaming(graph: vx_graph) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Stop streaming mode of graph execution\n\n This function blocks until graph execution is gracefully stopped at a logical boundary, for example,\n when all internally scheduled graph executions are completed.\n\n \\param graph [in] Reference to the graph to stop streaming mode of execution.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_FAILURE Graph is not started in streaming execution mode.\n \\retval VX_ERROR_INVALID_REFERENCE graph is not a valid reference.\n\n \\ingroup group_streaming"]
    pub fn vxStopGraphStreaming(graph: vx_graph) -> vx_status;
}
#[doc = " \\brief The raw image format structure that is given to the <tt>\\ref vxCreateRawImage</tt> function.\n \\ingroup group_raw_image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_image_raw_format_t {
    #[doc = "< \\brief Pixel Container, see \\ref vx_image_raw_pixel_container_e"]
    pub pixel_container: vx_uint32,
    #[doc = "< \\brief Most significant bit in pixel container"]
    pub msb: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_image_raw_format_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_image_raw_format_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_image_raw_format_t>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_image_raw_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_image_raw_format_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_image_raw_format_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_container) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_format_t),
            "::",
            stringify!(pixel_container)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_format_t),
            "::",
            stringify!(msb)
        )
    );
}
#[doc = " \\brief The raw image format structure that is given to the <tt>\\ref vxCreateRawImage</tt> function.\n \\ingroup group_raw_image"]
pub type vx_image_raw_format_t = _vx_image_raw_format_t;
#[doc = " \\brief The raw image create params structure that is given to the <tt>\\ref vxCreateRawImage</tt> function.\n \\ingroup group_raw_image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_image_raw_create_params_t {
    #[doc = "< \\brief The image width in pixels"]
    pub width: vx_uint32,
    #[doc = "< \\brief The image height in lines (not including meta rows)."]
    pub height: vx_uint32,
    #[doc = "< \\brief The number of exposures contained in the sensor readout for a given timestamp.\nMax supported is \\ref VX_IMAGE_RAW_MAX_EXPOSURES."]
    pub num_exposures: vx_uint32,
    #[doc = "< \\brief Indicates the type of exposure interleaving, if any, in memory. see \\ref vx_image_raw_exposure_interleaving_e."]
    pub exposure_interleaving: vx_uint32,
    #[doc = "< \\brief Array of vx_image_raw_format_t structures indicating the pixel packing and\nbit alignment format of each exposure.  If line_interleaved == vx_false_e, then the number of\nvalid structures in this array should be equal to the value of num_exposures.  If line_interleaved ==\nvx_true_e, then the format should be the same for each exposure in a single buffer, so the\nnumber of valid structures in this array should equal 1."]
    pub format: [vx_image_raw_format_t; 3usize],
    #[doc = "< \\brief Number of lines of meta data at top of sensor readout  (before pixel data)\n(uses the same width as original sensor readout width)"]
    pub meta_height_before: vx_uint32,
    #[doc = "< \\brief Number of lines of meta data at bottom of sensor readout  (after pixel data)\n(uses the same width as original sensor readout width)"]
    pub meta_height_after: vx_uint32,
}
#[test]
fn bindgen_test_layout__vx_image_raw_create_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_image_raw_create_params_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_image_raw_create_params_t>(),
        48usize,
        concat!("Size of: ", stringify!(_vx_image_raw_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_image_raw_create_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_image_raw_create_params_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_exposures) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(num_exposures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure_interleaving) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(exposure_interleaving)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_height_before) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(meta_height_before)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_height_after) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_raw_create_params_t),
            "::",
            stringify!(meta_height_after)
        )
    );
}
#[doc = " \\brief The raw image create params structure that is given to the <tt>\\ref vxCreateRawImage</tt> function.\n \\ingroup group_raw_image"]
pub type vx_image_raw_create_params_t = _vx_image_raw_create_params_t;
#[doc = " \\brief For accessing pointer to full allocated buffer (pixel buffer + meta buffer)."]
pub const vx_image_raw_buffer_access_e_VX_IMAGE_RAW_ALLOC_BUFFER: vx_image_raw_buffer_access_e =
    147456;
#[doc = " \\brief For accessing pointer to pixel buffer only"]
pub const vx_image_raw_buffer_access_e_VX_IMAGE_RAW_PIXEL_BUFFER: vx_image_raw_buffer_access_e =
    147457;
#[doc = " \\brief For accessing pointer to meta buffer only"]
pub const vx_image_raw_buffer_access_e_VX_IMAGE_RAW_META_BEFORE_BUFFER:
    vx_image_raw_buffer_access_e = 147458;
#[doc = " \\brief For accessing pointer to meta buffer only"]
pub const vx_image_raw_buffer_access_e_VX_IMAGE_RAW_META_AFTER_BUFFER:
    vx_image_raw_buffer_access_e = 147459;
#[doc = " \\brief The raw image buffer access enum.\n \\ingroup group_raw_image"]
pub type vx_image_raw_buffer_access_e = ::std::os::raw::c_uint;
#[doc = " \\brief Two bytes per pixel in memory."]
pub const vx_image_raw_pixel_container_e_VX_IMAGE_RAW_16_BIT: vx_image_raw_pixel_container_e =
    151552;
#[doc = " \\brief One byte per pixel in memory."]
pub const vx_image_raw_pixel_container_e_VX_IMAGE_RAW_8_BIT: vx_image_raw_pixel_container_e =
    151553;
#[doc = " \\brief Packed 12 bit mode; Three bytes per two pixels in memory."]
pub const vx_image_raw_pixel_container_e_VX_IMAGE_RAW_P12_BIT: vx_image_raw_pixel_container_e =
    151554;
#[doc = " \\brief The raw image pixel container enum.\n \\ingroup group_raw_image"]
pub type vx_image_raw_pixel_container_e = ::std::os::raw::c_uint;
#[doc = " \\brief Each exposure is readout and stored in separate planes; single exposure per CSI virtual channel."]
pub const vx_image_raw_exposure_interleaving_e_VX_IMAGE_RAW_PLANAR:
    vx_image_raw_exposure_interleaving_e = 155648;
#[doc = " \\brief Each exposure is readout and stored in line interleaved fashion; multiple exposures share same CSI virtual channel."]
pub const vx_image_raw_exposure_interleaving_e_VX_IMAGE_RAW_LINE_INTERLEAVED:
    vx_image_raw_exposure_interleaving_e = 155649;
#[doc = " \\brief Each exposure is readout and stored in pixel interleaved fashion; multiple exposures share same CSI virtual channel."]
pub const vx_image_raw_exposure_interleaving_e_VX_IMAGE_RAW_PIXEL_INTERLEAVED:
    vx_image_raw_exposure_interleaving_e = 155650;
#[doc = " \\brief The raw image exposure interleaving enum.\n \\ingroup group_raw_image"]
pub type vx_image_raw_exposure_interleaving_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a raw sensor image (including multi-exposure and metadata).\n \\details Not guaranteed to exist until the <tt>\\ref vx_graph</tt> containing it has been verified.\n\n \\param [in] context         The reference to the implementation context.\n \\param [in] params          The pointer to a \\ref vx_image_raw_create_params_t structure\n \\param [in] size            The size of the structure pointed to by the params pointer, in bytes.\n\n \\returns An image reference <tt>\\ref vx_image</tt>. Any possible errors preventing a successful\n creation should be checked using <tt>\\ref vxGetStatus</tt>.\n\n \\see vxMapImagePatch to obtain direct memory access to the image data.\n\n \\ingroup group_raw_image"]
    pub fn vxCreateRawImage(
        context: vx_context,
        params: *const vx_image_raw_create_params_t,
        size: vx_size,
    ) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a virtual raw sensor image no direct user access (including multi-exposure and metadata).\n \\details Not guaranteed to exist until the <tt>\\ref vx_graph</tt> containing it has been verified.\n\n Virtual Raw Image Objects are useful when the Raw Image is used as internal graph edge.\n Virtual Raw Image Objects are scoped within the parent graph only.\n\n \\param [in] graph           The reference to the parent graph.\n \\param [in] params          The pointer to a \\ref vx_image_raw_create_params_t structure\n \\param [in] size            The size of the structure pointed to by the params pointer, in bytes.\n\n \\returns A raw image reference <tt>\\ref vx_image</tt>. Any possible errors preventing a successful\n creation should be checked using <tt>\\ref vxGetStatus</tt>.\n\n \\see vxMapImagePatch to obtain direct memory access to the image data.\n\n \\ingroup group_raw_image"]
    pub fn vxCreateVirtualRawImage(
        graph: vx_graph,
        params: *const vx_image_raw_create_params_t,
        size: vx_size,
    ) -> vx_image;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy a rectangular patch from/into an image object plane.\n \\param [in] image The reference to the image object that is the source or the\n destination of the copy.\n \\param [in] image_rect The coordinates of the image patch. The patch must be within\n the bounds of the image. (start_x, start_y) gives the coordinates of the topleft\n pixel inside the patch, while (end_x, end_y) gives the coordinates of the bottomright\n element out of the patch. Must be 0 <= start < end <= number of pixels in the image dimension.\n \\param [in] image_plane_index The plane index of the image object that is the source or the\n destination of the patch copy.\n \\param [in] user_addr The address of a structure describing the layout of the\n user memory location pointed by user_ptr. In the structure, only dim_x, dim_y,\n stride_x and stride_y fields must be provided, other fields are ignored by the function.\n The layout of the user memory must follow a row major order:\n stride_x >= pixel size in bytes, and stride_y >= stride_x * dim_x.\n \\param [in] user_ptr The address of the memory location where to store the requested data\n if the copy was requested in read mode, or from where to get the data to store into the image\n object if the copy was requested in write mode. The accessible memory must be large enough\n to contain the specified patch with the specified layout:\n accessible memory in bytes >= (end_y - start_y) * stride_y.\n \\param [in] usage This declares the effect of the copy with regard to the image object\n using the <tt>\\ref vx_accessor_e</tt> enumeration. For uniform images, only VX_READ_ONLY\n is supported. For other images, Only <tt>\\ref VX_READ_ONLY</tt> and <tt>\\ref VX_WRITE_ONLY</tt> are supported:\n \\param [in] flags An integer that allows passing options to the copy operation.\n \\arg <tt>\\ref VX_READ_ONLY</tt> means that data is copied from the image object into the application memory\n \\arg <tt>\\ref VX_WRITE_ONLY</tt> means that data is copied into the image object from the application memory\n \\param [in] user_mem_type A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n the memory type of the memory referenced by the user_addr.\n \\param [in] flags An integer that allows passing options to the copy operation.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors; any other value indicates failure.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual image that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE image is not a valid <tt>\\ref vx_image</tt> reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\note The application may ask for data outside the bounds of the valid region, but\n such data has an undefined value.\n \\note Some special restrictions apply to <tt>\\ref VX_DF_IMAGE_U1</tt> images.\n \\ingroup group_image"]
    pub fn vxCopyImagePatchWithFlags(
        image: vx_image,
        image_rect: *const vx_rectangle_t,
        image_plane_index: vx_uint32,
        user_addr: *const vx_imagepatch_addressing_t,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
        flags: vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Swap data from one object to another.\n \\note An implementation may optimize away the swap when virtual data objects are used.\n \\param [in] graph The reference to the graph.\n \\param [in, out] first The first data object.\n \\param [in, out] second The second data object with meta-data identical to the input data object.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation\n should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_swap"]
    pub fn vxSwapNode(graph: vx_graph, first: vx_reference, second: vx_reference) -> vx_node;
}
extern "C" {
    #[doc = " \\brief Move data from one object to another. Same as Swap but second parameter is an output\n \\note An implementation may optimize away the move when virtual data objects are used.\n \\param [in] graph The reference to the graph.\n \\param [in, out] first The first data object.\n \\param [out] second The second data object with meta-data identical to the input data object.\n \\return <tt>\\ref vx_node</tt>.\n \\retval vx_node A node reference. Any possible errors preventing a successful creation\n should be checked using <tt>\\ref vxGetStatus</tt>\n \\ingroup group_vision_function_move"]
    pub fn vxMoveNode(graph: vx_graph, first: vx_reference, second: vx_reference) -> vx_node;
}
extern "C" {
    #[doc = " \\brief Swap data from one object to another.\n \\param [in] context The OpenVX context.\n \\param [in, out] first The first data object.\n \\param [in, out] second The second data object with meta-data identical to the input data object.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_swap"]
    pub fn vxuSwap(context: vx_context, first: vx_reference, second: vx_reference) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Move data from one object to another.\n \\note In immediate mode identical to Swap.\n \\param [in]  context The OpenVX context.\n \\param [in, out] first The first data object.\n \\param [out] second The second data object with meta-data identical to the input data object.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS Success\n \\retval * An error occurred. See <tt>\\ref vx_status_e</tt>.\n \\ingroup group_vision_function_move"]
    pub fn vxuMove(context: vx_context, first: vx_reference, second: vx_reference) -> vx_status;
}
#[doc = " \\brief The User Tiling Function tile block size declaration.\n \\details The author of a User Tiling Kernel will use this structure to define\n the dimensionality of the tile block.\n \\ingroup group_tiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_tile_block_size_t {
    #[doc = "< \\brief Tile block width in pixels."]
    pub width: vx_int32,
    #[doc = "< \\brief Tile block height in pixels."]
    pub height: vx_int32,
}
#[test]
fn bindgen_test_layout__vx_tile_block_size_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_tile_block_size_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_tile_block_size_t>(),
        8usize,
        concat!("Size of: ", stringify!(_vx_tile_block_size_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_tile_block_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_tile_block_size_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_block_size_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_block_size_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " \\brief The User Tiling Function tile block size declaration.\n \\details The author of a User Tiling Kernel will use this structure to define\n the dimensionality of the tile block.\n \\ingroup group_tiling"]
pub type vx_tile_block_size_t = _vx_tile_block_size_t;
#[doc = " \\brief The User Tiling Function Neighborhood declaration.\n \\details The author of a User Tiling Kernel will use this structure to define\n the neighborhood surrounding the tile block.\n \\ingroup group_tiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_neighborhood_size_t {
    #[doc = "< \\brief Left of the tile block."]
    pub left: vx_int32,
    #[doc = "< \\brief Right of the tile block."]
    pub right: vx_int32,
    #[doc = "< \\brief Top of the tile block."]
    pub top: vx_int32,
    #[doc = "< \\brief Bottom of the tile block."]
    pub bottom: vx_int32,
}
#[test]
fn bindgen_test_layout__vx_neighborhood_size_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_neighborhood_size_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_neighborhood_size_t>(),
        16usize,
        concat!("Size of: ", stringify!(_vx_neighborhood_size_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_neighborhood_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_neighborhood_size_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_neighborhood_size_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_neighborhood_size_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_neighborhood_size_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_neighborhood_size_t),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " \\brief The User Tiling Function Neighborhood declaration.\n \\details The author of a User Tiling Kernel will use this structure to define\n the neighborhood surrounding the tile block.\n \\ingroup group_tiling"]
pub type vx_neighborhood_size_t = _vx_neighborhood_size_t;
#[doc = " \\brief A structure which describes the tile's parent image.\n \\ingroup group_tiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_image_description_t {
    #[doc = "< \\brief Width of the image"]
    pub width: vx_uint32,
    #[doc = "< \\brief Height of the image"]
    pub height: vx_uint32,
    #[doc = "< \\brief The <tt>\\ref vx_df_image_e</tt> of the image"]
    pub format: vx_df_image,
    #[doc = "< \\brief The number of planes in the image"]
    pub planes: vx_uint32,
    #[doc = "< \\brief The <tt>\\ref vx_channel_range_e</tt> enumeration."]
    pub range: vx_enum,
    #[doc = "< \\brief The <tt>\\ref vx_color_space_e</tt> enumeration."]
    pub space: vx_enum,
}
#[test]
fn bindgen_test_layout__vx_image_description_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_image_description_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_image_description_t>(),
        24usize,
        concat!("Size of: ", stringify!(_vx_image_description_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_image_description_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_vx_image_description_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_description_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_description_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_description_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_description_t),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_description_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_image_description_t),
            "::",
            stringify!(space)
        )
    );
}
#[doc = " \\brief A structure which describes the tile's parent image.\n \\ingroup group_tiling"]
pub type vx_image_description_t = _vx_image_description_t;
#[doc = " \\brief The tile structure declaration.\n \\ingroup group_tiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_tile_t {
    #[doc = " \\brief The array of pointers to the tile's image plane."]
    pub base: [*mut vx_uint8; 4usize],
    #[doc = " \\brief The top left X pixel index within the width dimension of the image."]
    pub tile_x: vx_uint32,
    #[doc = " \\brief The top left Y pixel index within the height dimension of the image."]
    pub tile_y: vx_uint32,
    #[doc = " \\brief The array of addressing structure to describe each plane."]
    pub addr: [vx_imagepatch_addressing_t; 4usize],
    #[doc = " \\brief The output block size structure."]
    pub tile_block: vx_tile_block_size_t,
    #[doc = " \\brief The neighborhood definition."]
    pub neighborhood: vx_neighborhood_size_t,
    #[doc = " \\brief The description and attributes of the image."]
    pub image: vx_image_description_t,
}
#[test]
fn bindgen_test_layout__vx_tile_t() {
    const UNINIT: ::std::mem::MaybeUninit<_vx_tile_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_vx_tile_t>(),
        216usize,
        concat!("Size of: ", stringify!(_vx_tile_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_vx_tile_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_vx_tile_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(tile_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_y) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(tile_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_block) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(tile_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neighborhood) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(neighborhood)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_vx_tile_t),
            "::",
            stringify!(image)
        )
    );
}
#[doc = " \\brief The tile structure declaration.\n \\ingroup group_tiling"]
pub type vx_tile_t = _vx_tile_t;
#[doc = " \\brief This allows a tiling mode kernel to set its input neighborhood."]
pub const vx_kernel_attribute_tiling_e_VX_KERNEL_INPUT_NEIGHBORHOOD: vx_kernel_attribute_tiling_e =
    525319;
#[doc = " \\brief This allows a tiling mode kernel to set its output tile block size."]
pub const vx_kernel_attribute_tiling_e_VX_KERNEL_OUTPUT_TILE_BLOCK_SIZE:
    vx_kernel_attribute_tiling_e = 525320;
#[doc = " \\brief This allows the author to set the border mode on the tiling kernel."]
pub const vx_kernel_attribute_tiling_e_VX_KERNEL_BORDER: vx_kernel_attribute_tiling_e = 525321;
#[doc = " \\brief This determines the per tile memory allocation."]
pub const vx_kernel_attribute_tiling_e_VX_KERNEL_TILE_MEMORY_SIZE: vx_kernel_attribute_tiling_e =
    525322;
#[doc = " \\brief The User Kernel Tiling Attributes.\n \\ingroup group_tiling"]
pub type vx_kernel_attribute_tiling_e = ::std::os::raw::c_uint;
#[doc = " \\brief This allows a tiling mode node to get its input neighborhood."]
pub const vx_node_attribute_tiling_e_VX_NODE_INPUT_NEIGHBORHOOD: vx_node_attribute_tiling_e =
    525067;
#[doc = " \\brief This allows a tiling mode node to get its output tile block size."]
pub const vx_node_attribute_tiling_e_VX_NODE_OUTPUT_TILE_BLOCK_SIZE: vx_node_attribute_tiling_e =
    525068;
#[doc = " \\brief This is the size of the tile local memory area."]
pub const vx_node_attribute_tiling_e_VX_NODE_TILE_MEMORY_SIZE: vx_node_attribute_tiling_e = 525069;
#[doc = " \\brief The User Node Tiling Attributes.\n \\note These are largely unusable by the tiling function, as it doesn't give you the node reference!\n \\ingroup group_tiling"]
pub type vx_node_attribute_tiling_e = ::std::os::raw::c_uint;
#[doc = " \\brief This value indicates that the author of the tiling kernel wrote\n code to handle border conditions into the kernel itself. If this mode\n is set, it can not be overriden by a call to the \\ref vxSetNodeAttribute\n with \\ref VX_NODE_BORDER."]
pub const vx_border_tiling_e_VX_BORDER_MODE_SELF: vx_border_tiling_e = 49155;
#[doc = " \\brief The tiling border mode extensions\n \\ingroup group_tiling"]
pub type vx_border_tiling_e = ::std::os::raw::c_uint;
pub type vx_tiling_kernel_f = ::std::option::Option<
    unsafe extern "C" fn(
        parameters: *mut *mut ::std::os::raw::c_void,
        tile_memory: *mut ::std::os::raw::c_void,
        tile_memory_size: vx_size,
    ),
>;
extern "C" {
    #[doc = " \\brief Allows a user to add a tile-able kernel to the OpenVX system.\n \\param [in] context The handle to the implementation context.\n \\param [in] name The string to be used to match the kernel.\n \\param [in] enumeration The enumerated value of the kernel to be used by clients.\n \\param [in] flexible_func_ptr The process-local flexible function pointer to be invoked.\n \\param [in] fast_func_ptr The process-local fast function pointer to be invoked.\n \\param [in] num_params The number of parameters for this kernel.\n \\param [in] input The pointer to a function which will validate the\n input parameters to this kernel.\n \\param [in] output The pointer to a function which will validate the\n output parameters to this kernel.\n \\note Tiling Kernels do not have access to any of the normal node attributes listed\n in \\ref vx_node_attribute_e.\n \\post Call <tt>\\ref vxAddParameterToKernel</tt> for as many parameters as the function has,\n then call <tt>\\ref vxFinalizeKernel</tt>.\n \\retval 0 Indicates that an error occurred when adding the kernel.\n Note that the fast or flexible formula, but not both, can be NULL.\n \\ingroup group_tiling"]
    pub fn vxAddTilingKernel(
        context: vx_context,
        name: *mut vx_char,
        enumeration: vx_enum,
        flexible_func_ptr: vx_tiling_kernel_f,
        fast_func_ptr: vx_tiling_kernel_f,
        num_params: vx_uint32,
        input: vx_kernel_input_validate_f,
        output: vx_kernel_output_validate_f,
    ) -> vx_kernel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vx_user_data_object {
    _unused: [u8; 0],
}
#[doc = " \\brief The User Data Object. User Data Object is a strongly-typed container for other data structures.\n \\ingroup group_user_data_object"]
pub type vx_user_data_object = *mut _vx_user_data_object;
#[doc = " \\brief The type name of the user data object. Read-only. Use a <tt>\\ref vx_char</tt>[<tt>\\ref VX_MAX_REFERENCE_NAME</tt>] array."]
pub const vx_user_data_object_attribute_e_VX_USER_DATA_OBJECT_NAME:
    vx_user_data_object_attribute_e = 529920;
#[doc = " \\brief The number of bytes in the user data object. Read-only. Use a <tt>\\ref vx_size</tt> parameter."]
pub const vx_user_data_object_attribute_e_VX_USER_DATA_OBJECT_SIZE:
    vx_user_data_object_attribute_e = 529921;
#[doc = " \\brief The user data object attributes.\n \\ingroup group_user_data_object"]
pub type vx_user_data_object_attribute_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Creates a reference to a User Data Object.\n\n User data objects can be used to pass a user kernel defined data structure or blob of memory as a parameter\n to a user kernel.\n\n \\param [in] context      The reference to the overall Context.\n \\param [in] type_name    Pointer to the '\\0' terminated string that identifies the type of object.\n                          The string is copied by the function so that it stays the property of the caller.\n                          The length of the string shall be lower than VX_MAX_REFERENCE_NAME bytes.\n                          The string passed here is what shall be returned when passing the\n                          <tt>\\ref VX_USER_DATA_OBJECT_NAME</tt> attribute enum to the <tt>\\ref vxQueryUserDataObject</tt> function.\n                          In the case where NULL is passed to type_name, then the query of the <tt>\\ref VX_USER_DATA_OBJECT_NAME</tt>\n                          attribute enum will return a single character '\\0' string.\n \\param [in] size         The number of bytes required to store this instance of the user data object.\n \\param [in] ptr          The pointer to the initial value of the user data object. If NULL, then entire size bytes of the user data object\n                          is initialized to all 0s, otherwise, <tt>size</tt> bytes is copied into the object\n                          from ptr to initialize the object\n\n \\returns A user data object reference <tt>\\ref vx_user_data_object</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n\n \\ingroup group_user_data_object"]
    pub fn vxCreateUserDataObject(
        context: vx_context,
        type_name: *const vx_char,
        size: vx_size,
        ptr: *const ::std::os::raw::c_void,
    ) -> vx_user_data_object;
}
extern "C" {
    #[doc = " \\brief Creates an opaque reference to a virtual User Data Object with no direct user access.\n\n Virtual User Data Objects are useful when the User Data Object is used as internal graph edge.\n Virtual User Data Objects are scoped within the parent graph only.\n\n \\param [in] graph        The reference to the parent graph.\n \\param [in] type_name    Pointer to the '\\0' terminated string that identifies the type of object.\n                          The string is copied by the function so that it stays the property of the caller.\n                          The length of the string shall be lower than VX_MAX_REFERENCE_NAME bytes.\n                          The string passed here is what shall be returned when passing the\n                          <tt>\\ref VX_USER_DATA_OBJECT_NAME</tt> attribute enum to the <tt>\\ref vxQueryUserDataObject</tt> function.\n                          In the case where NULL is passed to type_name, then the query of the <tt>\\ref VX_USER_DATA_OBJECT_NAME</tt>\n                          attribute enum will return a single character '\\0' string.\n \\param [in] size         The number of bytes required to store this instance of the user data object.\n\n \\returns A user data object reference <tt>\\ref vx_user_data_object</tt>. Any possible errors preventing a\n successful creation should be checked using <tt>\\ref vxGetStatus</tt>.\n\n \\ingroup group_user_data_object"]
    pub fn vxCreateVirtualUserDataObject(
        graph: vx_graph,
        type_name: *const vx_char,
        size: vx_size,
    ) -> vx_user_data_object;
}
extern "C" {
    #[doc = " \\brief Releases a reference of a User data object.\n The object may not be garbage collected until its total reference count is zero.\n After returning from this function the reference is zeroed.\n \\param [in] user_data_object  The pointer to the User Data Object to release.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS No errors.\n \\retval VX_ERROR_INVALID_REFERENCE If user_data_object is not a <tt>\\ref vx_user_data_object</tt>.\n \\ingroup group_user_data_object"]
    pub fn vxReleaseUserDataObject(user_data_object: *mut vx_user_data_object) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Queries the User data object for some specific information.\n\n \\param [in] user_data_object  The reference to the User data object.\n \\param [in] attribute         The attribute to query. Use a <tt>\\ref vx_user_data_object_attribute_e</tt>.\n \\param [out] ptr              The location at which to store the resulting value.\n \\param [in] size              The size in bytes of the container to which \\a ptr points.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_SUCCESS                   No errors.\n \\retval VX_ERROR_INVALID_REFERENCE   If the \\a user_data_object is not a <tt>\\ref vx_user_data_object</tt>.\n \\retval VX_ERROR_NOT_SUPPORTED       If the \\a attribute is not a value supported on this implementation.\n \\retval VX_ERROR_INVALID_PARAMETERS  If any of the other parameters are incorrect.\n\n \\ingroup group_user_data_object"]
    pub fn vxQueryUserDataObject(
        user_data_object: vx_user_data_object,
        attribute: vx_enum,
        ptr: *mut ::std::os::raw::c_void,
        size: vx_size,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to copy a subset from/into a user data object.\n \\param [in] user_data_object   The reference to the user data object that is the source or the\n                                destination of the copy.\n \\param [in] offset             The byte offset into the user data object to copy.\n \\param [in] size               The number of bytes to copy.  The size must be within the bounds of the user data object:\n                                0 <= (offset + size) <= size of the user data object. If zero, then copy until the end of the object.\n \\param [in] user_ptr           The address of the memory location where to store the requested data\n                                if the copy was requested in read mode, or from where to get the data to store into the user data object\n                                if the copy was requested in write mode. The accessible memory must be large enough\n                                to contain the specified size.\n \\param [in] usage               This declares the effect of the copy with regard to the user data object\n                                using the <tt>\\ref vx_accessor_e</tt> enumeration. Only VX_READ_ONLY and VX_WRITE_ONLY\n                                are supported:\n                                \\arg VX_READ_ONLY means that data are copied from the user data object into the user memory.\n                                \\arg VX_WRITE_ONLY means that data are copied into the user data object from the user memory.\n \\param [in] user_mem_type      A <tt>\\ref vx_memory_type_e</tt> enumeration that specifies\n                                the memory type of the memory referenced by the user_addr.\n\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual user data object that cannot be\n accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE The user_data_object reference is not actually a user data object reference.\n \\retval VX_ERROR_INVALID_PARAMETERS Another parameter is incorrect.\n \\ingroup group_user_data_object"]
    pub fn vxCopyUserDataObject(
        user_data_object: vx_user_data_object,
        offset: vx_size,
        size: vx_size,
        user_ptr: *mut ::std::os::raw::c_void,
        usage: vx_enum,
        user_mem_type: vx_enum,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Allows the application to get direct access to a subset of the user data object.\n \\param [in] user_data_object   The reference to the user data object that contains the subset to map.\n \\param [in] offset             The byte offset into the user data object to map.\n \\param [in] size               The number of bytes to map.  The size must be within the bounds of the user data object:\n                                0 <= (offset + size) <= size of the user data object. If zero, then map until the end of the object.\n \\param [out] map_id            The address of a vx_map_id variable where the function returns a map identifier.\n                                \\arg (*map_id) must eventually be provided as the map_id parameter of a call to\n                                <tt>\\ref vxUnmapUserDataObject</tt>.\n \\param [out] ptr               The address of a pointer that the function sets to the\n                                address where the requested data can be accessed. The returned (*ptr) address\n                                is only valid between the call to the function and the corresponding call to\n                                <tt>\\ref vxUnmapUserDataObject</tt>.\n \\param [in] usage              This declares the access mode for the user data object subset, using\n                                the <tt>\\ref vx_accessor_e</tt> enumeration.\n                                \\arg VX_READ_ONLY: after the function call, the content of the memory location\n                                pointed by (*ptr) contains the user data object subset data. Writing into this memory location\n                                is forbidden and its behavior is implementation specific.\n                                \\arg VX_READ_AND_WRITE : after the function call, the content of the memory\n                                location pointed by (*ptr) contains the user data object subset data; writing into this memory\n                                is allowed only for the location of data and will result in a modification of the\n                                affected data in the user data object once the subset is unmapped.\n                                \\arg VX_WRITE_ONLY: after the function call, the memory location pointed by (*ptr)\n                                contains undefined data; writing to all data in the subset is required prior to\n                                unmapping. Data values not written by the application before unmap may be defined differently in\n                                different implementations after unmap, even if they were well defined before map.\n \\param [in] mem_type           A <tt>\\ref vx_memory_type_e</tt> enumeration that\n                                specifies the type of the memory where the user data object subset is requested to be mapped.\n \\param [in] flags              An integer that allows passing options to the map operation.\n                                Use the <tt>\\ref vx_map_flag_e</tt> enumeration.\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_OPTIMIZED_AWAY This is a reference to a virtual user data object that cannot be accessed by the application.\n \\retval VX_ERROR_INVALID_REFERENCE The user_data_object reference is not actually a user data object reference.\n \\retval VX_ERROR_INVALID_PARAMETERS An other parameter is incorrect.\n \\ingroup group_user_data_object\n \\post <tt>\\ref vxUnmapUserDataObject </tt> with same (*map_id) value."]
    pub fn vxMapUserDataObject(
        user_data_object: vx_user_data_object,
        offset: vx_size,
        size: vx_size,
        map_id: *mut vx_map_id,
        ptr: *mut *mut ::std::os::raw::c_void,
        usage: vx_enum,
        mem_type: vx_enum,
        flags: vx_uint32,
    ) -> vx_status;
}
extern "C" {
    #[doc = " \\brief Unmap and commit potential changes to a user data object subset that was previously mapped.\n Unmapping a user data object subset invalidates the memory location from which the subset could\n be accessed by the application. Accessing this memory location after the unmap function\n completes is implementation specific.\n \\param [in] user_data_object   The reference to the user data object to unmap.\n \\param [in] map_id             The unique map identifier that was returned when calling\n                                <tt>\\ref vxMapUserDataObject</tt> .\n \\return A <tt>\\ref vx_status_e</tt> enumeration.\n \\retval VX_ERROR_INVALID_REFERENCE The user_data_object reference is not actually a user data object reference.\n \\retval VX_ERROR_INVALID_PARAMETERS Another parameter is incorrect.\n \\ingroup group_user_data_object\n \\pre <tt>\\ref vxMapUserDataObject</tt> returning the same map_id value"]
    pub fn vxUnmapUserDataObject(
        user_data_object: vx_user_data_object,
        map_id: vx_map_id,
    ) -> vx_status;
}
